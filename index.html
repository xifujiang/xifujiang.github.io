<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="Content-Language" content="zh-cn">
    <meta charset="utf-8">
    
    
    
    <title>小西芙-沿着回忆我走过旧时光 | 小西芙-沿着回忆我走过旧时光</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    
    <meta name="theme-color" content="#77AAFF">
    
    
    <meta name="keywords" content="xifujiang">
    
    

    

    <!-- Baidu Push -->
<script>
	(function(){
		var bp = document.createElement('script');
		var curProtocol = window.location.protocol.split(':')[0];
		if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
		}
		else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
		}
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(bp, s);
	})();

	var _hmt = _hmt || [];
</script>



    
    <meta name="description" content="呢嚎哟，介里是小西芙的小小博客，请多多关照。顺便说一句夕立立永远是我儿贼！！~">
<meta name="keywords" content="xifujiang">
<meta property="og:type" content="website">
<meta property="og:title" content="小西芙-沿着回忆我走过旧时光">
<meta property="og:url" content="https://xifujiang.github.io/index.html">
<meta property="og:site_name" content="小西芙-沿着回忆我走过旧时光">
<meta property="og:description" content="呢嚎哟，介里是小西芙的小小博客，请多多关照。顺便说一句夕立立永远是我儿贼！！~">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小西芙-沿着回忆我走过旧时光">
<meta name="twitter:description" content="呢嚎哟，介里是小西芙的小小博客，请多多关照。顺便说一句夕立立永远是我儿贼！！~">
    
        <link rel="alternate" type="application/atom+xml" title="小西芙-沿着回忆我走过旧时光" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/icon.ico">
    <link id="style" rel="stylesheet" href="/css/style.css?v=3.0">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    
            
</head>

<body>
    <div id="loading" class="active"></div>
    <aside id="menu">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/timg.png" alt="avatar">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname" id="name">xifujiang</h5>
          
            <div id="yiyanmotto" class="motto">&nbsp;</div>
          
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
              <li class="waves-block waves-effect active">
                  <a href="/">
                    <i class="icon icon-lg icon-home"></i>
                    <span>主 页</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/archives">
                    <i class="icon icon-lg icon-archives"></i>
                    <span>归 档</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/categories">
                    <i class="icon icon-lg icon-th-list"></i>
                    <span>分 类</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/tags">
                    <i class="icon icon-lg icon-tags"></i>
                    <span>标 签</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/about">
                    <i class="icon icon-lg icon-smile-o"></i>
                    <span>关 于</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
      <div class="nav2">
          
              <a class="nav2item" data-title="Email" href="/229694302@qq.com" target="_parent" title="Email">
                <i class="icon icon-lg icon-envelope-o envelope-o"></i>
              </a>
          
              <a class="nav2item" data-title="Github" href="https://github.com/xifujiang" target="_blank" title="Github">
                <i class="icon icon-lg icon-github github"></i>
              </a>
          
              <a class="nav2item" data-title="微博" href="https://www.weibo.com/xifujiang/home?wvr=5&lf=reg" target="_blank" title="微博">
                <i class="icon icon-lg icon-weibo weibo"></i>
              </a>
          

            </div>
        
      </ul>
        
    </div>
  </div>
 
</aside>


    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">小西芙-沿着回忆我走过旧时光</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        <a href="../../atom.xml" target="_blank" class="header-icon waves-effect waves-circle waves-light" id="Rss">
            <i class="icon icon-lg icon-rss"></i>
        </a>
    </div>
</header>
<header class="content-header index-header">
    
    
    <div class="container fade-scale">
        <div id="myheader">
            <h1 class="title">
                 
                    小西芙-沿着回忆我走过旧时光
                
            </h1>
            <h5 class="subtitle">
                
                    小西芙想做机器人鸭
                
            </h5>
        </div>
    </div>

</header>

<div class="container body-wrap">
    <ul class="post-list">
    
        <li class="post-list-item fade">
            <article id="post-01 hadoop" class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/posts/a5ead4c6/">hadoop详细学习</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2019-09-13 17:50:11" datetime="2019-09-13T09:50:11.087Z" itemprop="datePublished">2019-09-13</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h1 id="1、hadoop"><a href="#1、hadoop" class="headerlink" title="1、hadoop"></a>1、hadoop</h1><h2 id="1-1-hadoop介绍"><a href="#1-1-hadoop介绍" class="headerlink" title="1.1 hadoop介绍"></a>1.1 hadoop介绍</h2><p>1）hadoop是一个由Apache基金会所开发的分布式系统基础架构。</p>
<p>2）主要解决海量数据的存储和海量数据的分析计算问题。</p>
<p>3）Hadoop生态圈</p>
    
        <div class="post-more-div">
            <a href="/posts/a5ead4c6/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-09 机器学习" class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/posts/0/">机器学习算法</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2019-09-09 21:04:00" datetime="2019-09-09T13:04:00.000Z" itemprop="datePublished">2019-09-09</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h1 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h1><p>最大期望算法（Expectation-Maximization algorithm, EM），或Dempster-Laird-Rubin算法 [1]  ，是一类通过迭代进行<strong>极大似然估计</strong>（Maximum Likelihood Estimation, MLE）的优化算法 [2]  ，通常作为<strong>牛顿迭代法</strong>（Newton-Raphson method）的替代用于对包含隐变量（latent variable）或缺失数据（incomplete-data）的<strong>概率模型</strong>进行参数估计 [2-3]  。</p>
<p>EM算法的标准计算框架由E步（Expectation-step）和M步（Maximization step）交替组成，算法的收敛性可以确保迭代至少逼近局部极大值 [4]  。EM算法是MM算法（Minorize-Maximization algorithm）的特例之一，有多个改进版本，包括使用了<strong>贝叶斯推断</strong>的EM算法、EM梯度算法、广义EM算法等 [2]  。</p>
<p><a href="https://www.cnblogs.com/jiangxinyang/p/9278608.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiangxinyang/p/9278608.html</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    
        <div class="post-more-div">
            <a href="/posts/0/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-08 java底层面试" class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/posts/0/">JAVA笔试经典题型及原因</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2019-09-09 21:04:00" datetime="2019-09-09T13:04:00.000Z" itemprop="datePublished">2019-09-09</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h1 id="JAVA笔试经典题型及原因"><a href="#JAVA笔试经典题型及原因" class="headerlink" title="JAVA笔试经典题型及原因"></a>JAVA笔试经典题型及原因</h1><h2 id="1、JVM"><a href="#1、JVM" class="headerlink" title="1、JVM"></a>1、JVM</h2><p>​        JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</p>
<p>​        引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>
<h3 id="1、内存管理"><a href="#1、内存管理" class="headerlink" title="1、内存管理"></a>1、内存管理</h3><p>​        （1）Java运行时涉及到的存储区域主要包括程序计数器、Java虚拟机栈、本地方法栈、java堆、方法区以及直接内存等等。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="java/JVM内存.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>
<p>大多数JVM将内存区域划分为 </p>
<p><strong>Method Area(Non-Heap)(方法区),Heap(堆)Program Counter Register(程序计数器), VM Stack(虚拟机栈,也有翻译成JAVA方法栈的)</strong>,<strong>Native Method  Stack本地方法栈)</strong> 。</p>
<p>其中<strong>Method Area(方法区)</strong> 和<strong>Heap（堆）</strong> 是线程共享的，</p>
<p><strong>VM Stack，Native Method Stack  和Program Counter Register</strong>   是非线程共享的。  </p>
<p>​        首先我们熟悉一下一个一般性的   Java 程序的工作过程。一个 Java 源程序文件，会被编译为字节码文件（以 class   为扩展名），每个java程序都需要运行在自己的JVM上，然后告知 JVM 程序的运行入口，再被 JVM   通过字节码解释器加载运行。</p>
<p>​        概括地说来，JVM初始运行的时候都会分配好 <strong>Method Area（方法区）</strong> 和<strong>Heap（堆）</strong> ，而JVM每遇到一个线程，就为其分配一个 <strong>Program Counter Register（程序计数器）</strong> ,   <strong>VM Stack（虚拟机栈）和Native Method Stack （本地方法栈），</strong> 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，<strong>非线程共享的那三个区域的生命周期与所属线程相同</strong>，而<strong>线程共享的区域与JAVA程序运行的生命周期相同</strong>，所以这也是<strong>系统垃圾回收的场所只发生在线程共享的区域</strong>（实际上对大部分虚拟机来说知发生在Heap上）的原因。</p>
<h3 id="2、题目"><a href="#2、题目" class="headerlink" title="2、题目"></a>2、题目</h3><blockquote>
<p>1、下面有关JVM内存，说法错误的是？</p>
<ul>
<li><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">>   A.程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">>   B.虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">>   C.方法区用于存储JVM加载的类信息、常量、静态变量、以及编译器编译后的代码等数据，是线程隔离的</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">>   D.原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</blockquote>
<p>解析：堆区、方法区是线程共享的，程序计数区、虚拟机栈区是线程隔离的。本题选C，出错的原因就在此。</p>
<h2 id="2、SQL"><a href="#2、SQL" class="headerlink" title="2、SQL"></a>2、SQL</h2><h3 id="1、Statement、PreparedStatement、CallableStatement"><a href="#1、Statement、PreparedStatement、CallableStatement" class="headerlink" title="1、Statement、PreparedStatement、CallableStatement"></a>1、Statement、PreparedStatement、CallableStatement</h3><p>1.它们都是接口(interface)。  </p>
<p>2.<strong>Statement</strong>继承自<strong>Wrapper</strong>、<strong>PreparedStatement</strong>继承自<strong>Statement</strong>、<strong>CallableStatement</strong>继承自<strong>PreparedStatement</strong>。</p>
<p>3.<strong>Statement</strong>接口提供了<strong>执行语句和获取结果的基本方法</strong>；  </p>
<p><strong>PreparedStatement</strong>接口添加了<strong>处理 IN 参数的方法</strong>；  </p>
<p><strong>CallableStatement</strong>接口添加了<strong>处理 OUT 参数的方法</strong>。  </p>
<p>4.</p>
<blockquote>
<p>a.<strong>Statement</strong>:  普通的不带参的查询SQL；支持批量更新,批量删除;</p>
<p>b.<strong>PreparedStatement</strong>:  可变参数的SQL,编译一次,执行多次,效率高;  安全性好，有效防止Sql注入等问题;  支持批量更新,批量删除;  </p>
<p>c.<strong>CallableStatement</strong>:  继承自PreparedStatement,支持带参数的SQL操作;  支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;  </p>
</blockquote>
<p><strong>Statement</strong>每次执行sql语句，数据库<strong>都要执行sql语句的编译</strong>,<strong>最好用于仅执行一次查询并返回结果的情形</strong>，效率高于PreparedStatement。</p>
<p><strong>PreparedStatement</strong>是<strong>预编译</strong>的，使用PreparedStatement有几个好处  </p>
<ol>
<li>在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。  </li>
<li>安全性好，有效防止Sql注入等问题。  </li>
<li>对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；  </li>
<li>代码的可读性和可维护性。</li>
</ol>
<h3 id="2、题目-1"><a href="#2、题目-1" class="headerlink" title="2、题目"></a>2、题目</h3><p>1、下面有关jdbc statement的说法错误的是？</p>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">> A.JDBC提供了Statement、PreparedStatement 和 CallableStatement三种方式来执行查询语句，其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询，而 CallableStatement则是用于存储过程</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">> B.对于PreparedStatement来说，数据库可以使用已经编译过及定义好的执行计划，由于 PreparedStatement 对象已预编译过，所以其执行速度要快于 Statement 对象”</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">> C.PreparedStatement中，“?” 叫做占位符，一个占位符可以有一个或者多个值</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">> D.PreparedStatement可以阻止常见的SQL注入式攻击</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>解析：选C，占位符只能有1个值。</p>
<h2 id="3、Spring事务"><a href="#3、Spring事务" class="headerlink" title="3、Spring事务"></a>3、Spring事务</h2><p><strong>事务属性的种类：</strong> <strong>传播行为、隔离级别、只读和事务超时</strong></p>
<p><strong>a)</strong>   <strong>传播行为定义了被调用方法的事务边界。</strong> </p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PROPERGATION_MANDATORY</strong></td>
<td><strong>表示方法必须运行在一个事务中，如果当前事务不存在，就抛出异常</strong></td>
</tr>
<tr>
<td><strong>PROPAGATION_NESTED</strong></td>
<td><strong>表示如果当前事务存在，则方法应该运行在一个嵌套事务中。否则，它看起来和PROPAGATION_REQUIRED</strong> <strong>看起来没什么俩样</strong></td>
</tr>
<tr>
<td><strong>PROPAGATION_NEVER</strong></td>
<td><strong>表示方法不能运行在一个事务中，否则抛出异常</strong></td>
</tr>
<tr>
<td><strong>PROPAGATION_NOT_SUPPORTED</strong></td>
<td><strong>表示方法不能运行在一个事务中，如果当前存在一个事务，则该方法将被挂起</strong></td>
</tr>
<tr>
<td><strong>PROPAGATION_REQUIRED</strong></td>
<td><strong>表示当前方法必须运行在一个事务中，如果当前存在一个事务，那么该方法运行在这个事务中，否则，将创建一个新的事务</strong></td>
</tr>
<tr>
<td><strong>PROPAGATION_REQUIRES_NEW</strong></td>
<td><strong>表示当前方法必须运行在自己的事务中，如果当前存在一个事务，那么这个事务将在该方法运行期间被挂起</strong></td>
</tr>
<tr>
<td><strong>PROPAGATION_SUPPORTS</strong></td>
<td><strong>表示当前方法不需要运行在一个是事务中，但如果有一个事务已经存在，该方法也可以运行在这个事务中</strong></td>
</tr>
</tbody>
</table>
<p><strong>b)</strong>   <strong>隔离级别</strong></p>
<p>在操作数据时可能带来 3个副作用，分别是<strong>脏读、不可重复读、幻读。</strong>为了避免这 3 <strong>中副作用的发生，在标准的 SQL</strong> <strong>语句中定义了 4种隔离级别</strong>，分别是未提交读、已提交读、可重复读、可序列化。而在 spring <strong>事务中提供了 5</strong> <strong>种隔离级别来对应在 SQL</strong> <strong>中定义的 4</strong>种隔离级别，如下：</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ISOLATION_DEFAULT</strong></td>
<td><strong>使用后端数据库默认的隔离级别</strong></td>
</tr>
<tr>
<td><strong>ISOLATION_READ_UNCOMMITTED</strong></td>
<td><strong>允许读取未提交的数据（对应未提交读），可能导致脏读、不可重复读、幻读</strong></td>
</tr>
<tr>
<td><strong>ISOLATION_READ_COMMITTED</strong></td>
<td><strong>允许在一个事务中读取另一个已经提交的事务中的数据（对应已提交读）。可以避免脏读，但是无法避免不可重复读和幻读</strong></td>
</tr>
<tr>
<td><strong>ISOLATION_REPEATABLE_READ</strong></td>
<td><strong>一个事务不可能更新由另一个事务修改但尚未提交（回滚）的数据（对应可重复读）。可以避免脏读和不可重复读，但无法避免幻读</strong></td>
</tr>
<tr>
<td><strong>ISOLATION_SERIALIZABLE</strong></td>
<td><strong>这种隔离级别是所有的事务都在一个执行队列中，依次顺序执行，而不是并行（对应可序列化）。可以避免脏读、不可重复读、幻读。但是这种隔离级别效率很低，因此，除非必须，否则不建议使用。</strong></td>
</tr>
</tbody>
</table>
<p><strong>c)</strong>    <strong>只读</strong></p>
<p><strong>如果在一个事务中所有关于数据库的操作都是只读的，也就是说，这些操作只读取数据库中的数据，而并不更新数据，那么应将事务设为只读模式（ READ_ONLY_MARKER</strong> <strong>） ,</strong> <strong>这样更有利于数据库进行优化</strong> <strong>。</strong></p>
<p><strong>因为只读的优化措施是事务启动后由数据库实施的，因此，只有将那些具有可能启动新事务的传播行为(PROPAGATION_NESTED</strong> <strong>、 PROPAGATION_REQUIRED</strong> <strong>、 PROPAGATION_REQUIRED_NEW)</strong> <strong>的方法的事务标记成只读才有意义。</strong></p>
<p><strong>如果使用 Hibernate</strong> <strong>作为持久化机制，那么将事务标记为只读后，会将 Hibernate</strong> <strong>的 flush</strong> <strong>模式设置为 FULSH_NEVER,</strong> <strong>以告诉 Hibernate</strong> <strong>避免和数据库之间进行不必要的同步，并将所有更新延迟到事务结束。</strong></p>
<p><strong>d)</strong>   <strong>事务超时</strong></p>
<p><strong>如果一个事务长时间运行，这时为了尽量避免浪费系统资源，应为这个事务设置一个有效时间，使其等待数秒后自动回滚。与设</strong></p>
<p><strong>置“只读”属性一样，事务有效属性也需要给那些具有可能启动新事物的传播行为的方法的事务标记成只读才有意义。</strong></p>
<h3 id="2、题目-2"><a href="#2、题目-2" class="headerlink" title="2、题目"></a>2、题目</h3><p>下面有关SPRING的事务传播特性，说法错误的是？</p>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">> A.PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行</span><br><span class="line">> B.PROPAGATION_REQUIRED：支持当前事务，如果当前没有事务，就抛出异常</span><br><span class="line">> C.PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起</span><br><span class="line">> D.PROPAGATION_NESTED：支持当前事务，新增Savepoint点，与当前事务同步提交或回滚</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>解析：</p>
<p>PROPAGATION_REQUIRED–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 </p>
<p><strong>PROPAGATION_SUPPORTS</strong>–支持当前事务，如果当前没有事务，就以非事务方式执行。<br><strong>PROPAGATION_MANDATORY</strong>–支持当前事务，如果当前没有事务，就抛出异常。<br><strong>PROPAGATION_REQUIRES_NEW</strong>–新建事务，如果当前存在事务，把当前事务挂起。<br><strong>PROPAGATION_NOT_SUPPORTED</strong>–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br><strong>PROPAGATION_NEVER</strong>–以非事务方式执行，如果当前存在事务，则抛出异常。 </p>
<p>所以答案选择B。</p>
<h2 id="4、Servlet"><a href="#4、Servlet" class="headerlink" title="4、Servlet"></a>4、Servlet</h2><h3 id="1、CGI简介"><a href="#1、CGI简介" class="headerlink" title="1、CGI简介"></a>1、CGI简介</h3><p>CGI（Common Gateway Interface）<strong>公共网关接口</strong>，是外部扩展应用程序与 Web 服务器交互的一个标准接口。服务器端与客户端进行交互的常见方式多，CGI 技术就是其中之一。根据CGI标准，编写外部扩展应用程序，可以对客户端浏览器输入的数据进行处理，完成客户端与服务器的交互操作。CGI规范定义了Web服务器如何向扩展应用程序发送消息，在收到扩展应用程序的信息后又如何进行处理等内容。对于许多静态的HTML网页无法实现的功能，通过 CGI可以实现，比如表单的处理、对数据库的访问、搜索引擎、基于Web的数据库访问等等。使用CGI实现客户端与服务器的交互有以下几个标准步骤，具体步骤如下：</p>
<p>（1）Web 客户端的浏览器将URL的第一部分解码与Web服务器相连。</p>
<p>（2）Web 浏览器将URL的其余部分提供给服务器。</p>
<p>（3）Web 服务器将URL转换成路径和文件名。</p>
<p>（4）Web 服务器发送 HTML 和别的组成请求页面的文件给客户。一旦页面内容传送完，</p>
<p>这个连接自动断开。</p>
<p>（5）在客户端，HTML脚本提示用户做动作或输入。当用户响应后，客户请求Web服务器建立一个新的连接。</p>
<p>（6）Web 服务器把这些信息和别的进程变量传送给由HTML以URL的形式指定CGI程序。</p>
<p>（7）CGI 根据输入作出响应，把响应结果传送给 Web 服务器。</p>
<p>（8）Web 服务器把响应的数据传给客户，完成后关闭连接。</p>
<h3 id="2、Servlet简介"><a href="#2、Servlet简介" class="headerlink" title="2、Servlet简介"></a>2、Servlet简介</h3><p>Servlet（Server Applet）是Java Servlet的简称，称为小服务程序或服务连接器，用Java编写的服务器端程序，具有<strong>独立于平台和协议</strong>的特性，主要功能在于<strong>交互式地浏览和生成数据，生成动态Web内容</strong>。</p>
<h3 id="3、Servlet生命周期"><a href="#3、Servlet生命周期" class="headerlink" title="3、Servlet生命周期"></a>3、Servlet生命周期</h3><ol>
<li>客户端请求该 <strong>Servlet</strong>；</li>
<li>加载 <strong>Servlet</strong> 类到内存；</li>
<li>实例化并调用<strong>init()</strong>方法初始化该 <strong>Servlet</strong>；</li>
<li><strong>service()</strong>（根据请求方法不同调用<strong>doGet()</strong> 或者 <strong>doPost()</strong>，此外还有<strong>doHead()、doPut()、doTrace()、doDelete()、doOptions()、destroy()</strong>。</li>
<li>加载和实例化 <strong>Servlet</strong>。这项操作一般是动态执行的。然而，<strong>Server</strong> 通常会提供一个管理的选项，用于在 <strong>Server</strong> 启动时强制装载和初始化特定的 <strong>Servlet</strong>。</li>
</ol>
<h3 id="4、Servlet与CGI对比"><a href="#4、Servlet与CGI对比" class="headerlink" title="4、Servlet与CGI对比"></a>4、Servlet与CGI对比</h3><blockquote>
<p>与传统的 CGI 和许多其他类似 CGI 的技术相比，Java Servlet 具有更高的效率，更容易使用，功能更强大，具有更好的可移植性，更节省投资。在未来的技术发展过程中，Servlet 有可能彻底取代 CGI。</p>
<p>在传统的 CGI中，每个请求都要启动一个新的进程，如果 CGI 程序本身的执行时间较短，启动进程所需要的开销很可能反而超过实际执行时间。而在 Servlet 中，每个请求由一个轻量级的 Java 线程处理（而不是重量级的操作系统进程）。</p>
<p>在传统 CGI 中，如果有 N 个并发的对同一 CGI程序的请求，则该CGI程序的代码在内存中重复装载了 N 次；而对于 Servlet，处理请求的是 N 个线程，只需要一份 Servlet 类代码。在性能优化方面，Servlet 也比 CGI 有着更多的选择。</p>
</blockquote>
<h3 id="5、题目"><a href="#5、题目" class="headerlink" title="5、题目"></a>5、题目</h3><p>1、下面有关servlet和cgi的描述，说法错误的是？</p>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">> A.servlet处于服务器进程中，它通过多线程方式运行其service方法</span><br><span class="line">> B.CGI对每个请求都产生新的进程，服务完成后就销毁</span><br><span class="line">> C.servlet在易用性上强于cgi，它提供了大量的实用工具例程，例如自动地解析和解码HTML表单数据、读取和设置HTTP头、处理Cookie、跟踪会话状态等</span><br><span class="line">> D.cgi在移植性上高于servlet，几乎所有的主流服务器都直接或通过插件支持cgi</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>解析：cgi的移植性很差</p>
<p>2、下面有关servlet service描述错误的是？</p>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">> A.不管是post还是get方法提交过来的连接，都会在service中处理</span><br><span class="line">> B.doGet/doPost 则是在 javax.servlet.GenericServlet 中实现的</span><br><span class="line">> C.service()是在javax.servlet.Servlet接口中定义的</span><br><span class="line">> D.service判断请求类型，决定是调用doGet还是doPost方法</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>解析：doget/dopost与Http协议有关，是在 javax.servlet.http.HttpServlet 中实现的</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="java/servlet实现图.png" alt="img" title>
                </div>
                <div class="image-caption">img</div>
            </figure>
<p>3、下列有关Servlet的生命周期，说法不正确的是？</p>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">> A.在创建自己的Servlet时候，应该在初始化方法init()方法中创建Servlet实例</span><br><span class="line">> B.在Servlet生命周期的服务阶段，执行service()方法，根据用户请求的方法，执行相应的doGet()或是doPost()方法</span><br><span class="line">> C.在销毁阶段，执行destroy()方法后会释放Servlet 占用的资源</span><br><span class="line">> D.destroy()方法仅执行一次，即在服务器停止且卸载Servlet时执行该方法</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>解析：init()不是来创造servlet实例，而是用于初始化。详细见上面的生命周期。选A。</p>
<p>4、下面有关servlet中init,service,destroy方法描述错误的是？</p>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">> A.init()方法是servlet生命的起点。一旦加载了某个servlet，服务器将立即调用它的init()方法</span><br><span class="line">> B.service()方法处理客户机发出的所有请求</span><br><span class="line">> C.destroy()方法标志servlet生命周期的结束</span><br><span class="line">> D.servlet在多线程下使用了同步机制，因此，在并发编程下servlet是线程安全的</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>解析：选D</p>
<p>  servlet在多线程下其本身并不是线程安全的。 如果<strong>在类中定义成员变量，而在service中根据不同的线程对该成员变量进行更改，那么在并发的时候就会引起错误</strong>。最好是在方法中，<strong>定义局部变量</strong>，而不是类变量或者对象的成员变量。由于<strong>方法中的局部变量是在栈</strong>中，彼此<strong>各自都拥有独立的运行空间*</strong>而不会互相干扰，因此才做到线程安全。</p>
<h3 id="5、Struts2"><a href="#5、Struts2" class="headerlink" title="5、Struts2"></a>5、Struts2</h3><p>1、下面有关struts1和struts2的区别，描述错误的是？</p>
<blockquote>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">> A.Struts1要求Action类继承一个抽象基类。Struts 2 Action类可以实现一个Action接口</span><br><span class="line">> B.Struts1 Action对象为每一个请求产生一个实例。Struts2 Action是单例模式并且必须是线程安全的</span><br><span class="line">> C.Struts1 Action 依赖于Servlet API，Struts 2 Action不依赖于容器，允许Action脱离容器单独被测试</span><br><span class="line">> D.Struts1 整合了JSTL，Struts2可以使用JSTL，但是也支持OGNL</span><br><span class="line">></span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>解析：选B， struts2是多例模式</p>
<p>从action类上分析:<br>    1.Struts1要求Action类继承一个抽象基类。Struts1的一个普遍问题是使用抽象类编程而不是接口。 </p>
<ol start="2">
<li>Struts 2 Action类可以实现一个Action接口，也可实现其他接口，使可选和定制的服务成为可能。Struts2提供一个ActionSupport基类去实现常用的接口。Action接口不是必须的，任何有execute标识的POJO对象都可以用作Struts2的Action对象。<br>从Servlet 依赖分析: </li>
<li>Struts1 Action 依赖于Servlet API ,因为当一个Action被调用时HttpServletRequest 和 HttpServletResponse 被传递给execute方法。 </li>
<li>Struts 2 Action不依赖于容器，允许Action脱离容器单独被测试。如果需要，Struts2 Action仍然可以访问初始的request和response。但是，其他的元素减少或者消除了直接访问HttpServetRequest 和 HttpServletResponse的必要性。<br>从action线程模式分析: </li>
<li>Struts1 Action是单例模式并且必须是线程安全的，因为仅有Action的一个实例来处理所有的请求。单例策略限制了Struts1 Action能作的事，并且要在开发时特别小心。Action资源必须是线程安全的或同步的。 </li>
<li>Struts2 Action对象为每一个请求产生一个实例，线程不安全。（实际上，servlet容器给每个请求产生许多可丢弃的对象，并且不会导致性能和垃圾回收问题）</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    
        <div class="post-more-div">
            <a href="/posts/0/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-vue项目创建" class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/posts/0/">No title</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2019-08-08 11:08:59" datetime="2019-08-08T03:08:59.729Z" itemprop="datePublished">2019-08-08</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <hr>
<p>time：2019/7/28</p>
<h2 id="author：西芙酱"><a href="#author：西芙酱" class="headerlink" title="author：西芙酱"></a>author：西芙酱</h2><h1 id="1、Vue-项目创建过程"><a href="#1、Vue-项目创建过程" class="headerlink" title="1、Vue 项目创建过程"></a>1、Vue 项目创建过程</h1><h2 id="1-1项目搭建过程"><a href="#1-1项目搭建过程" class="headerlink" title="1.1项目搭建过程"></a>1.1项目搭建过程</h2><ul>
<li><p>创建项目</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> vue init webpack projectname</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>运行项目</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> npm run dev</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
    
        <div class="post-more-div">
            <a href="/posts/0/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-06 git上传" class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/posts/0/">git上传仓库步骤</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2019-07-15 17:33:15" datetime="2019-07-15T09:33:15.538Z" itemprop="datePublished">2019-07-15</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h1 id="git上传仓库步骤"><a href="#git上传仓库步骤" class="headerlink" title="git上传仓库步骤"></a>git上传仓库步骤</h1><p>有关git上传仓库步骤，请享用。</p>
    
        <div class="post-more-div">
            <a href="/posts/0/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-05 hbase笔记" class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/posts/346bfea7/">hbase笔记</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2019-05-09 15:36:00" datetime="2019-05-09T07:36:00.000Z" itemprop="datePublished">2019-05-09</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <p>通用命令</p>
<pre><code>status: 提供HBase的状态，例如，服务器的数量。
version: 提供正在使用HBase版本。    
table_help: 表引用命令提供帮助。
whoami: 提供有关用户的信息。
</code></pre><p>数据定义语言（表操作命令）。</p>
    
        <div class="post-more-div">
            <a href="/posts/346bfea7/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-01 .bat批量把txt中想要的信息存放到excel" class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/posts/5fe19fd1/">bat批量存放信息到excel</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2019-03-28 14:34:00" datetime="2019-03-28T06:34:00.000Z" itemprop="datePublished">2019-03-28</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <center>![Git][git]</center>

<p>最近喵仙子有个需求，需要抽取大量.log文件中的有效信息到excel，刚开始我用mapreduce给他做了一份，不过他有点蠢配不了环境，于是乎我研究了下bat，终于给他整了个好方法，请看下文。</p>
<p><code>需求</code></p>
<p>需要从log中抽取两列数据到excel中。</p>
    
        <div class="post-more-div">
            <a href="/posts/5fe19fd1/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-03 python入门笔记" class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/posts/c00b24b1/">python笔记</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2019-03-28 14:34:00" datetime="2019-03-28T06:34:00.000Z" itemprop="datePublished">2019-03-28</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h1 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h1><p>1、ipython命令技能实现python命令，也能实现部分linux命令。<br>2、python2不能识别文件里的中文，如果硬要识别，在头文件中加上 -<em>- coding:utf-8 -</em>- （python官方推荐这种方式）<br>3、输入一个数</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">high = input("请输入一个数")</span><br></pre></td></tr></tbody></table></figure>
    
        <div class="post-more-div">
            <a href="/posts/c00b24b1/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-02 HDFS上传和读取流程" class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/posts/e4062a35/">HDFS上传和读取流程</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2019-03-28 14:34:00" datetime="2019-03-28T06:34:00.000Z" itemprop="datePublished">2019-03-28</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <center>![Git][git]</center>

<h3 id="上传流程"><a href="#上传流程" class="headerlink" title="上传流程"></a>上传流程</h3><ul>
<li>1.根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在。</li>
<li>2.namenode返回是否可以上传</li>
<li>3.client请求第一个 block该传输到哪些datanode服务器上</li>
<li></li></ul>
    
        <div class="post-more-div">
            <a href="/posts/e4062a35/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-07 linux" class="article-card article-type-post" itemprop="blogPost">

    


  
    <h3 class="post-title" itemprop="name">
      <a href="/posts/0/">Linux复习</a>
    </h3>
  




     <div class="post-meta">
        <time class="post-time" title="2019-03-28 14:34:00" datetime="2019-03-28T06:34:00.000Z" itemprop="datePublished">2019-03-28</time>

    </div>

    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h1 id="Linux复习"><a href="#Linux复习" class="headerlink" title="Linux复习"></a>Linux复习</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>linux系统诞生于1991年，由芬兰大学生李纳斯（Linux Torvalds）。</p>
    
        <div class="post-more-div">
            <a href="/posts/0/" class="post-more waves-button">
                阅读全文 »
            </a>
        </div>
    </div>
    
</article>

        </li>
    
    </ul>

    
<nav id="page-nav">
    <div class="inner">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
    </div>
</nav>


</div>

        <footer class="footer">
    <div class="footer-content">
        <span class="power">
            <i class="icon icon-lg icon-copyright"></i>
            2019
            <i class="icon icon-lg icon-heart"></i>
            <a href="https://xifujiang.github.io">xifuxili.com.cn</a>
            <br>
            Power by
            <a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a>&nbsp;·&nbsp;
            Theme
            <a class="tomotoeslink" href="https://github.com/tomotoes/hexo-theme-tomotoes/" target="_blank" rel="external nofollow">tomotoes</a>
        </span>

        <br>

        <span id="RunTime" style="color:#a7a7a2;"></span>
        <br>

        <span>
            
	<i class="icon icon-lg icon-user">
<span id="busuanzi_container_site_uv" style="display:none">
       访问用户：<span id="busuanzi_value_site_uv"></span>
    </span>人</i>
    ·
    <i class="icon icon-lg icon-eye">
    <span id="busuanzi_container_site_pv" style="display:none">
      访问次数：<span id="busuanzi_value_site_pv"></span>
    </span>次
    </i>


        </span>
        <br>

        <span class="license"><a target="_blank" rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">博客内容遵循 知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
    </div>
</footer>

    </main>
    
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <!-- waves按钮特效 -->
<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<!-- 主题配置脚本 -->
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };
</script>

<!-- jquery -->
<script src="/js/jquery.min.js?v=3.0"></script>

<!-- 搜索 -->

<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item waves-block waves-effect" onclick="location.href='{path}'">
    <div class="title ellipsis" title="{title}">{title}</div>
</li>
</template>


<!-- main博客脚本 -->
<script src="/js/main.min.js?v=3.0"></script>

<!-- 动画&配置 -->
<script src="/js/script.min.js?v=3.0"></script>

<!-- 脚本管理 -->
<script>

if(window.innerWidth > 800){
	/* 3D标题 */
	$(".content-header").on("mousemove", threedee);

	/* 底部追随鼠标 */
	$(".footer").hover(2);

	/* gotop键的涟漪 */
	$("#gotop").hover(1);

	/* 赞赏的粒子雨 */
	$("#reward").hover(3);

	/* 微信公众号的底部渲染 */
	$("#wechat").hover(4);

    /* 标题跳动 */
    $(".archivestitle").bumpyText();

	/* 图片点击放大 */
	const postimg = jQuery(".post-content img:not(.github-emoji)");
	postimg.on("click",function(){

		mask.classList.add("in");
		main.classList.add("Mask");
		menu.classList.add("Mask");
		var myimg = this.cloneNode(true);
		myimg.classList.add("imgShow");

		setTimeout(function(){
			jQuery(myimg).animate({
				opacity:"1"
			},1000);
		},0);

		document.body.appendChild(myimg);

		myimg.onclick=function(){
			document.body.removeChild(myimg);
			mask.classList.remove("in");
			main.classList.remove("Mask");
			menu.classList.remove("Mask");
		};

	});

}

/* 名字跳动 */
$("#name").bumpyText();


/* 网站运行时间 */
setInterval(function () {
	setTime("2019/04/29");
}, 1000);

/* 文章块的淡出 */
postshow();

/* 座右铭 */

   getHitokoto();



/* 粘贴提示 */
G($(".post-content"), location.href, "xifujiang");


/* 控制台 */
if (window.console && window.console.log) {
	setTimeout(function () {
		console.log("\n %c 倔强小西芙 %c  © Xifu Mua~  https://weibo.com/xifujiang \n\n", "color:#FFFFFB;background:#1abc9c;padding:5px 0;border-radius:.5rem 0 0 .5rem;", "color:#FFFFFB;background:#080808;padding:5px 0;border-radius:0 .5rem .5rem 0;");
	}, 0);
}

</script>




<!-- 公式渲染 -->



<!-- 不蒜子 -->

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</body>
</html>
