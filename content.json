[{"title":"","date":"2019-04-29T12:05:20.134Z","path":"/posts/undefined/","text":"date:2019-03-28 14:34 title:04 python爬虫笔记爬虫如何抓取网页数据网页三大特征：1、网页都有自己的唯一的URL（统一资源定位符）来进行定位。2、网页都使用HTML(超文本标记语言)来描述页面信息。3、网页都使用HTTP/HTTPS(超文本传输协议)协议来传输HTML数据。 爬虫的设计思路1、首先确定需要爬取的网页URL地址。2、通过HTTP/HTTP协议协议来获取对应的HTML页面。3、提取HTML页面里有用的数据： a.如果是需要的数据，就保存起来。 b.如果是页面里的其他URL，那就继续执行第二步。 #为什么选择Python做爬虫？PHP：是世界上最好的语言，但他天生不是干爬虫的，对多线程，异步支持不够好。爬虫是工具性程序，对速度和效率的要求比较高。Java爬虫生态圈很完善，是Python爬虫最大的对手。但是Java语言本身很笨重，代码量很大。爬虫经常需要修改部分采集代码，所以Java不合适。C/C++运行效率和性能几乎最强，但是学习成本很高。代码成型比较慢。能用C/C++做爬虫，只能说是能力的表现，但不是正确的选择。Python语法优美、代码简介、开发效率高、支持的模块多，相关HTTP请求模块还有强大的爬虫Scrapy，以及成熟高效的scrapy-redis分布式策略。而且，调用其他接口也非常方便（胶水语言） 如何抓取HTML页面：HTTP请求的处理，urllib、urllib2、requests 处理后的请求可以模拟浏览器发送请求，获取服务器响应的文件 #解析服务器响应的内容 re、xpath、BeautifulSoup4（bs4）、jsonpath、pyquery等 使用某种描述性一样来给我们需要提取的数据定义一个匹配规则 符合这个规则的数据就会被匹配 #如何采集动态HTML、验证码的处理 通过动态页面采集，Selenium+PhantomJS(无界面)：模拟真实浏览器加载js、ajax等非静态的数据。 Tesseract：机器学习库，机器图像识别系统，可以处理简单的验证码，复杂的验证码可以通过手动输入/专门的打码平台。 sccrapy框架：（Scrapy，Pyspider） 搞定制性高性能（异步网络框架 twisterd），所以数据下载速度非常快，提供了数据存储、数据下载、提取规则等组件。 分布式策略：scrapy-redis，在Scrapy的基础上添加了一套以Redis数据库为核心的一套组件。让Scrapy框架支持分布式的功能。主要在Redis里做请求指纹去重、请求分配、数据临时存储。 爬虫–反爬虫–反反爬虫 之间的斗争：其实怕重做到最后，最头疼的不是复杂的页面，也是灰色的数据，而是网站另一边的反爬虫人员。 User-Agent、代理、验证码、动态数据加载、加密数据。 数据价值、是否值的去费劲做反爬虫。 1. 机器成本 + 人力成本 &gt; 数据价值，就不反了，一般做到封IP就结束了。 2、面子的战争...... 爬虫和反爬虫之间的斗争，最后一定是爬虫获胜。 为什么？只要是真实用户可以浏览的网页数据，爬虫就一定能爬下来！ #根据使用场景 分为 ：通用爬虫 聚焦爬虫1通用爬虫：搜索引擎用的爬虫系统。1、目标：就是尽可能吧互联网上所有的网页下载下来，放到本地服务器里形成备份； 再对这些网页做相关处理（提取关键字、去掉广告），最后提供一个用户检索接口。2、抓取流程： a） 首选选取一部分已有的URL，把这些URL放到待爬取队列。 b） 从队列里取出这些URL，然后解析DNS得到主机IP，然后去这个IP对应的服务器里下载HTML页面，保存到搜索引擎的本地服务器。之后把这个爬过的URL放入已爬取队列。 c）分析这些网页内容，找出网页里其他的URL链接，继续执行第二步，直到爬取条件结束。3、搜索引擎如何获取一个新网站的URL: A).主动向搜索引擎提交网址, B).向其他网站里设置网站的外链。 C).搜索引擎会和DNS服务商进行合作，可以快速收录新的网站。 DNS：就是把域名解析成IP的一种技术。4、通用爬虫并不是万物皆可爬，它也需要遵守规则：Robots协议：协议会指明通用爬虫可以爬取网页的权限。Robots.txt 只是一个建议。并不是所有爬虫都遵守，一般只有大型的搜索引擎爬虫才会遵守。咱们个人写的爬虫，就不用管了。5、通用爬虫工作流程：爬取网页 - 存储数据 - 内容处理 - 提供检索/排名服务6、搜索引擎排名： ·PageRank值：根据网站的流量（点击量/浏览量/人气）统计，流量越高，网站越值钱，排名越靠前。 ·竞价排名：谁给钱多，谁排名就高。7、通用爬虫的缺点： 1、只能提供和文本相关的内容（HTML、Word、PDF）等等，但是不能提供多媒体（音乐、图片、视频）和二进制文件（程序、脚本）等。 2、提供的结果千篇一律，不能针对不同背景领域的人提供不同的搜索结果。 3、不能理解人类语义上的检索。 2聚焦爬虫：爬虫程序员写的针对某种内容爬虫。面向主题爬虫、面向需求爬虫：会针对某种特定的内容去爬取信息，而且会保证信息和需求息息相关。 http的端口号：80；https的端口是：443； Python自带的模块：/usr/lib/python2.7/urllib2.py Python的第三方模块： /usr/local/lib/python2.7/site-packages urllib2 默认的 User-Agent：Python-urllib/2.7 User-Agent: 是爬虫和反爬虫斗争的第一步，养成好习惯，发送请求带User-Agent response 是服务器响应的类文件，除了支持文件操作的方法外，还支持以下常用的方法： 返回 HTTP的响应码，成功返回200，4服务器页面出错，5服务器问题 print response.getcode() 返回 返回实际数据的实际URL，防止重定向问题print response.geturl() 返回 服务器响应的HTTP报头print response.info() User-Agent 历史： Mosaic 世界上第一个浏览器：美国国家计算机应用中心 Netscape 网景：Netscape（支持框架），慢慢开始流行….(第一款支持框架的浏览器) Microsoft 微软：Internet Explorer（也支持框架） 第一次浏览器大战：网景公司失败..消失 Mozilla 基金组织：Firefox 火狐 - （Gecko内核）(第一款浏览器内核) User-Agent 决定用户的浏览器，为了获取更好的HTML页面效果。 IE开了个好头，大家都开就给自己披着了个 Mozilla 的外皮 Microsoft公司：IE（Trident） Opera公司：Opera（Presto） Mozilla基金会：Firefox（Gecko） Linux组织：KHTML （like Gecko） Apple公司：Webkit（like KHTML） Google公司：Chrome（like webkit） 其他浏览器都是IE/Chrome内核 Scrapy架构图（绿线是数据流向）：ScrapyEngine（引擎）：负责通讯，信号、数据传递 制作Scrapy爬虫 四步骤： 新建项目（scrapy startproject xxx）:新建一个新的爬虫项目 明确目标（编写items.py）：明确你想要爬取的目标 制作爬虫（spiders/xxspider.py）：制作爬虫开始爬取网页 存储内容（pipelines.py）：设计管道存储爬取内容 创建爬虫项目1234#创建普通项目scrapy startproject 项目名#创建模板scrapy startproject 项目名 网站名","tags":[]},{"title":"","date":"2019-04-29T11:59:33.680Z","path":"/posts/undefined/","text":"date:2019-03-28 14:34 title:03 python笔记1、ipython命令技能实现python命令，也能实现部分linux命令。2、python2不能识别文件里的中文，如果硬要识别，在头文件中加上 -- coding:utf-8 -- （python官方推荐这种方式）3、输入一个数1high = input(&quot;请输入一个数&quot;) 4、输出一个数12345age = 18print(&quot;age的值为%d&quot;%age)name = &quot;西芙&quot;print(&quot;name的值为%s&quot;%name);print(&quot;name的值是%s,年龄的值是%d&quot;%(name,age)) 4、if else语句12345678910age = 19if age&gt;18: print(&quot;已经成年&quot;)else print(&quot;未成年&quot;)#input获取的所有数据都会当成字符串类型#python 规定 str（）&gt;int()#所以如果 age = input(&quot;一个值&quot;)#要与int比较，需要把age换成int类型，即#age_num = int(age) 5、python语言是弱类型的编程语言，及赋值的时候已经知道是什么类型6、查看变量类型1type(a) 7、python的变量类型123456·Numbers(数字)： int(有符号整型)，long（长整型[也可代表八进制和十六进制]），float（浮点型），complex（复数）·布尔类型： True，False·String（字符串）·List（列表）·Tuple（元组）·Dictionary（字典） 8、关键字￼查看关键字命令12import keyword #导入keyword包keyword.kwlist 9、运算符12345&quot;s&quot;*10#输出&apos;ssssssssss&apos;#幂#** 10、is是地址相同的意思，在数值-5到256间，a与b地址相同，其余不同￼11、深拷贝与浅拷贝123456789101112131415161718192021222324252627282930313233#例1、浅拷贝a = [11, 22, 33]b = a #浅拷贝，地址拷贝，地址相同#例2、深拷贝import copyc = copy.deepcopy(a) #开辟一个内存空间，拷贝内容#例3、在数组中，深拷贝数组后，a = [11,22,33]b = [44,55,66]c = [a, b]d = copy.deepcopy[c]#查看c，d的id，并不相同，深拷贝#在a数组中添加[44],查看c[0],d[0]a.append(44)c[0][11,22,33,44]d[0][11,22,33]#说明深拷贝后，d另外拷贝了有关a、b的拷贝#例4、有关指向a，b的拷贝e = copy.copy(c)a.append(55)c[0]e[0]#所看到的结果都是[11,22,33,44,55]id(c)id(e)#所看到的地址不同，所以他们是指向不同的地址但所指向数组的内容地址是相同的#但如果是c = (a,b)，是元组的话，由于元组是不可变类型，e = copy.copy(c),他们所指向的地址是一样的#所以使用copy模块的copy功能时候，它会根据当前拷贝的数据类型是可变类型还是不可变类型有不同的处理方式 12、私有化12345678910class Test(object): def __init__(self): self.__num = 100 def setNum(self, newNum): self.__num = newNum def getNum(self): return self.__numt = Test()t.__num = 200 #可以使用print(t.__num) 升级版私有化 property使用123456789class Test(object): def __init__(self): self.__num = 100 def setNum(self, newNum): self.__num = newNum def getNum(self): return self.__num num = property(getNum, setNum)#!!!!#此时，可以用t.num = ?赋值 或者 t.num 取值，不用调用函数 装饰器使用12345678910class Test(object): def __init__(self): self.__num = 100 @property def num(self): return self.__num @num.setter def num(self, newNum): self.__num = newNum#与上面的代码意思相同。理解一下吧~ 1、xx:公有变量2、x:单前置下划线，私有化属性或方法，from somemodule import * 禁止导入，类对象和子类可以访问3、__x:双前置下划线，避免与子类中的属性命名冲突，无法在外部直接访问（名字重整所以访问不到）4、x：双前后下划线，用户名字空间的魔法对象或属性。例如init,__不要自己发明这样的名字5、xx_:单后置下划线，用于避免与python关键词的冲突 ###但是私有属性实际上是可以访问，python把私有属性的名字由原来的_私有属性名 改成 _类名私有属性名，所以可以通过对象._类名__私有属性名可以获取值！！！ 13、迭代器迭代器 迭代器是访问集合元素的一种方式，迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，知道所有的元素被访问完结束。迭代器只能往前不会后退。可迭代对象： 可直接作用于for循环的数据类型有以下几种： 一类是集合数据类型：如list、tuple、dict、set、str等 一类是generator，包括生成器和带yield的generator function。 可以直接作用于for循环的对象统称为可迭代对象：Iterable。 14、闭包：定义：函数里面有另外的函数，并且里面的函数用到了外面的函数的变量闭包的应用：1234567891011121314def test(number): print(&quot;--1--&quot;) def test_in(number2): print(&quot;--2--&quot;) print(number+number2) print(&quot;--3--&quot;) return test_in ret = test(100)print(&quot;-&quot;*30)ret(1)ret(100)ret(200)#优点 简化了步骤 linux快捷键： %s/^/#/g 所有行前面加# 1,14/#//g 去掉1-14行的#15、装饰器12345678910111213141516171819def w1(func): def inner(): print(&quot;----正在验证权限---&quot;) func() return innerdef f1(): print(&quot;---f1---&quot;)def f2(): print(&quot;---f2---&quot;)#innerFunc = w1(f1)#innerFunc()f1 = w1(f1) #把w1（f1）赋值给f1，也就是说f1 = w1.inner，f1指向的就是inner这个函数f1() #调用后，执行的是inner，但由于之前传入f1的参数，所以输出结果为inner的输出结果+f1函数的输出结果@w1 #与上面f1=w1(f1)意义相同，但只要python执行器执行到了这个代码，name就会自动的进行装饰，而不是等到调用的时候才装饰的 语法糖 @w1def f1(): print(&quot;---f1---&quot;) 12345678910111213141516171819#若有参数def func(functionName): print(&quot;---func---1---&quot;) def func_in(*args, **kwargs):#如果没有定义参数，会导致调用的时候出现问题 print(&quot;---func_in---1---&quot;) functionName(*args, **kwargs)#传入同样的参数 print(&quot;---func_in---2---&quot;) print(&quot;---func---2---&quot;) return func_in@funcdef test(a, b, c): print(&quot;---test-a=%d,b=%d,c=%d---&quot;%(a,b,c)) @funcdef test2(a, b, c, d): print(&quot;---test-a=%d,b=%d,c=%d,d=%d---&quot;%(a,b,c,d))test(11,22,33)test2(44,55,66,77) 12345678910111213141516171819202122232425262728#通用装饰器def func(functionName): def func_in(*args, **kwargs): print(&quot;---记录日志---&quot;) ret = functionName(*args, **kwargs) return ret return func_in@funcdef test(): print(&quot;---test---&quot;) return &quot;haha&quot;@funcdef test2(): print(&quot;---test2---&quot;)@funcdef test3(a): print(&quot;---test3---a=%d--&quot;%a) ret = test()print(&quot;test return value is %s&quot;%ret)a = test2()print(&quot;test2 return value is %s&quot;%a)test3(11) 16、作用域 #什么是命名空间在某个范围内所能用到的作用域 17、类方法与静态方法1234567891011121314151617#给类添加方法import types #导入types包class Person(object): def __init__(self, newName, newAge): self.name = newName self.age = newAge def eat(self): print(&quot;-----%s正在吃----&quot;%self.name)def run(self): print(&quot;-----%s正在跑----&quot;%self.name) p1 = Person(&quot;p1&quot;, 10)p1.eat()p1.run = types.MethodType(run, p1)p1.run() 18、限制class实例添加的属性123456789class Person(object): __slots__ = (&quot;name&quot;, &quot;age&quot;)p = Person()p.name = &quot;老王&quot;p.age = 20p.score = 100 #会报错！！！``` ## 生成器、迭代器、装饰器、闭包（重点）！！19、生成器 In [1]: a = [x*2 for x in range(10)]In [2]: aOut[2]: [0, 2, 4, 5, 6, 10, 12, 14, 16, 18] #如果用[]，会生成数组，同时加载到内存中 #如果用括号（），输出的是一个地址，需要时才提取出In [3]: b = (x*2 for x in range(10))In [4]: bOut[4]: &lt;generator object at 0x7fb057ff06d0&gt;In [5]:next(b)Out[5]:0120、a，b交换 def creatNum(): print(“—-start—-“) a, b = 0, 1 for i in range(5): print(“—-1—-“) yield b #python中有一个非常有用的语法叫做生成器，所利用到的关键字就是yield。有效利用生成器这个工具可以有效地节约系统资源，避免不必要的内存占用。当执行到这的时候，会做停顿。 print(“—-2—-“) a, b = b, a+b print(“—-3—-“) print(“—-stop—-“) #创建了一个生成器对象a = creatNum() #实现交换a, b = 0, 1a, b = b, a121、斐波拉契数列 a,b = 0, 1a,b = b, a+b #重复此步骤122、类当做装饰器 #1class Test(object): def call(self): print(“—test—“)t = Test()t() #out: —test— #2class Test(object): def init(self, func): print(‘—初始化—‘) print(‘func name is %s’func.name) self.func = func def call__(self): print(‘—装饰器中的功能—‘) self.__func() @Test #相当于 t = Test(test)def test(): print(‘—test—‘) #out: —初始化— #out:func name is ‘test’ test() #out: —装饰器中的功能 #out:—test—123、元类 Test = type(“Test”, (), {})#相当于创建一个类Test #out:__main.Test #创建一个拥有属性num=0的Person类Person = type(“Person”,(),{“num”:0}) #创建一个拥有方法printNum()的Test3类def printNum(self): print(“–num-%d–”%self.num)Test3 = type(“Test3”,(),{“printNum”:printNum}) 12345678910111213141516171819202122232425```#设置Foo类的属性变大写！！，通过metaclass设置def upper_attr(future_class_name, future_class_parents, future_class_attr): #Foo object &#123;bar:&quot;bip&quot;&#125; #遍历属性字典，把不是__开头的属性名字变成大写 newAttr = &#123;&#125; for name, value in future_class_attr.items(): if not name.startswith(&quot;__&quot;): newAttr[name.upper()] = value #调用type创建一个类 return type(future_class_name,future_class_parents,newAttr)class Foo(object,metaclass=upper_attr): # __metaclass__ = upper_attr #设置Foo类的元类为upper_attr python2 bar = &quot;bip&quot;print(hasattr(Foo, &quot;bar&quot;))print(hasattr(Foo, &quot;BAR&quot;))f = Foo()print(f.BAR)#out:False#out:True#out:bip 24、内建属性123456789101112131415161718class Itcast(object): def __init__(self,subject1): self.subject1 = subject1 self.subject2 = &apos;cpp&apos; #属性访问时拦截器，打log def __getattribute__(self,obj): #obj--&gt;&quot;subject1&quot; if obj == &apos;subject1&apos;: print(&apos;log subject1&apos;) return &apos;redirect python&apos; else: return object__getattribute__(self,obj) def show(self): print(&apos;this is Itcast&apos;) s = Itcast(&quot;python&quot;)print(s.subject1)print(s.subject2) 内建方法25、lambda之map123456789101112131415#函数需要一个参数map(lambda x: x*x, [1, 2,3])#结果为：[1, 4, 9]#函数需要两个参数map(lambda x, y: x+y, [1, 2, 3], [4, 5, 6])#结果为:[5,7,9]def f1(x, y): return (x, y)l1 = [0,1,2,3,4,5,6]l2 = [&apos;Sun&apos;, &apos;M&apos;, &apos;T&apos;, &apos;W&apos;, &apos;T&apos;, &apos;F&apos;, &apos;S&apos;]l3 = map(f1, l1, l2)print(list(l3))结果为：[(0,&apos;Sun&apos;), (1,&apos;M&apos;).....] 26、lambda之filter12345fliter(lambda x : x%2, [1, 2 ,3, 4]) #如果为1，则输出[1, 3]filter(None, &quot;she&quot;)&apos;she&apos; 27、lambda之reduce12345678reduce(lambda x, y: x+y, [1,2,3,4])10 #先把1赋值给x，2赋值给2，x+y后=3，把3赋值给x，数组中的3赋值给y，再累加，以此类推reduce(lambda x, y:x+y, [1,2,3,4], 5)15 #如果前面是数组，先把5赋值给x，再累加[1,,2,3,4]reduce(lambda x, y: x+y, [&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;], &apos;dd&apos;)ddaabbcc 28、sort123456789a = [9,8,7,6,5,4,3,2,1]a.sort()a#[1,2,3,4,5,6,7,8,9]b = [&apos;dd&apos;,&apos;cc&apos;,&apos;bb&apos;,&apos;aa&apos;]b.sort()b#[&apos;aa&apos;,&apos;bb&apos;,&apos;cc&apos;,&apos;dd&apos;] 28、python的functools包中提供了一个叫wraps的装饰器来消除这样的副作用1234567891011121314151617import functoolsdef note(func): &quot;note function&quot; @functoolswraps(func) def wrapper(): &quot;wrapper function&quot; print(&quot;note something&quot;) return func() return wrapper@notedef test(): &quot;test function&quot; print(&apos;I am test&apos;)test()print(test.__doc__)","tags":[]},{"title":"","date":"2019-04-29T11:41:26.966Z","path":"/posts/undefined/","text":"date:2019-03-28 14:34 title:02 HDFS上传和读取流程上传流程 1.根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在。 2.namenode返回是否可以上传 3.client请求第一个 block该传输到哪些datanode服务器上 4.namenode返回3个datanode服务器ABC 5.client请求3台dn中的一台A上传数据（本质上是一个RPC调用，建立pipeline），A收到请求会继续调用B，然后B调用C，将这个pipeline建立完成，逐级返回客户端 6.client开始往A上传第一个block（先从磁盘读取数据放到一个本地内存缓存），以packet为单位，A收到一个packet就会传给B，B传给C；A每传一个packet会放入一个应答队列等待应答 7.当一个block传输完成之后，client再次请求namenode上传第二个block的服务器。读取流程客户端读取HDFS数据相比写入数据要简单一些，以下是读取数据步骤： 1.client访问NameNode，查询元数据信息，获得这个文件的数据块位置列表，返回输入流对象。 2.就近挑选一台datanode服务器，请求建立输入流。 3.开始读取这个数据的第一个block块，读取完全之后，开始接着读取这个文件的第二个block，直至把这个数据所有的block都读完了则文件读取完全了。 4.数据读完之后关闭流连接。 5.如果读取过程当中读取失败，将会依次读取该数据块的下一个副本，失败的节点将会被记录，不再连接。 ￼# SecondaryNameNodeSecondaryNameNode 是 HDFS 架构中的一个组成部分，它用来保存名称节点中对HDFS元数据信息的备份，减小Editlog文件大小，从而缩短名称节点重启的时间。 它一般是单独运行在一台机器上。 SecondaryNameNode让EditLog变小的工作流程如下: (1)SecondaryNameNode 会定期和 NameNode 通信，请求其停止使用 EditLog 文件，暂时将 新的写操作写到一个新的文件 edit.new 中，这个操作是瞬间完成的，上层写日志的函数完全感觉不到差别。 (2) SecondaryNameNode 通过 HTTP GET 方式从 NameNode 上获取到 Fslmage 和 EditLog 文 件，井下载到本地的相应目录下。 (3) SecondaryNameNode 将下载下来的 Fslmage 载入到内存，然后一条一条地执行 EditLog 文件中的各项更新操作，使内存中的 Fslmage 保持最新。 这个过程就是 EditLog 和 Fslmage 文件合 井。 (4) SecondaryNameNode 执行完（3）操作之后，会通过 post 方式将新的 Fslmage 文件发送 到 NameNode 节点上 (5) NameNode 将从 SecondaryNameNode 接收到的新的 Fslmage 替换旧的 Fslmage 文件，同 时将 Edit.new 替换 EditLog 文件，从而减小 EditLog 文件大小。￼从上面的过程可以看出，第二名称节点相当于为名称节点设置一个“检查点” ，周期性备份 名称节点中的元数据信息，但第二名称节点在 HDFS 设计中只是一个冷备份，并不能起到“热备 份”的作用。 HDFS 设计并不支持当名称节点故障时直接切换到第二名称节点。 HDFS FederationHDFSl.O 的单 NameNode 设计不仅存在单点故障问题，还存在可扩展性和性能问题。只有一 个 NameNode， 不利于水平扩展。 HDFS Federation (HDFS 联邦）特性允许一个 HDFS 集群中存在 多个 NameNode 同时对外提供服务，这些 NameNode 分管一部分目录（水平切分），彼此之间相 互隔离，但共享底层的 DataNode 存储资源。每个 NameNode 是独立的，不需要和其他 Nam巳Node 协调合作。 如图 4-5 所示 ， Federation 使用了 多 个独立的 NameNode/NameSpace 命名空间。这些 NameNode 之间是联合的，也就是说， 它们之间相互独立且不需要互相协调，各自分工管理自己的 区域。分布式的 DataNode 被用作通用的数据块存储设备。每个 DataNode 要向集群中所有的 NameNode 注册，且周期性地向所有 NameNode 发送心跳和块报告， 并执行来自所有 NameNode 的命令。每一个 DataNode 作为统一的块存储设备被所有 NameNode 节点使用。 每一个 DataNode 节点都在所有的 NameNode 进行注册。 DataNode 发送心跳信息、块报告到 所有 NameNode，同时执行所有 NameNode 发来的命令。￼","tags":[]},{"title":"","date":"2019-04-29T11:40:34.393Z","path":"/posts/undefined/","text":"date:2019-03-28 14:34 title:01 .bat批量把txt中想要的信息存放到excel最近喵仙子有个需求，需要抽取大量.log文件中的有效信息到excel，刚开始我用mapreduce给他做了一份，不过他有点蠢配不了环境，于是乎我研究了下bat，终于给他整了个好方法，请看下文。 需求 需要从log中抽取两列数据到excel中。 本西芙没了解过bat语法，所以查了一下，通过结合这两篇解答完成bat命令。1、实现了按照空格批处理分割txt数据，存储excelhttps://zhidao.baidu.com/question/1770548208106936980.html123456789101112@echo offrem 保存为bat文件跟txt文件放一起运行md &quot;结果\\&quot; 2&gt;nulfor /f &quot;delims=&quot; %%a in (&apos;dir /a-d/b *.txt&apos;) do ( setlocal EnableDelayedExpansion (for /f &quot;delims=&quot; %%b in (&apos;type &quot;%%a&quot;&apos;) do ( set &quot;str=%%b&quot; echo;!str: =,! ))&gt;&quot;结果\\%%~na.csv&quot; Endlocal)pause 2、批处理分割字符串https://blog.csdn.net/zhju85126com/article/details/46649961123456789101112@echo offset str=100x200x300y400y500x600y700for /f &quot;tokens=1,3-5,* delims=x|y&quot; %%a in (&quot;%str%&quot;) do ( set c1=%%a set c3=%%b set c4=%%c set c5=%%d set c6=%%e)echo %c1%, %c3%, %c4%, %c5%, %c6%pauserem 输出结果为输出结果为：100, 300, 400, 500, 600y700。其中tokens=1,3-5,*表示提取第1、3至5列，同时把第5列后所有剩余字符串作为第6列，一个输出了5个变量，也可以写作tokens=1,3,4,5,*。 最终我所加工的代码12345678910111213@echo offmd &quot;结果\\&quot; 2&gt;nulrem 循环数据for /f &quot;delims=&quot; %%a in (&apos;dir /a-d/b *.log&apos;) do ( setlocal EnableDelayedExpansion rem 切割方式 (for /f &quot;tokens=7,25 delims=_| &quot; %%b in (&apos;type &quot;%%a&quot;&apos;) do ( set &quot;str1=%%b %%c&quot; echo;!str1: =,! ))&gt;&quot;结果\\%%~na.csv&quot; Endlocal)pause 首先根据第一篇解答套入转excel模板，其次根据第二篇解答对bat for循环中分割和选取的描述，修改第五行代码。可以实现。 ###演示1、双击bat 2、生成结果 3、查看生成数据（完成）","tags":[]}]