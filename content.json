[{"title":"","date":"2019-07-15T09:33:15.538Z","path":"/posts/undefined/","text":"git上传仓库步骤 1、新建仓库 2、git config –global user.name “xifujiang” 3、git config –global user.email “229694302@qq.com“ 进入文件夹后初始化 git init git add . git pull –rebase 地址 //该步骤是复制之前的master，使得代码相同 git commit -m “xxx1.version” git push 地址","tags":[]},{"title":"","date":"2019-05-16T10:13:51.724Z","path":"/posts/undefined/","text":"Linux复习第一章linux系统诞生于1991年，由芬兰大学生李纳斯（Linux Torvalds）。 文件处理命令 ls （-lh…） -rw-r--r-- 1 root root 8690 3月 1 13:23 install.log.syslog 1是引用计数（代表此文件被调用几次 引用几次） 文件所有者 文件所属组 字节文件大小 最后修改时间 文件名称 -rw-r--r-- - 文件类型（- 二进制文件 d目录 l软连接文件） rw- r-- r-- u g o u所有者 g所属组 o其他人 r读 w写 x执行 cd pwd mkdir 网络通信命令 ping ifconfig 系统关闭命令 shutdown reboot 重启系统 文本编辑器 vim/vi 虚拟机安装 CPU：建议主频为1GHz以上 内存：建议1GB以上 硬盘：建议分区空闲空间8GB以上 linux分区 boot 400mb home 分区， 4G swap 交换分区2G 没有挂载点，就是没有盘符，swap不是给用户用的，是给操作系统或内科自己调用的 设置为2G 超过两个G就没有意义了 逻辑分区 / 剩余所有空间 第四个分区，linux不知道要分几个区，所有先创建一个sda5（第一个逻辑分区），一块硬盘只能有4个分区是第四个默认为逻辑分区，三个主分区，一个逻辑分区 系统磁盘分区 基本分区（primary partion） 扩充分区（extension partion） 基本分区和扩充分区的数目之和不能大于四个。且基本分区可以马上被使用单不能再分区。扩充分区必须再进行分区后才能使用，也就是说它必须还要进行二次分区。扩充分区下面是逻辑分区（logical partion），逻辑分区没有数量上的限制。 主分区：最多只能有4个。 扩展分区： 最多只能有1个。 主分区加扩展分区最多有4个。 不能写入数据，只能包含逻辑分区 分区格式化目的：为了给这个分区写入文件系统，也就是告诉我们的操作系统，如何去管理这个分区的数据。 分区：把大硬盘分为小的逻辑分区 格式化：写入文件系统 分区设备文件名：给每个分区定义设备文件名 挂载：给每个分区分配挂载点 虚拟机网络连接方式 桥接模式 NAT模式 仅主机模式 自定义模式 桥接模式 你的虚拟机是利用你的真实网卡，一块本地有线网卡(以太网)，一块是本地无线网卡（wlan）装完虚拟机后会出现两块虚拟网卡，一块vmnet1，一块vmnet8，如何选择桥接你的虚拟机将会利用你的网卡以太网或无线网卡和你的真实机进行通信 好处是配置简单，和你的真是机的ip地址设置同一网段，和真机进行通信，局域网的其他电脑也可以通信。 缺点占用同意网段的一个ip地址，在家里宿舍没有问题，在教室可能会和其他同学的ip地址冲突。 NAT模式你的虚拟机是通过VMnet8这块假的虚拟网卡和你的真实机连接 仅主机模式你的虚拟机是通过VMnet1这块假的虚拟网卡和你的真实机连接。 1234桥接是不仅和你的真机通信还可以与你的局域网的其他机器通信，和一台笔记本是一个意思。Nat hostonly 只能和你真机通信，不可以和局域网其他电脑通信，不用占用你的真实网段的一个ip地址。Hostonly 只能和你计算机主机通信。NAT和主机通信，如果你的主机可以联网，虚拟机也可以联网。 df盘符分区查询df （-h）文件系统 1k-块 已用 可用 已用% 挂载点 文件处理命令文件处理命令 ls 查看目录下的文件 -a 显示所有文件，包括隐藏文件 -l 详细信息显示 -d 查看目录属性 -i Inode索引节点 mkdir 创建目录 -p 创建递归 cd 切换目录 pwd 显示当前目录 rmdir 删除空目录 cp 复制文件或目录 -rp 【源文件或目录】 【目标目录】 -r 复制目录 -p 保留文件属性 clear 清屏操作 mv 【源文件或目录】【目标目录】 剪切文件、改名 rm 删除文件 rm -rf 【文件或目录】 -r 删除目录 -f 强制执行 touch 创建空文件 cat 显示文件内容 -n 显示行号 more 分页显示文件内容 （空格）或f 翻页 （Enter） 换行 q或Q 退出 less 分页显示文件内容 ln 生成链接文件 -s创建软连接 软链接特征：类似windows快捷方式 lrwxrwxrwxl软链接 文件大小——只是符号链接 /tmp/issue.soft -&gt; /etc/issue 箭头指向源文件 硬链接特征： 1、拷贝cp -p + 同步更新 2、通过i节点识别 3、不能跨分区 4、不能针对目录使用 shutdown命令 -c 取消前一个关机命令 -h 关机 -r 重启 vi/vim 建立、编辑、显示文本文件 vim是一个功能强大的全屏幕文本编辑器，是Linux/UNIX上最常用的文本编辑器，它的作用是建立、编辑、显示文本文件。 vim没有菜单，只有命令。 vim工作模式 插入命令 命令 作用 a 在光标所在字符后插入 A 在光标所在行尾插入 i 在光标所在字符前插入 I 在光标所在行行首插入 o 在光标下插入新行 O 在光标上插入新行 定位命令 命令 作用 :set nu 设置行号 :set nonu 取消行号 gg 到第一行 G 到最后一行 nG 到第n行 :n 到第n行 $ 移至行尾 0 移至行首 删除命令 命令 作用 x 删除光标所在处字符 nx 删除光标所在处后n个字符 dd 删除光标所在行，ndd删除n行 dG 删除光标所在行到文件末尾内容 D 删除光标所在处到行尾内容 n1,n2d 删除指定范围的行 复制和剪切命令 命令 作用 yy 复制当前行 nyy 复制当前行以下n行 dd 剪切当前行 ndd 剪切当前行以下n行 p、P 粘贴在当前光标所在行下或行上 搜索和搜索替换命令 命令 作用 /string 搜索指定字符串 搜索时忽略大小写：set ic n 搜索指定字符串的下一个出现位置 :%s/old/new/g 全文替换指定字符串 :n1,n2s/old/new/g 在一定范围内替换指定字符串 保存和退出命令 命令 作用 :w 保存修改 :w new_filename 另存为指定文件 :wq 保存修改并退出 zz 快捷键，保存修改并退出 :q! 不保存修改退出 :wq! 保存修改并退出（文件所有者及root可使用） 权限管理命令 chmod 改变文件或目录（权限） -R 递归修改 权限的数字表示 r——4 w——2 x——1 文件目录权限总结 代表字符 权限 对文件的含义 对目录的含义 r 读权限 可以查看文件内容 可以列出目录中的内容 w 写权限 可以修改文件内容 可以在目录中创建、删除文件 x 执行权限 可以执行文件 可以进入目录 chown 改变文件或目录的（所有者） chmod 【用户】【文件或目录】 chgrp 改变文件或目录的（所属组） chgrp 【用户组】【文件或目录】 Groupadd 所有组名称新的命令 umask 显示、设置文件的缺省权限 umask -S 以rwx形式显示新建文件缺省权限 在linux创建文件默认权限没有x权限，防止病毒可执行脚本 在linux创建目录默认权限有x 文件搜索命令 find 【搜索范围】【匹配条件】 尽量不要使用linux里的find命令浪费资源特别是使用高峰期的时候，目录和文件合理的命名存放位置最重要。 Find 路径 选项 关键字 完全搜索 Find / -name a 模糊搜索 Find / -name a 模糊搜索 Find / -name *a?? 模糊搜索 Find / -iname *a?? （iname不区分大小写） Find -size +n -n n 查询文件大小 (+大于 -小于 什么都不写 =) Find -user dj 根据所有者查找文件 find /etc -cmin -5 在/etc下查找5分钟内被修改过属性的文件和目录（+超过多长时间 -在多少分钟内） amin 访问时间 access cmin 文件属性 change mmin 文件内容 modify 帮助命令用户管理命令简介：所以越是对服务器安全性要求高的服务器， 越需要建立合理的用户权限登记制度和服务器操作规范。 在linux中主要是通过用户配置文件来查看好修改用户信息。 #1、添加更多的用户分配不同的权限。 #2、通过配置文件添加信息，使用命令重启可能就消失了。 1、用户配置文件——用户用户信息文件 /etc/passwd 第1字段：用户名称 第2字段：密码标志 第3阶段：UID（用户ID） 0： 超级用户 1-499： 系统用户（伪用户） 500-65535： 普通用户 第4字段：GID（用户初始组ID） 第5字段：用户说明 第6字段：家目录 普通用户：/home/用户名/ 超级用户：/root/ 第7字段：登录之后的Shell 初始组和附加组 初始组：就是指用户一登录就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户名相同的组名作为这个用户的初始组。 附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。 shell是什么？ 1、shell就是Linux的命令解释器 2、在/etc/passwd当中，除了标准shell是/bin/bash之外，还可以写如/sbin/nologin。 2、用户配置文件——影子1、影子文件/etc/shadow 第1字段：用户名 第2字段：加密密码 加密算法升级为SHA512散列加密算法 如果密码位是“!!”或“*”代表没有密码，不能登录 第3字段：密码最后一次修改日期 使用1970年1月1日作为标准时间，每过一天时间戳加1 第4字段：两次密码的修改间隔时间（和第三字段相比） # 0代表随时可以修改密码，10代表10天后才能修改密码 第5字段：密码有效期（和第3字段相比） 第6字段：密码修改到期前的警告天数（和第5字段相比） 第7字段：密码过期后的宽限天数（和第5字段相比） 0：代表密码过期后立即失效 -1：则代表密码永远不会失效。 第8字段：账号失效时间 （到了不管过期 6 7） 要用时间戳表示 第9阶段：保留 2、时间戳换算 把时间戳换算为日期 &gt;&gt; date -d &quot;1970-01-01 16066 days&quot; 把日期换算为时间戳 &gt;&gt; echo $(($(date --date=&quot;2014/01/06&quot; +%s)/86400 +1)) 3、用户配置文件——组件1、组信息文件/etc/group 第1字段：组别 第2字段：组密码标志 第3阶段：GID 第4字段：组中附加用户 2、组密码文件/etc/gshadow 第1字段：组别 第2字段：组密码 第3阶段：组管理员用户名 第4字段：组中附加用户 4、用户管理相关文件用户的家目录 普通用户：/home/用户名/，所有者和所属组都是此用户，权限是700 超级用户：/root/，所有者和所属组都是root用户，权限是550 5、用户管理命令 useradd命令 useradd[选项] 用户名 -u UID：手工指定用户的UID号 -d 家目录 手工指定用户的家目录 -c 用户说明 手工指定用户的说明 -g 组名 手工指定用户的初始组 -G 组名 指定用户的附加组 -s shell 手工指定用户的登录shell。默认是/bin/bash 例 ：添加默认用户 &gt;&gt; useradd sc &gt;&gt; grep sc /etc/passwd &gt;&gt; grep sc /etc/shadow &gt;&gt; grep sc /etc/group &gt;&gt; grep sc /etc/gshadow passwd命令格式 passwd[选项] 用户名 -S 查询用户密码的密码状态。仅root用户可用。 -l 暂时锁定用户。仅root用户可用。 -u 解锁用户。仅root用户可用。 --stdin 可以通过管道符输出的数据作为用户的密码。 修改用户信息usermod usermod[选项] 用户名 -u UID 修改用户的uid号 -c 用户说明 修改用户的说明信息 -G 组名 修改用户附加组 -L 临时锁定用户(lock) -U 解锁用户锁定（Unlock） 例 ：修改用户信息 &gt;&gt; usermod -c &quot;test user&quot; xifu #修改用户的说明 &gt;&gt; usermod -G root xifu #把西芙用户加入到root组 &gt;&gt; usermod -L xifu #锁定用户 &gt;&gt; usermod -U xifu #解锁用户 修改用户密码状态chage chage[选项] 用户名 -l 列出用户的详细密码状态 -d 日期 修改密码最后一次更改时间（shadow3字段） -m 天数 两次密码修改间隔（4字段） -M 天数 密码有效期（5字段） -W 天数 密码过期前警告天数（6字段） -l 天数 密码过期后宽限天数（7字段） -E 日期 账号失效时间（8字段） 例：修改密码状态 &gt;&gt; chage -d 0 xifu #这个命令其实是把密码修改日期归0了（shadow第3字段） 这样用户一登录就要修改密码 删除用户userdel userdel[-r] 用户名 -r 删除用户的同时删除用户家目录 切换用户身份su su [选项] 用户名 - 选项只使用“-”代表连带用户的环境变量一起切换 -c命令 仅执行一次命令，而不切换用户身份 压缩解压命令网络命令 write 给用户发信息 网络 w命令查看用户在线情况 打开两个窗体（写错的时候 退格键 ctrl+backspace键） 写好了 ctrl+D保存结束 远程终端第一个0 终结符EOF wall 【message】 发广播信息 广播信息 在线用户 ping 测试网络连通性 ping 选项 IP地址 -C 指定发送次数 ifconfig 查看和设置网卡信息 eth0第一块网卡 Ethernet网络昵称以太网 网络类型目前我们接触的都是以太网 Hwaddr 网卡的物理地址 Inet addr 当前计算机地址 Bcast 发送广播的ip地址 Mask 子网掩码网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分 Rx接受数据包数量 byte 接收到的数据包的总大小 TX发送数据包数量 Interrupt 网卡在内存中的物理地址 Lo回环网卡每台机器都有用来做本机网络测试的 mail 查看发送电子邮件 不在线也能收到 收到直接数据mail 直接回车 n代表没有读的邮件 1代表一份邮件 输入1回车查看第一份信内容 last 列出目前与过去登入系统的用户信息 计算机所有用户登录系统信息 dj pts/1 192.168.40.1 Thu Mar 7 13:04 still logged in 第二个远程终端 登录的远程ip 一直在登录 netstat 【选项】 显示网络相关信息 选项 用途 -t TCP协议 -u UDP协议 -l 监听 -r 路由 -n 显示IP地址和端口号 范例 netstat -tlun 查看本机监听的端口 netstat -an 查看本机所有的网络连接 netstat -rn 查看本机路由器 netstat -ntlp Tcp http 用的协议 三次握手 安全可靠 传输 打电话 Udp 快 发短信 端口 ip地址为公司名字 找某人 就是端口 Destination Gateway Genmask Flags MSS Window irtt Iface setup 配置网络 dhcp 自动分配自动获取服务 * 默认相当于windows自动获取ip地址没有用，原因个人电脑和家里的环境不会有路由分配。 setup操作结束后 使用 service network restart命令 关机重启命令 shutdown命令 -c 取消前一个关机命令 -h 关机 -r 重启 linux shell基础shell概述 shell是什么 shell是一个命令行解释器。 它为用户提供了一个向linux内核发送请求以便运行程序的界面系统级程序。 用户可以用shell来启动、挂起、停止甚至是编写一些程序。 注释： 内核 机器语言01010 外层 pwd ls命令 shell就是黑色及交互命令窗体 shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。shell是解释执行的脚本语言，在shell中可以直接调用Linux系统命令。 shell的分类 1、Bourne Shell: 从1979起Unix就开始使用Bourne Shell，Bourne Shell的主文件名为sh。 2、 C Shell： C Shell主要在BSD版的Unix系统中使用，其语法和C语言相类似而得名。 shell的两种语法类型有Bourne和C，这两种语法彼此不兼容。Bourne家族主要包括sh、ksh、Bash、psh、zsh；C家族主要包括：csh、tcsh linux标准shell是伯恩 shell bash ei Bash:Bash与sh兼容，现在使用的linux就是使用bash作为用户的基本shell。 linux支持的shell /etc/shells shell脚本运行 echo输出命令 echo [选项] [输出内容] -e 支持反斜线控制的字符转换 转移符 echo -e ‘\\e[1,31m abcd \\e[0m’ 变色 第一个脚本 &gt; vi hello.sh #linux不区分扩展名,告诉linux为base脚本vim有颜色 &gt; &gt; #!/bin/Bash # #为注释，第一行标志shell脚本 脚本执行 &gt;&gt; 1、赋予执行权限，直接运行 &gt;&gt; chmod 755 hello.sh &gt;&gt; ./hello.sh &gt;&gt; 2、或者通过Bash调用执行脚本 &gt;&gt; Bash hello.sh linux标准shellbase 历史命令 history [选项] [历史命令保存文件] -c 清空历史记录 -W 把缓存中的历史命令写入历史命令保存文件 ~/.bash_history * 历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改 正常退出后才写入到history文件里，黑客基本就会清空，太多了就会删掉第一条，正在保存在vim /root/.bash_history。 命令与文件补全 在bash中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或文件时，按“Tab”键就会自动进行补全。 bash常用快捷键 标准输入输出 设备 设备文件名 文件描述符 类型 键盘 /dev/stdin 0 标准输入 显示器 /dev/sdtout 1 标准输出 显示器 /dev/sdterr 2 标准错误输出 输出重定向 1、夜里12点执行一些命令 保存到文件里 输出重定向最终结果 把输出结果给管理员随时查看 必须保证命令有输出信息 2、1&gt;/dev/null 2&gt;&amp;1 将错误绑定到标准输出上， 标准输出重定向到/dev/null中， 所有到这个下的命令不会被保存， 就像黑洞一样被吸引， 该条shell命令将不会输出任何信息到控制台， 也不会有任何信息输出到文件中。 通常用于运行shell命令 输入重定向 命令&lt;文件 文件作为命令的输入 wc [选项] [文件名] -c 统计字节数 -w 统计单词数 -l 统计行数 多命令顺序执行 多命令执行符 格式 作用 ; 命令1；命令2 多个命令顺序执行，明明之间没有任何逻辑联系 &amp;&amp; 命令1&amp;&amp;命令2 逻辑与，当命令1正确执行，则命令2才会执行，当命令1执行不正确，则命令2不会执行 &#124;&#124; 命令1&#124;&#124;命令2 逻辑或，当命令1执行不正确，则命令2才会执行，当命令1正确执行，命令2不会执行 dd dd if=输入文件 of=输出文件 bs=字节数 count=个数 if=输入文件 指定源文件或源设备 of=输出文件 指定目标文件或目标设备 bs=字节数 指定一个输入/输出多少字节，即把这些字节看做一个数据块 count=个数 指定输入/输出多少个数据块 例：date；dd if=/dev/zero of=/root/testfile bs=1k count=10000; date #数据复制或者磁盘命令，复制分区和硬盘,复制文件系统 ls anaconda-ks.cfg &amp;&amp; echo yesls /root/test || echo “no命令 &amp;&amp; echo yes || echo no 管道符 命令1 | 命令2 #命令1的正确输出作为命令2的操作对象 例 &gt;ll -a/etc | more &gt;netstat -an | grep &quot;ESTABLISHED&quot; &gt;more只能看文件内容 &gt;命令1必须正确输出 多个管道符嵌套目的就是得到正确命令输出 gerp grep [选项] “搜索内容” -i 忽略大小写 -n 输出行号 -v 反向查找 --color=auto 搜索出的关键字用颜色显示 通配符 例：通配符 &gt;cd /tmp &gt;rm -rf * &gt;touch abc &gt;touch abcd &gt;touch 012 &gt;ls ?abc &gt;ls [0-9]* &gt;ls [^0-9]* bash中其他特殊符号 双引号与单引号 &gt; name=sc &gt; echo ‘$name’ &gt; echo “$name” &gt; echo ‘$(date)’ &gt; echo “$(date)” xifu@xifu-virtual-machine:~$ echo &quot;$name&quot; xifu@xifu-virtual-machine:~$ echo &apos;$(date)&apos; $(date) xifu@xifu-virtual-machine:~$ echo &quot;$(date)&quot; 2019年 05月 15日 星期三 20:37:30 CST xifu@xifu-virtual-machine:~$ echo &quot;hahahha $(date)&quot; hahahha 2019年 05月 15日 星期三 20:37:35 CST 反引号与$() &gt; echo ‘ls’ &gt; echo $(date) xifu@xifu-virtual-machine:~$ echo $(date) 2019年 05月 15日 星期三 20:39:35 CST shell变量 变量的定义 变量是计算机内存的单元，其中存放的值可以改变。 如shell脚本需要保存一些信息时，如一个文件名或是一个数字，就把它存放在一个变量中。 每个变量有一个名字，所以很容易引用它。 使用变量可以保存有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息。 变量设置规则 变量分类 例：用户自定义变量 &gt;name=&quot;xifu&quot; #变量定义 &gt;#变量叠加 &gt;aa=123 &gt;aa=&quot;$aa&quot;456 &gt;aa=${aa}789 &gt;echo $name #变量调用 &gt;set #变量查看 &gt; unset name #变量删除 环境变量： 用户自定义变量只在当前的shell中生效， 而环境变量会在当前shell和这个shell的所有子shell中生效。 如果把环境变量写入相应的配置文件， name这个环境变量就会在所有的shell中生效。 环境变量语法 &gt;export 变量名=变量值 #申明变量 &gt;env #查询变量 &gt;unset 变量名 #删除变量 系统常见环境变量 系统命令操作直接敲即可原因是写入到path里了，此操作为临时生效自己的脚本也可以这么做，写好脚本，设置权限，cp文件到bin 输入文件名操作系统的命令就是吧当前命令写到了path具体每个命令路径地址下的，所以会自动扫描找到每个目录下的就执行，没有找到就报错 位置参数变量 预定义变量 &amp;&amp; || 是通过什么第二命令知道第一命令是否正常运行的呢 其实是通过$?的数字才判断的 程序员用户眼睛判断命令是否正确 计算机是通过$?判断命令是否正确 接收键盘输入 read[选项][变量名] -p “提示信息”：在等待read输入时，输出提示信息 -t 描述 read命令会一直等待用户输入，使用此选项可以指定等待时间 -n 字符数 read命令只接受指定的字符数，就会执行 -s 隐藏输入的数据，适用于机密信息的输入 declare声明变量类型 declare [+/] [选项] [变量名] - 给变量设定类型属性 + 取消变量的类型属性 -i 将变量声明为整数型（integer） -x 将变量声明为环境变量 -p 显示指定变量的被声明的类型 例：方法一，数值运算——方法1 &gt;aa=11 &gt;bb=22 &gt;给变量aa和bb赋值 &gt;declare -i cc=$aa+$bb 例：方法二，expr或let数值运算工具 &gt;aa=11 &gt;bb=22 &gt;#给变量aa和bb赋值 &gt;dd=$(expr $aa + $bb) &gt;#dd的值是aa和bb的和。注意“+”号左右两侧必须有空格 例：方法三，”$((运算式))” 或”$[运算式]” &gt;aa=11 &gt;bb=22 &gt;ff=$(( $aa+$$bb )) &gt;gg=$[ $aa+$$bb ] #单个小括号是系统命令 #双个小括号代表数值运算符 修改环境变量从新登陆才能生效 用source直接生效 .有空格 Path 命令路径 Histsize 历史命令保存条数 Ps1 提示符 Hostname 主机名 [root@localhost ~]# echo $PATH /usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin:/root [root@localhost ~]# PATH=&quot;$PATH&quot;:/root [root@localhost ~]# echo $PATH /usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin:/root:/root [root@localhost ~]# echo $HOSTNAME set 一组文件目录下所有文件etc目录下对所有用户生效,家目录当前目录生效/etc目录下所有登录用户都生效 ~代表家目录 1、家目录是用户的/home目录，其分为两种情况(1)、普通用户/home/linuxprobe (linuxprobe是设置的用户名，也可以自己设置) 1(2)、root用户你修改了哪个用户的家目录就对哪个用户有效 /etc/profile的作用 默认环境变量配置文件 正则表达式 条件判断 -if desc &apos;test2&apos; [root@localhost tmp]# cat sys.sh #!/bin/bash rate=$(df -h | grep /dev/sda3 | awk &apos;{print $5}&apos;|cut -d &quot;%&quot; -f1) if [ $rate -ge 1 ] then echo &quot;/dev/sda3 is full&quot; fi #!/bin/bash rate=$(df -h | grep /dev/sda3 | awk &apos;{print $5}&apos;|cut -d &quot;%&quot; -f1) if [ $rate -ge 1 ] then echo &quot;$(date) /dev/sda3 is full&quot; &gt;&gt; /tmp/shellwaring else echo &quot;$(date) /dev/sda3 is not full&quot; &gt;&gt; /tmp/shellinfo fi 多分支case条件语句 条件判断-for 条件判断-while 条件判断-until Linux 服务管理1、服务管理分类 源码包可以看到源代码 可以自定义 Rpm没有源代码 自定义差 独立服务：服务直接在内存中 客户直接调用服务，服务直接相应用户，速度快，服务多了浪费内存资源 基于xinetd服务本身是独立的 本身没有功能，后面有一系列服务rsync 网络备份服务，通过xinted相应 rsync 相应最后客户端相应速度慢 本身不占用内存 0关机 1单用户 2不完全多用户 3字符界面 4未分配 5图形界面 6重启动 1查看所有启动服务的进程 ps aux 2、RPM服务管理 #### 3、源码包服务管理 Linux系统备份与恢复1、备份和恢复概述 完全备份： 优点是数据恢复方便 缺点备份的数据量较大,备份时间较长,占用的空间较大 增量备份： 优点备份的数据较少，耗时较短，占用的空间较小； 缺点是数据恢复比较麻烦，先恢复完全备份的数据每次增量备份的数据，最终才能恢复所有的数据。 差异备份： 优点恢复数据简单方便快捷 缺点数据量庞大、备份速度缓慢、占用空间较大。 2、备份和恢复命令 Linux系统管理1、进程管理查看 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.5 0.0 2872 1416 ? Ss 15:36 0:01 /sbin/init root 2 0.0 0.0 0 0 ? S 15:36 0:00 [kthreadd] 用户 进程id 占用cpu 内存 内存daxiao 物理大 终端 状态 开始时间 占用cpu时间 名 2、进程管理终止 3、工作管理4、系统资源查看5、系统定时任务","tags":[]},{"title":"05 hbase笔记","date":"2019-05-09T07:36:00.000Z","path":"/posts/undefined/","text":"通用命令 status: 提供HBase的状态，例如，服务器的数量。 version: 提供正在使用HBase版本。 table_help: 表引用命令提供帮助。 whoami: 提供有关用户的信息。 数据定义语言（表操作命令）。 create: 创建一个表。 list: 列出HBase的所有表。 disable: 禁用表。 is_disabled: 验证表是否被禁用。 enable: 启用一个表。 is_enabled: 验证表是否已启用。 describe: 提供了一个表的描述。 alter: 改变一个表。 exists: 验证表是否存在。 drop: 从HBase中删除表。 drop_all: 丢弃在命令中给出匹配“regex”的表。 Java Admin API: 在此之前所有的上述命令，Java提供了一个通过API编程来管理实现DDL功能。在这个org.apache.hadoop.hbase.client包中有HBaseAdmin和HTableDescriptor 这两个重要的类提供DDL功能。 数据操纵语言 put: 把指定列在指定的行中单元格的值在一个特定的表。 get: 取行或单元格的内容。 delete: 删除表中的单元格值。 deleteall: 删除给定行的所有单元格。 scan: 扫描并返回表数据。 count: 计数并返回表中的行的数目。 truncate: 禁用，删除和重新创建一个指定的表。 Java client API: 在此之前所有上述命令，Java提供了一个客户端API来实现DML功能，CRUD（创建检索更新删除）操作更多的是通过编程，在org.apache.hadoop.hbase.client包下。 在此包HTable 的 Put和Get是重要的类。 创建样本模式 列族 创建表create &apos;emp&apos;, &apos;personal data&apos;, &apos;perfessional data&apos; 更改列族单元格的最大数目hbase&gt; alter &apos;t1&apos;, NAME =&gt; &apos;f1&apos;, VERSIONS =&gt; 5 表范围运算符 使用alter，可以设置和删除表范围，运算符，如MAX_FILESIZE，READONLY，MEMSTORE_FLUSHSIZE，DEFERRED_LOG_FLUSH等。 #设置只读 hbase&gt;alter &apos;t1&apos;, READONLY(option) alter ‘emp’, READONLYalter ‘t1’, METHOD =&gt; ‘table_att_unset’, NAME =&gt; ‘MAX_FILESIZE’ drop 在删除一个表之前必须先将其禁用。hbase(main):018:0&gt; disable &apos;emp&apos; hbase(main):019:0&gt; drop &apos;emp&apos; HBase创建数据put 命令, add() - Put类的方法 put() - HTable 类的方法 使用put命令，可以插入行到一个表。它的语法如下： put &apos;&lt;table name&gt;&apos;, &apos;row1&apos;, &apos;&lt;colfamily:colname&gt;&apos;,&apos;&lt;value&gt;&apos; 插入第一行 put &apos;emp&apos;, &apos;1&apos;,&apos;personal data:name&apos;,&apos;xifu&apos; put &apos;emp&apos;, &apos;1&apos;, &apos;personal data:city&apos;,&apos;taizhou&apos; put &apos;emp&apos;, &apos;1&apos;, &apos;perfessional data:designation&apos;,&apos;manager&apos; put &apos;emp&apos;, &apos;1&apos;, &apos;perfessional data:salary&apos;,&apos;50000&apos;","tags":[]},{"title":"04 python爬虫笔记","date":"2019-03-28T06:34:00.000Z","path":"/posts/undefined/","text":"爬虫如何抓取网页数据网页三大特征：1、网页都有自己的唯一的URL（统一资源定位符）来进行定位。2、网页都使用HTML(超文本标记语言)来描述页面信息。3、网页都使用HTTP/HTTPS(超文本传输协议)协议来传输HTML数据。 爬虫的设计思路1、首先确定需要爬取的网页URL地址。2、通过HTTP/HTTP协议协议来获取对应的HTML页面。3、提取HTML页面里有用的数据： a.如果是需要的数据，就保存起来。 b.如果是页面里的其他URL，那就继续执行第二步。 #为什么选择Python做爬虫？PHP：是世界上最好的语言，但他天生不是干爬虫的，对多线程，异步支持不够好。爬虫是工具性程序，对速度和效率的要求比较高。Java爬虫生态圈很完善，是Python爬虫最大的对手。但是Java语言本身很笨重，代码量很大。爬虫经常需要修改部分采集代码，所以Java不合适。C/C++运行效率和性能几乎最强，但是学习成本很高。代码成型比较慢。能用C/C++做爬虫，只能说是能力的表现，但不是正确的选择。Python语法优美、代码简介、开发效率高、支持的模块多，相关HTTP请求模块还有强大的爬虫Scrapy，以及成熟高效的scrapy-redis分布式策略。而且，调用其他接口也非常方便（胶水语言） 如何抓取HTML页面：HTTP请求的处理，urllib、urllib2、requests 处理后的请求可以模拟浏览器发送请求，获取服务器响应的文件 #解析服务器响应的内容 re、xpath、BeautifulSoup4（bs4）、jsonpath、pyquery等 使用某种描述性一样来给我们需要提取的数据定义一个匹配规则 符合这个规则的数据就会被匹配 #如何采集动态HTML、验证码的处理 通过动态页面采集，Selenium+PhantomJS(无界面)：模拟真实浏览器加载js、ajax等非静态的数据。 Tesseract：机器学习库，机器图像识别系统，可以处理简单的验证码，复杂的验证码可以通过手动输入/专门的打码平台。 sccrapy框架：（Scrapy，Pyspider） 搞定制性高性能（异步网络框架 twisterd），所以数据下载速度非常快，提供了数据存储、数据下载、提取规则等组件。 分布式策略：scrapy-redis，在Scrapy的基础上添加了一套以Redis数据库为核心的一套组件。让Scrapy框架支持分布式的功能。主要在Redis里做请求指纹去重、请求分配、数据临时存储。 爬虫–反爬虫–反反爬虫 之间的斗争：其实怕重做到最后，最头疼的不是复杂的页面，也是灰色的数据，而是网站另一边的反爬虫人员。 User-Agent、代理、验证码、动态数据加载、加密数据。 数据价值、是否值的去费劲做反爬虫。 1. 机器成本 + 人力成本 &gt; 数据价值，就不反了，一般做到封IP就结束了。 2、面子的战争...... 爬虫和反爬虫之间的斗争，最后一定是爬虫获胜。 为什么？只要是真实用户可以浏览的网页数据，爬虫就一定能爬下来！ #根据使用场景 分为 ：通用爬虫 聚焦爬虫1通用爬虫：搜索引擎用的爬虫系统。1、目标：就是尽可能吧互联网上所有的网页下载下来，放到本地服务器里形成备份； 再对这些网页做相关处理（提取关键字、去掉广告），最后提供一个用户检索接口。2、抓取流程： a） 首选选取一部分已有的URL，把这些URL放到待爬取队列。 b） 从队列里取出这些URL，然后解析DNS得到主机IP，然后去这个IP对应的服务器里下载HTML页面，保存到搜索引擎的本地服务器。之后把这个爬过的URL放入已爬取队列。 c）分析这些网页内容，找出网页里其他的URL链接，继续执行第二步，直到爬取条件结束。3、搜索引擎如何获取一个新网站的URL: A).主动向搜索引擎提交网址, B).向其他网站里设置网站的外链。 C).搜索引擎会和DNS服务商进行合作，可以快速收录新的网站。 DNS：就是把域名解析成IP的一种技术。4、通用爬虫并不是万物皆可爬，它也需要遵守规则：Robots协议：协议会指明通用爬虫可以爬取网页的权限。Robots.txt 只是一个建议。并不是所有爬虫都遵守，一般只有大型的搜索引擎爬虫才会遵守。咱们个人写的爬虫，就不用管了。5、通用爬虫工作流程：爬取网页 - 存储数据 - 内容处理 - 提供检索/排名服务6、搜索引擎排名： ·PageRank值：根据网站的流量（点击量/浏览量/人气）统计，流量越高，网站越值钱，排名越靠前。 ·竞价排名：谁给钱多，谁排名就高。7、通用爬虫的缺点： 1、只能提供和文本相关的内容（HTML、Word、PDF）等等，但是不能提供多媒体（音乐、图片、视频）和二进制文件（程序、脚本）等。 2、提供的结果千篇一律，不能针对不同背景领域的人提供不同的搜索结果。 3、不能理解人类语义上的检索。 2聚焦爬虫：爬虫程序员写的针对某种内容爬虫。面向主题爬虫、面向需求爬虫：会针对某种特定的内容去爬取信息，而且会保证信息和需求息息相关。 http的端口号：80；https的端口是：443； Python自带的模块：/usr/lib/python2.7/urllib2.py Python的第三方模块： /usr/local/lib/python2.7/site-packages urllib2 默认的 User-Agent：Python-urllib/2.7 User-Agent: 是爬虫和反爬虫斗争的第一步，养成好习惯，发送请求带User-Agent response 是服务器响应的类文件，除了支持文件操作的方法外，还支持以下常用的方法： 返回 HTTP的响应码，成功返回200，4服务器页面出错，5服务器问题 print response.getcode() 返回 返回实际数据的实际URL，防止重定向问题print response.geturl() 返回 服务器响应的HTTP报头print response.info() User-Agent 历史： Mosaic 世界上第一个浏览器：美国国家计算机应用中心 Netscape 网景：Netscape（支持框架），慢慢开始流行….(第一款支持框架的浏览器) Microsoft 微软：Internet Explorer（也支持框架） 第一次浏览器大战：网景公司失败..消失 Mozilla 基金组织：Firefox 火狐 - （Gecko内核）(第一款浏览器内核) User-Agent 决定用户的浏览器，为了获取更好的HTML页面效果。 IE开了个好头，大家都开就给自己披着了个 Mozilla 的外皮 Microsoft公司：IE（Trident） Opera公司：Opera（Presto） Mozilla基金会：Firefox（Gecko） Linux组织：KHTML （like Gecko） Apple公司：Webkit（like KHTML） Google公司：Chrome（like webkit） 其他浏览器都是IE/Chrome内核 Scrapy架构图（绿线是数据流向）：ScrapyEngine（引擎）：负责通讯，信号、数据传递 制作Scrapy爬虫 四步骤： 新建项目（scrapy startproject xxx）:新建一个新的爬虫项目 明确目标（编写items.py）：明确你想要爬取的目标 制作爬虫（spiders/xxspider.py）：制作爬虫开始爬取网页 存储内容（pipelines.py）：设计管道存储爬取内容 创建爬虫项目1234#创建普通项目scrapy startproject 项目名#创建模板scrapy startproject 项目名 网站名","tags":[]},{"title":"02 HDFS上传和读取流程","date":"2019-03-28T06:34:00.000Z","path":"/posts/undefined/","text":"上传流程 1.根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在。 2.namenode返回是否可以上传 3.client请求第一个 block该传输到哪些datanode服务器上 4.namenode返回3个datanode服务器ABC 5.client请求3台dn中的一台A上传数据（本质上是一个RPC调用，建立pipeline），A收到请求会继续调用B，然后B调用C，将这个pipeline建立完成，逐级返回客户端 6.client开始往A上传第一个block（先从磁盘读取数据放到一个本地内存缓存），以packet为单位，A收到一个packet就会传给B，B传给C；A每传一个packet会放入一个应答队列等待应答 7.当一个block传输完成之后，client再次请求namenode上传第二个block的服务器。读取流程客户端读取HDFS数据相比写入数据要简单一些，以下是读取数据步骤： 1.client访问NameNode，查询元数据信息，获得这个文件的数据块位置列表，返回输入流对象。 2.就近挑选一台datanode服务器，请求建立输入流。 3.开始读取这个数据的第一个block块，读取完全之后，开始接着读取这个文件的第二个block，直至把这个数据所有的block都读完了则文件读取完全了。 4.数据读完之后关闭流连接。 5.如果读取过程当中读取失败，将会依次读取该数据块的下一个副本，失败的节点将会被记录，不再连接。 ￼# SecondaryNameNodeSecondaryNameNode 是 HDFS 架构中的一个组成部分，它用来保存名称节点中对HDFS元数据信息的备份，减小Editlog文件大小，从而缩短名称节点重启的时间。 它一般是单独运行在一台机器上。 SecondaryNameNode让EditLog变小的工作流程如下: (1)SecondaryNameNode 会定期和 NameNode 通信，请求其停止使用 EditLog 文件，暂时将 新的写操作写到一个新的文件 edit.new 中，这个操作是瞬间完成的，上层写日志的函数完全感觉不到差别。 (2) SecondaryNameNode 通过 HTTP GET 方式从 NameNode 上获取到 Fslmage 和 EditLog 文 件，井下载到本地的相应目录下。 (3) SecondaryNameNode 将下载下来的 Fslmage 载入到内存，然后一条一条地执行 EditLog 文件中的各项更新操作，使内存中的 Fslmage 保持最新。 这个过程就是 EditLog 和 Fslmage 文件合 井。 (4) SecondaryNameNode 执行完（3）操作之后，会通过 post 方式将新的 Fslmage 文件发送 到 NameNode 节点上 (5) NameNode 将从 SecondaryNameNode 接收到的新的 Fslmage 替换旧的 Fslmage 文件，同 时将 Edit.new 替换 EditLog 文件，从而减小 EditLog 文件大小。￼从上面的过程可以看出，第二名称节点相当于为名称节点设置一个“检查点” ，周期性备份 名称节点中的元数据信息，但第二名称节点在 HDFS 设计中只是一个冷备份，并不能起到“热备 份”的作用。 HDFS 设计并不支持当名称节点故障时直接切换到第二名称节点。 HDFS FederationHDFSl.O 的单 NameNode 设计不仅存在单点故障问题，还存在可扩展性和性能问题。只有一 个 NameNode， 不利于水平扩展。 HDFS Federation (HDFS 联邦）特性允许一个 HDFS 集群中存在 多个 NameNode 同时对外提供服务，这些 NameNode 分管一部分目录（水平切分），彼此之间相 互隔离，但共享底层的 DataNode 存储资源。每个 NameNode 是独立的，不需要和其他 Nam巳Node 协调合作。 如图 4-5 所示 ， Federation 使用了 多 个独立的 NameNode/NameSpace 命名空间。这些 NameNode 之间是联合的，也就是说， 它们之间相互独立且不需要互相协调，各自分工管理自己的 区域。分布式的 DataNode 被用作通用的数据块存储设备。每个 DataNode 要向集群中所有的 NameNode 注册，且周期性地向所有 NameNode 发送心跳和块报告， 并执行来自所有 NameNode 的命令。每一个 DataNode 作为统一的块存储设备被所有 NameNode 节点使用。 每一个 DataNode 节点都在所有的 NameNode 进行注册。 DataNode 发送心跳信息、块报告到 所有 NameNode，同时执行所有 NameNode 发来的命令。￼","tags":[]},{"title":"03 python笔记","date":"2019-03-28T06:34:00.000Z","path":"/posts/undefined/","text":"1、ipython命令技能实现python命令，也能实现部分linux命令。2、python2不能识别文件里的中文，如果硬要识别，在头文件中加上 -- coding:utf-8 -- （python官方推荐这种方式）3、输入一个数1high = input(&quot;请输入一个数&quot;) 4、输出一个数12345age = 18print(&quot;age的值为%d&quot;%age)name = &quot;西芙&quot;print(&quot;name的值为%s&quot;%name);print(&quot;name的值是%s,年龄的值是%d&quot;%(name,age)) 4、if else语句12345678910age = 19if age&gt;18: print(&quot;已经成年&quot;)else print(&quot;未成年&quot;)#input获取的所有数据都会当成字符串类型#python 规定 str（）&gt;int()#所以如果 age = input(&quot;一个值&quot;)#要与int比较，需要把age换成int类型，即#age_num = int(age) 5、python语言是弱类型的编程语言，及赋值的时候已经知道是什么类型6、查看变量类型1type(a) 7、python的变量类型123456·Numbers(数字)： int(有符号整型)，long（长整型[也可代表八进制和十六进制]），float（浮点型），complex（复数）·布尔类型： True，False·String（字符串）·List（列表）·Tuple（元组）·Dictionary（字典） 8、关键字￼查看关键字命令12import keyword #导入keyword包keyword.kwlist 9、运算符12345&quot;s&quot;*10#输出&apos;ssssssssss&apos;#幂#** 10、is是地址相同的意思，在数值-5到256间，a与b地址相同，其余不同￼11、深拷贝与浅拷贝123456789101112131415161718192021222324252627282930313233#例1、浅拷贝a = [11, 22, 33]b = a #浅拷贝，地址拷贝，地址相同#例2、深拷贝import copyc = copy.deepcopy(a) #开辟一个内存空间，拷贝内容#例3、在数组中，深拷贝数组后，a = [11,22,33]b = [44,55,66]c = [a, b]d = copy.deepcopy[c]#查看c，d的id，并不相同，深拷贝#在a数组中添加[44],查看c[0],d[0]a.append(44)c[0][11,22,33,44]d[0][11,22,33]#说明深拷贝后，d另外拷贝了有关a、b的拷贝#例4、有关指向a，b的拷贝e = copy.copy(c)a.append(55)c[0]e[0]#所看到的结果都是[11,22,33,44,55]id(c)id(e)#所看到的地址不同，所以他们是指向不同的地址但所指向数组的内容地址是相同的#但如果是c = (a,b)，是元组的话，由于元组是不可变类型，e = copy.copy(c),他们所指向的地址是一样的#所以使用copy模块的copy功能时候，它会根据当前拷贝的数据类型是可变类型还是不可变类型有不同的处理方式 12、私有化12345678910class Test(object): def __init__(self): self.__num = 100 def setNum(self, newNum): self.__num = newNum def getNum(self): return self.__numt = Test()t.__num = 200 #可以使用print(t.__num) 升级版私有化 property使用123456789class Test(object): def __init__(self): self.__num = 100 def setNum(self, newNum): self.__num = newNum def getNum(self): return self.__num num = property(getNum, setNum)#!!!!#此时，可以用t.num = ?赋值 或者 t.num 取值，不用调用函数 装饰器使用12345678910class Test(object): def __init__(self): self.__num = 100 @property def num(self): return self.__num @num.setter def num(self, newNum): self.__num = newNum#与上面的代码意思相同。理解一下吧~ 1、xx:公有变量2、x:单前置下划线，私有化属性或方法，from somemodule import * 禁止导入，类对象和子类可以访问3、__x:双前置下划线，避免与子类中的属性命名冲突，无法在外部直接访问（名字重整所以访问不到）4、x：双前后下划线，用户名字空间的魔法对象或属性。例如init,__不要自己发明这样的名字5、xx_:单后置下划线，用于避免与python关键词的冲突 ###但是私有属性实际上是可以访问，python把私有属性的名字由原来的_私有属性名 改成 _类名私有属性名，所以可以通过对象._类名__私有属性名可以获取值！！！ 13、迭代器迭代器 迭代器是访问集合元素的一种方式，迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，知道所有的元素被访问完结束。迭代器只能往前不会后退。可迭代对象： 可直接作用于for循环的数据类型有以下几种： 一类是集合数据类型：如list、tuple、dict、set、str等 一类是generator，包括生成器和带yield的generator function。 可以直接作用于for循环的对象统称为可迭代对象：Iterable。 14、闭包：定义：函数里面有另外的函数，并且里面的函数用到了外面的函数的变量闭包的应用：1234567891011121314def test(number): print(&quot;--1--&quot;) def test_in(number2): print(&quot;--2--&quot;) print(number+number2) print(&quot;--3--&quot;) return test_in ret = test(100)print(&quot;-&quot;*30)ret(1)ret(100)ret(200)#优点 简化了步骤 linux快捷键： %s/^/#/g 所有行前面加# 1,14/#//g 去掉1-14行的#15、装饰器12345678910111213141516171819def w1(func): def inner(): print(&quot;----正在验证权限---&quot;) func() return innerdef f1(): print(&quot;---f1---&quot;)def f2(): print(&quot;---f2---&quot;)#innerFunc = w1(f1)#innerFunc()f1 = w1(f1) #把w1（f1）赋值给f1，也就是说f1 = w1.inner，f1指向的就是inner这个函数f1() #调用后，执行的是inner，但由于之前传入f1的参数，所以输出结果为inner的输出结果+f1函数的输出结果@w1 #与上面f1=w1(f1)意义相同，但只要python执行器执行到了这个代码，name就会自动的进行装饰，而不是等到调用的时候才装饰的 语法糖 @w1def f1(): print(&quot;---f1---&quot;) 12345678910111213141516171819#若有参数def func(functionName): print(&quot;---func---1---&quot;) def func_in(*args, **kwargs):#如果没有定义参数，会导致调用的时候出现问题 print(&quot;---func_in---1---&quot;) functionName(*args, **kwargs)#传入同样的参数 print(&quot;---func_in---2---&quot;) print(&quot;---func---2---&quot;) return func_in@funcdef test(a, b, c): print(&quot;---test-a=%d,b=%d,c=%d---&quot;%(a,b,c)) @funcdef test2(a, b, c, d): print(&quot;---test-a=%d,b=%d,c=%d,d=%d---&quot;%(a,b,c,d))test(11,22,33)test2(44,55,66,77) 12345678910111213141516171819202122232425262728#通用装饰器def func(functionName): def func_in(*args, **kwargs): print(&quot;---记录日志---&quot;) ret = functionName(*args, **kwargs) return ret return func_in@funcdef test(): print(&quot;---test---&quot;) return &quot;haha&quot;@funcdef test2(): print(&quot;---test2---&quot;)@funcdef test3(a): print(&quot;---test3---a=%d--&quot;%a) ret = test()print(&quot;test return value is %s&quot;%ret)a = test2()print(&quot;test2 return value is %s&quot;%a)test3(11) 16、作用域 #什么是命名空间在某个范围内所能用到的作用域 17、类方法与静态方法1234567891011121314151617#给类添加方法import types #导入types包class Person(object): def __init__(self, newName, newAge): self.name = newName self.age = newAge def eat(self): print(&quot;-----%s正在吃----&quot;%self.name)def run(self): print(&quot;-----%s正在跑----&quot;%self.name) p1 = Person(&quot;p1&quot;, 10)p1.eat()p1.run = types.MethodType(run, p1)p1.run() 18、限制class实例添加的属性123456789class Person(object): __slots__ = (&quot;name&quot;, &quot;age&quot;)p = Person()p.name = &quot;老王&quot;p.age = 20p.score = 100 #会报错！！！``` ## 生成器、迭代器、装饰器、闭包（重点）！！19、生成器 In [1]: a = [x*2 for x in range(10)]In [2]: aOut[2]: [0, 2, 4, 5, 6, 10, 12, 14, 16, 18] #如果用[]，会生成数组，同时加载到内存中 #如果用括号（），输出的是一个地址，需要时才提取出In [3]: b = (x*2 for x in range(10))In [4]: bOut[4]: &lt;generator object at 0x7fb057ff06d0&gt;In [5]:next(b)Out[5]:0120、a，b交换 def creatNum(): print(“—-start—-“) a, b = 0, 1 for i in range(5): print(“—-1—-“) yield b #python中有一个非常有用的语法叫做生成器，所利用到的关键字就是yield。有效利用生成器这个工具可以有效地节约系统资源，避免不必要的内存占用。当执行到这的时候，会做停顿。 print(“—-2—-“) a, b = b, a+b print(“—-3—-“) print(“—-stop—-“) #创建了一个生成器对象a = creatNum() #实现交换a, b = 0, 1a, b = b, a121、斐波拉契数列 a,b = 0, 1a,b = b, a+b #重复此步骤122、类当做装饰器 #1class Test(object): def call(self): print(“—test—“)t = Test()t() #out: —test— #2class Test(object): def init(self, func): print(‘—初始化—‘) print(‘func name is %s’func.name) self.func = func def call__(self): print(‘—装饰器中的功能—‘) self.__func() @Test #相当于 t = Test(test)def test(): print(‘—test—‘) #out: —初始化— #out:func name is ‘test’ test() #out: —装饰器中的功能 #out:—test—123、元类 Test = type(“Test”, (), {})#相当于创建一个类Test #out:__main.Test #创建一个拥有属性num=0的Person类Person = type(“Person”,(),{“num”:0}) #创建一个拥有方法printNum()的Test3类def printNum(self): print(“–num-%d–”%self.num)Test3 = type(“Test3”,(),{“printNum”:printNum}) 12345678910111213141516171819202122232425```#设置Foo类的属性变大写！！，通过metaclass设置def upper_attr(future_class_name, future_class_parents, future_class_attr): #Foo object &#123;bar:&quot;bip&quot;&#125; #遍历属性字典，把不是__开头的属性名字变成大写 newAttr = &#123;&#125; for name, value in future_class_attr.items(): if not name.startswith(&quot;__&quot;): newAttr[name.upper()] = value #调用type创建一个类 return type(future_class_name,future_class_parents,newAttr)class Foo(object,metaclass=upper_attr): # __metaclass__ = upper_attr #设置Foo类的元类为upper_attr python2 bar = &quot;bip&quot;print(hasattr(Foo, &quot;bar&quot;))print(hasattr(Foo, &quot;BAR&quot;))f = Foo()print(f.BAR)#out:False#out:True#out:bip 24、内建属性123456789101112131415161718class Itcast(object): def __init__(self,subject1): self.subject1 = subject1 self.subject2 = &apos;cpp&apos; #属性访问时拦截器，打log def __getattribute__(self,obj): #obj--&gt;&quot;subject1&quot; if obj == &apos;subject1&apos;: print(&apos;log subject1&apos;) return &apos;redirect python&apos; else: return object__getattribute__(self,obj) def show(self): print(&apos;this is Itcast&apos;) s = Itcast(&quot;python&quot;)print(s.subject1)print(s.subject2) 内建方法25、lambda之map123456789101112131415#函数需要一个参数map(lambda x: x*x, [1, 2,3])#结果为：[1, 4, 9]#函数需要两个参数map(lambda x, y: x+y, [1, 2, 3], [4, 5, 6])#结果为:[5,7,9]def f1(x, y): return (x, y)l1 = [0,1,2,3,4,5,6]l2 = [&apos;Sun&apos;, &apos;M&apos;, &apos;T&apos;, &apos;W&apos;, &apos;T&apos;, &apos;F&apos;, &apos;S&apos;]l3 = map(f1, l1, l2)print(list(l3))结果为：[(0,&apos;Sun&apos;), (1,&apos;M&apos;).....] 26、lambda之filter12345fliter(lambda x : x%2, [1, 2 ,3, 4]) #如果为1，则输出[1, 3]filter(None, &quot;she&quot;)&apos;she&apos; 27、lambda之reduce12345678reduce(lambda x, y: x+y, [1,2,3,4])10 #先把1赋值给x，2赋值给2，x+y后=3，把3赋值给x，数组中的3赋值给y，再累加，以此类推reduce(lambda x, y:x+y, [1,2,3,4], 5)15 #如果前面是数组，先把5赋值给x，再累加[1,,2,3,4]reduce(lambda x, y: x+y, [&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;], &apos;dd&apos;)ddaabbcc 28、sort123456789a = [9,8,7,6,5,4,3,2,1]a.sort()a#[1,2,3,4,5,6,7,8,9]b = [&apos;dd&apos;,&apos;cc&apos;,&apos;bb&apos;,&apos;aa&apos;]b.sort()b#[&apos;aa&apos;,&apos;bb&apos;,&apos;cc&apos;,&apos;dd&apos;] 28、python的functools包中提供了一个叫wraps的装饰器来消除这样的副作用1234567891011121314151617import functoolsdef note(func): &quot;note function&quot; @functoolswraps(func) def wrapper(): &quot;wrapper function&quot; print(&quot;note something&quot;) return func() return wrapper@notedef test(): &quot;test function&quot; print(&apos;I am test&apos;)test()print(test.__doc__)","tags":[]}]