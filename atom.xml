<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小西芙-沿着回忆我走过旧时光</title>
  <icon>https://www.gravatar.com/avatar/b6e94d356a58f5cfb718a518e748a427</icon>
  <subtitle>小西芙-沿着回忆我走过旧时光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xifujiang.github.io/"/>
  <updated>2020-01-13T07:06:23.610Z</updated>
  <id>https://xifujiang.github.io/</id>
  
  <author>
    <name>xifujiang</name>
    <email>229694302@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jvm</title>
    <link href="https://xifujiang.github.io//posts/f0675471/"/>
    <id>https://xifujiang.github.io//posts/f0675471/</id>
    <published>2020-01-12T16:00:00.000Z</published>
    <updated>2020-01-13T07:06:23.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>java虚拟机（java virtual machine，JVM），一种能够运行java字节码的虚拟机。JVM不只是专用于java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。如kotlin、scala等。</p><p>jvm有很多，不只是Hotspot，还有JRockit、J9等。</p><a id="more"></a><h2 id="一、JVM的基本结构"><a href="#一、JVM的基本结构" class="headerlink" title="一、JVM的基本结构"></a>一、JVM的基本结构</h2><p>JVM由三个主要的子系统构成</p><ul><li>类加载子系统</li><li>运行时数据区（内存结构）</li><li>执行引擎</li></ul><h2 id="二、类加载子系统"><a href="#二、类加载子系统" class="headerlink" title="二、类加载子系统"></a>二、类加载子系统</h2><h3 id="1、类的生命周期"><a href="#1、类的生命周期" class="headerlink" title="1、类的生命周期"></a>1、类的生命周期</h3><p>加载->连接（验证，准备，解析）->初始化->使用->卸载</p><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h4><p>将.class文件从磁盘读到内存</p><h4 id="2-连接"><a href="#2-连接" class="headerlink" title="2.连接"></a>2.连接</h4><h5 id="2-1验证"><a href="#2-1验证" class="headerlink" title="2.1验证"></a>2.1验证</h5><p>验证字节码文件的准确性</p><h5 id="2-2准备"><a href="#2-2准备" class="headerlink" title="2.2准备"></a>2.2准备</h5><p>给类的静态变量分配内存，并赋予默认值</p><h5 id="2-3解析"><a href="#2-3解析" class="headerlink" title="2.3解析"></a>2.3解析</h5><p>类装载器装入类所引用的其他所有类</p><h4 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h4><p>为类的静态变量赋予正确的初始值，上述的准备阶段为静态变量赋予的是虚拟机默认的初始值，此处赋予的才是编程编写者为变量分配的真正的初始值，执行静态代码块。</p><h4 id="4-使用"><a href="#4-使用" class="headerlink" title="4.使用"></a>4.使用</h4><h4 id="5-卸载"><a href="#5-卸载" class="headerlink" title="5.卸载"></a>5.卸载</h4><h3 id="2、类的加载器种类"><a href="#2、类的加载器种类" class="headerlink" title="2、类的加载器种类"></a>2、类的加载器种类</h3><h4 id="启动类加载器（Bootstrap-ClassLoader）"><a href="#启动类加载器（Bootstrap-ClassLoader）" class="headerlink" title="启动类加载器（Bootstrap ClassLoader）"></a>启动类加载器（Bootstrap ClassLoader）</h4><p>负责加载<strong>JRE的核心类库</strong>，如JRE目标下的rt.jar，charsets.jar等</p><h4 id="扩展类加载器（Extension-ClassLoadEer）"><a href="#扩展类加载器（Extension-ClassLoadEer）" class="headerlink" title="扩展类加载器（Extension ClassLoadEer）"></a>扩展类加载器（Extension ClassLoadEer）</h4><p>负责加载JRE扩展目录<strong>ext</strong>中jar类包</p><h4 id="系统类加载器（Application-ClassLoader）"><a href="#系统类加载器（Application-ClassLoader）" class="headerlink" title="系统类加载器（Application ClassLoader）"></a>系统类加载器（Application ClassLoader）</h4><p>负责加载<strong>ClassPath</strong>路径下的类包</p><h4 id="用户自定义加载器（User-ClassLoader）"><a href="#用户自定义加载器（User-ClassLoader）" class="headerlink" title="用户自定义加载器（User ClassLoader）"></a>用户自定义加载器（User ClassLoader）</h4><p>负责加载<strong>用户自定义路径</strong>下的类包</p><h2 id="2、类加载机制"><a href="#2、类加载机制" class="headerlink" title="2、类加载机制"></a>2、类加载机制</h2><h3 id="全盘负责委托机制"><a href="#全盘负责委托机制" class="headerlink" title="全盘负责委托机制"></a>全盘负责委托机制</h3><p>当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>指先委托父类加载器寻找目标类，在找不到的情况下载自己的路径中查找并载入目标类</p><h3 id="双亲委派模式的优势"><a href="#双亲委派模式的优势" class="headerlink" title="双亲委派模式的优势"></a>双亲委派模式的优势</h3><ul><li>沙箱安全机制：比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改</li><li>避免类的重复加载：当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次</li></ul><h2 id="GC算法和收集器"><a href="#GC算法和收集器" class="headerlink" title="GC算法和收集器"></a>GC算法和收集器</h2><p>新生代：轻GC</p><p>老年代：full GC</p><h3 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h3><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能被任何途径使用的对象）</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1。任何时候计数器为0的对象就是不可能再被使用的。</p><p>这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它<strong>很难解决对象之前相互循环引用的问题</strong>。</p><h3 id="可达性分析算法！！"><a href="#可达性分析算法！！" class="headerlink" title="可达性分析算法！！"></a>可达性分析算法！！</h3><p>这个算法的基本思想就是通过一系列的称为“<strong>GC Roots</strong>”的对象作为起点，这些节点开始向下搜索，节点走过的路径与当一个对象到GC Roots没有任何引用链相连的话，则证明此对象不可用的。</p><p>GC Roots根结点：类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等等。</p><h3 id="对象的引用："><a href="#对象的引用：" class="headerlink" title="对象的引用："></a>对象的引用：</h3><p>强引用 软引用 弱引用 虚引用</p><h3 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量"></a>如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。</p><p>如果在常量池中存在字符串“abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量“abc”就是废弃常量。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>需要满足以下三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>它是最基础的收集算法，这个算法分为两个阶段，“标记”和“清除”。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它有两个不足的地方：</p><p>1.效率问题，标记和清除两个过程的效率都不高。</p><p>2.空间问题，标记清除后会产生大量不连续的碎片。</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，复制算法出现了。它可以把内存分为大小相同的两块，每次只使用其中一块。当这一块的内存使用完后，就将还存活的对象复制到另一块区，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对 内存区间的一般进行回收。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程和“标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象向一段移动然后直接清理掉边界以外的内存。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>现在的商用虚拟机的垃圾收集器基本都采用“分代收集”算法，这种算法就是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法，</p><p>在新生代中，每次收集都有大量对象死去，所以可以选择复制算法，只要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，就必须选择“标记-清除”或者“标记-整理”算法进行垃圾收集。</p><h2 id="三、垃圾收集器"><a href="#三、垃圾收集器" class="headerlink" title="三、垃圾收集器"></a>三、垃圾收集器</h2><p>Java虚拟机规范对垃圾收集器应该如何实现没有任何规定，因为没有所谓最好的垃圾收集器出现，只能根据具体的应用场景选择合适的垃圾收集器。</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器。是一个单线程收集器。它的“单线程”的意义不仅仅意味着它只会使用一条垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有线程（“Stop The World”），直到它收集结束。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><strong>应用程序线程</strong>——<strong>GC线程应用程序暂停</strong>——<strong>应用程序线程</strong></p><p>Serial收集器相比其他垃圾收集器更加<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是不错的选择。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等）和Serial收集器完全一样。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><strong>应用程序线程——GC线程 多线程并发 应用程序暂停—— 应用程序线程</strong></p><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与<strong>CMS收集器</strong>（真正意义上的并发收集器）配合工作。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器类似于ParNew收集器。</p><p>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><strong>应用程序线程——GC线程 多线程并发 应用程序暂停—— 应用程序线程</strong></p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种是JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以用Scavenge收集器和Parallel Old收集器。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>并行和并发概念补充：</p><ul><li>并行（Parallel）：<strong>指多条垃圾收集线程并行工作</strong>，但此时用户线程仍然处于等待状态。</li><li>并发（Concurrent）：<strong>指用户线程与垃圾收集线程同时执行</strong>（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</li></ul><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</p><p>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集器同线程（基本上）同时工作。</p><p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种”标记-清除”算法实现的，它的运作过程分为四个步骤：</p><ul><li>初始标记（CMS initial mark）：暂停所有的其他线程，并记录下直接与root相连的对象，速度很快。</li><li>并发标记（CMS concurrent mark）：同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li>重新标记（CMS remark）：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li><li>并发清除（CMS concurrent sweep）：开启用户线程，同时GC线程开始对为标记的区域做清扫。</li></ul><p>CMS主要优点：<strong>并发收集、低停顿。</strong></p><p>缺点：</p><ul><li>对CPU资源敏感；</li><li>无法处理浮动垃圾；</li><li>它使用的回收算法“标记-清除”算法导致收集结束时会有<strong>大量空间碎片产生</strong>。</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1（Garbage-First）是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时，还具备高吞吐性能特征。（被视为JDK1.7中HotSpot虚拟机的一个重要进化特征）</p><ul><li>并行和并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li>分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但还是保留了分代的概念。</li><li>空间整合：与CMS的“标记-清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器，从局部上来看是基于“”</li><li>可预测的停顿：这是G1相对于CMS的另一大<strong>优势</strong>，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li></ul><p>G1收集器的运作步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率。</p><h3 id="怎么选择垃圾收集器？"><a href="#怎么选择垃圾收集器？" class="headerlink" title="怎么选择垃圾收集器？"></a>怎么选择垃圾收集器？</h3><p>1、优先调整堆的大小让服务自己来选择</p><p>2、如果内存小于100m，使用串行收集器</p><p>3、如果是单核，并且没有停顿时间的要求，串行或JVM自己选择</p><p>4、如果允许停顿时间超过1秒，选择并行或者JVM自己选</p><p>5、如果响应时间最重要，并且不能超过1秒，使用并发收集器</p><p>官方推荐G1，性能高</p><h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><p>JVM调优主要是调整下面两个指标</p><p>停顿时间：垃圾收集器做垃圾回收中断应用执行时间。-XX:MaxGCPauseMillis</p><p>吞吐量：垃圾收集的时间和总时间的占比：1/（1+n），吞吐量为1-1/（1+n）。-XX:GCTimeRatio=99</p><h2 id="GC调优步骤-！！"><a href="#GC调优步骤-！！" class="headerlink" title="GC调优步骤 ！！"></a>GC调优步骤 ！！</h2><p>1、打印GC日志</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">idea</span><br><span class="line">在vm options处加入-XX:+PrintGCDetails</span><br><span class="line">测试:代码调用system.gc后输出以下内容:</span><br></pre></td></tr></tbody></table></figure><p>测试:代码调用system.gc后输出以下内容:</p><p>Tomcat可以直接加载Java_OPTS变量里</p><p>2、分析日志得到关键性指标</p><p>3、分析GC原因，调优JVM参数</p><p>使用GCeasy分析</p><h2 id="四、运行时数据区"><a href="#四、运行时数据区" class="headerlink" title="四、运行时数据区"></a>四、运行时数据区</h2><h3 id="1、内存私有"><a href="#1、内存私有" class="headerlink" title="1、内存私有"></a>1、内存私有</h3><p><strong>程序计数器</strong></p><blockquote><p> 较小的内存空间，线程所执行的字节码的行号指示器，线程私有<br>Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。每个线程都有一个独立的程序计数器。<br>1、如果执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址<br>2、如果正在执行的是Native方法，这个计数器值则为空。</p></blockquote><p><strong>Java虚拟机栈</strong></p><blockquote><p>线程私有的，生命周期与线程相同。<br>虚拟机栈描述的是Java方法执行的内存模型。<br>每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<br>通常我们讲的栈就是局部变量表部分。<br>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char…..）、对象引用（reference类型）、returnArrdress类型（指向了一条字节码指令的地址）</p></blockquote><p><strong>本地方法栈</strong></p><blockquote><p>本地方法栈则为虚拟机使用到的Native方法服务。<br>本地方法栈区域也会抛出StackOverflowError的OutOfMemoryError异常</p></blockquote><p><strong>Java堆</strong></p><blockquote><p>是JVM所管理的内存最大的一块。<br>唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。<br>java堆是垃圾收集器管理的主要区域，有时候也称为GC堆<br>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。<br>如果在堆中没有完成实例分配，并且堆也无法再扩展时。会抛出OutOfMemoryError异常</p></blockquote><p><strong>方法区</strong></p><blockquote><p>方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。<br>运行时常量池是方法区的一部分</p></blockquote><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><h2 id="新生代-老年代"><a href="#新生代-老年代" class="headerlink" title="新生代 老年代"></a>新生代 老年代</h2><p>Java堆是Java虚拟机管理的最大的一块内存空间，主要存放对象实例。</p><p>在Java中，堆被分为两块区域：新生代、老年代。</p><p>堆大小=新生代+老年代。（分别占堆空间为1/3、2/3）</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新生代又被分为Eden、from survivor、to survivor（8:1:1）</p><p>新生代这样划分是为了更好的管理堆内存中的对象，方便GC算法–>“复制算法”来进行垃圾回收。</p><p>JVM每次只会使用Eden和其中一块survivor来为对象服务，所以无论什么时候，都会有一块survivor空间，因此新生代实际可用空间为90%。</p><p>新生代GC（minor gc）：指发生在新生代的垃圾回收动作，因为Java对象大多数都是“朝生夕死”的特性，所以minor GC非常频繁，使用复制算法快速的回收。</p><p>新生代几乎是所有Java对象出生的地方，Java对象申请的内存和存放都是在这个地方。<br> 当对象在Eden（包括一个survivor，假如是from），当此对象经过一次minor GC后仍然存活，并且能够被另一块survivor所容纳（这里的survivor则是to），则使用复制算法将这些仍然存活的对象复制到to survivor区域中，然后清理掉Eden和from survivor区域，并将这些存活的对象年龄+1，以后对象在survivor中每熬过一次则+1，当达到某个值（默认为15），这些对象会成为老年代！</p><p>事情不是绝对，有些较大的对象（需要分配连续的内存空间），则直接进入老年代。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代GC（major GC）：指发生在老年代的垃圾回收动作，所采用的的是“标记–整理”算法。<br> 老年代几乎都是从survivor中熬过来的，不会轻易“死掉”，因此major GC不会像minor GC那样频繁</p><p><strong>什么叫复制算法</strong></p><p><strong>两块</strong>survivor，每次使用其中的块。<strong>当这一块使用完了，就将还存储着的对象复制到另一块survivor上面</strong>，然后<strong>再把已经使用过的内存空间一次清理掉</strong>，下图为示意图。</p><p>优点：不用考虑内存碎片问题，实现简单，运行效率高。<br> 缺点：当对象存活较高（PS：老年代）时，就要进行较多的复制操作，效率会很低。</p><p><img src="https:////upload-images.jianshu.io/upload_images/12577595-32ca8750634eda38.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/667/format/webp" alt="img"></p><p>复制算法示意图</p><p><strong>什么叫标记–整理算法</strong></p><p>与“标记-清理”算法相似，只是后续不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</strong>，下图为示意图。</p><p><img src="https:////upload-images.jianshu.io/upload_images/12577595-d37e5ffcde0d6611.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/669/format/webp" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h1&gt;&lt;p&gt;java虚拟机（java virtual machine，JVM），一种能够运行java字节码的虚拟机。JVM不只是专用于java语言，只要生成的编译文件匹配JVM对加载编译文件格式要求，任何语言都可以由JVM编译运行。如kotlin、scala等。&lt;/p&gt;
&lt;p&gt;jvm有很多，不只是Hotspot，还有JRockit、J9等。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JAVAEE笔记04——微服务</title>
    <link href="https://xifujiang.github.io//posts/7a6c41a4/"/>
    <id>https://xifujiang.github.io//posts/7a6c41a4/</id>
    <published>2020-01-06T16:00:00.000Z</published>
    <updated>2020-01-13T07:06:23.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、原始服务的调用"><a href="#一、原始服务的调用" class="headerlink" title="一、原始服务的调用"></a>一、原始服务的调用</h1><p>通过网页的请求，这个网页请求到另一个网页，利用nginx做负载均衡。</p><a id="more"></a><p><strong>消费者</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/indexClient.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>{</span><br><span class="line">        ResponseEntity<String> responseEntity = restTemplate.getForEntity(<span class="string">"http://127.0.0.1/index.do"</span>,String.class);</span><br><span class="line">        <span class="keyword">return</span> responseEntity.getBody();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>RestTemplate</strong>：</p><blockquote><p>是Spring用于同步client端的核心类，简化了与http服务的通信，并满足RestFul原则，程序代码可以给它提供URL，并提取结果。默认情况下，RestTemplate默认依赖jdk的HTTP连接工具。当然你也可以 通过setRequestFactory属性切换到不同的HTTP源，比如Apache HttpComponents、Netty和OkHttp。</p></blockquote><p><strong>生产者：1111</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>{</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index.do"</span>)</span><br><span class="line">    <span class="keyword">public</span> List<Map<String, String>> index() {</span><br><span class="line">        List<Map<String, String>> list= <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Map<String, String> map = <span class="keyword">new</span> HashMap<>();</span><br><span class="line">        map.put(<span class="string">"key"</span>,<span class="string">"port:1111"</span>);</span><br><span class="line">        list.add(map);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>生产者：1121</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>{</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index.do"</span>)</span><br><span class="line">    <span class="keyword">public</span> List<Map<String, String>> index() {</span><br><span class="line">        List<Map<String, String>> list= <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Map<String, String> map = <span class="keyword">new</span> HashMap<>();</span><br><span class="line">        map.put(<span class="string">"key"</span>,<span class="string">"port:1121"</span>);</span><br><span class="line">        list.add(map);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>nginx负载均衡</strong></p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">upstream backser {</span><br><span class="line">server 127.0.0.1:1111;</span><br><span class="line">server 127.0.0.1:1121;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">   server {</span><br><span class="line">       listen       80;</span><br><span class="line">       server_name  localhost;</span><br><span class="line"></span><br><span class="line">       #charset koi8-r;</span><br><span class="line"></span><br><span class="line">       #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">       location / {</span><br><span class="line">           root   html;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">proxy_pass http://backser;</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h1 id="二、-服务注册中心eureka"><a href="#二、-服务注册中心eureka" class="headerlink" title="二、 服务注册中心eureka"></a>二、 服务注册中心eureka</h1><p> <a href="https://github.com/Netflix/Eureka" target="_blank" rel="noopener">Eureka</a> 是 <a href="https://github.com/Netflix" target="_blank" rel="noopener">Netflix</a> 开发的，一个基于 REST 服务的，服务注册与发现的组件</p><p>它主要包括两个组件：Eureka Server 和 Eureka Client</p><ul><li>Eureka Client：一个Java客户端，用于简化与 Eureka Server 的交互（通常就是微服务中的客户端和服务端）</li><li>Eureka Server：提供服务注册和发现的能力（通常就是微服务中的注册中心）</li></ul><p>Eureka Server依赖包</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-netflix-eureka-server<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><p>Eureka Client依赖包</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line"><span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line"><span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-starter-netflix-eureka-client<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><p>依赖管理</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">dependencyManagement</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">dependencies</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">groupId</span>></span>org.springframework.cloud<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">artifactId</span>></span>spring-cloud-dependencies<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">version</span>></span>${spring-cloud.version}<span class="tag"></<span class="name">version</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">type</span>></span>pom<span class="tag"></<span class="name">type</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">scope</span>></span>import<span class="tag"></<span class="name">scope</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">dependencies</span>></span></span><br><span class="line"><span class="tag"></<span class="name">dependencyManagement</span>></span></span><br></pre></td></tr></tbody></table></figure><p>Server application.yml</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      default-zone:</span> <span class="attr">http://${eureka.instance.hostname}:${server.port}/eureka</span></span><br></pre></td></tr></tbody></table></figure><p>ServerApplication</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurakeApplication</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(EurakeApplication.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>client application.yml</p><figure class="highlight yml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">1111</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:9000/eureka</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">shadow-order-service-1111</span></span><br></pre></td></tr></tbody></table></figure><p>ClientApplication</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApplication1111</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(OrderApplication1111.class, args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="三、dubbo-zookeeper"><a href="#三、dubbo-zookeeper" class="headerlink" title="三、dubbo zookeeper"></a>三、dubbo zookeeper</h1><h2 id="zookeeper服务器启动的逻辑："><a href="#zookeeper服务器启动的逻辑：" class="headerlink" title="zookeeper服务器启动的逻辑："></a>zookeeper服务器启动的逻辑：</h2><p>1、初始化配置</p><p>2、监听端口</p><p>3、初始化DataTree</p><p>4、领导者选举  </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、原始服务的调用&quot;&gt;&lt;a href=&quot;#一、原始服务的调用&quot; class=&quot;headerlink&quot; title=&quot;一、原始服务的调用&quot;&gt;&lt;/a&gt;一、原始服务的调用&lt;/h1&gt;&lt;p&gt;通过网页的请求，这个网页请求到另一个网页，利用nginx做负载均衡。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shiro笔记</title>
    <link href="https://xifujiang.github.io//posts/7d9cd029/"/>
    <id>https://xifujiang.github.io//posts/7d9cd029/</id>
    <published>2019-12-24T02:05:40.081Z</published>
    <updated>2020-01-13T07:06:23.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><h2 id="什么是shiro"><a href="#什么是shiro" class="headerlink" title="什么是shiro"></a>什么是shiro</h2><p>shiro是基于java的开源的安全管理框架。可以完成认证，授权，会话管理，加密，缓存等功能。</p><a id="more"></a><h2 id="Primary-Concerns"><a href="#Primary-Concerns" class="headerlink" title="Primary Concerns"></a>Primary Concerns</h2><p>Authentication：认证</p><p>验证用户是否合法。也就是登陆。</p><p>Authorization：授权</p><p>授予谁具有访问某些资源的权限。</p><p>Session Management：会话管理</p><p>用户登录后的用户信息通过Session Management来进行管理，不管是在上面应用中。</p><p>Cryptograpy：加密</p><p>提供了常见的一些加密算法，使得在应用中很方便的实现数据安全，并且使用很便捷。</p><h2 id="Supporting-Features"><a href="#Supporting-Features" class="headerlink" title="Supporting Features"></a>Supporting Features</h2><p>Web support：web应用程序支持</p><p>​    Shiro可以很方便的集成到web应用程序中。</p><p>Caching：缓存</p><p>​    Shiro提供了对缓存的支持，多种缓存架构：如ehcache，还支持缓存数据库：如redis</p><p>Concurrency：并发支持</p><p>​    支持多线程并发访问</p><p>Testing：测试</p><p>RunAs：一个允许用户假设为另一个用户身份（如果允许）的功能。</p><p>Remember Me：记住我</p><h2 id="Shiro的架构"><a href="#Shiro的架构" class="headerlink" title="Shiro的架构"></a>Shiro的架构</h2><p><strong>Subject</strong>（org.apache.shiro.subject.Subject）</p><p>​        当前与软件进行交互的<strong>实体</strong>（用户，第三方服务，cron job，等等）的安全特定“视图”。</p><p><strong>SecurityManager</strong>(org.apache.shiro.mgt.SecurityManager)：<strong>安全管理器</strong></p><p>​        如上所述，SecurityManager是Shiro架构的心脏。它基本上是一个“保护伞”对象，协调其管理的组件以确保它们能够一起顺利的工作。它还管理每个应用程序用户的shiro的视图，因此它知道如何执行每个用户的安全操作</p><p><strong>Authenticator</strong>(org.apache.shiro.authc.Authenticator)：<strong>认证器</strong></p><p>​        负责验证用户的身份</p><p><strong>Authorizer：授权器</strong></p><p>​        负责为合法的用户指定其权限。控制用户可以访问那些资源。</p><p><strong>Realms：域</strong></p><p>用户通过shiro来完成相关的安全工作，shiro是不会维护数据信息的。在shiro的工作过程中，数据的查询和获取工作是通过Realm从不同的数据源来获取的。Realm可以获取数据库信息，文本信息等。</p><h1 id="二、用户认证"><a href="#二、用户认证" class="headerlink" title="二、用户认证"></a>二、用户认证</h1><p><strong>Authentication</strong>：用户认证</p><p>验证用户是否合法，需要提交身份和凭证给shiro。</p><p><strong>principals</strong>：用户的身份信息，是subject的标识属性。能够唯一标识Subject。如：电话号码，电子邮箱，身份证号码等。</p><p><strong>Credentials</strong> 凭证：密码。是只被subject知道的秘密值。可以是密码，也可以是数字证书等。</p><p><strong>Pricipals/Credentials</strong> 最常见的组合：用户名/密码。在shiro中通常使用UsernamePasswordToken来指定身份和凭证信息。</p><h2 id="在shiro中用户的认证流程"><a href="#在shiro中用户的认证流程" class="headerlink" title="在shiro中用户的认证流程"></a>在shiro中用户的认证流程</h2><p>1、subject -> 2、sucurity manager ->3、Authenticator ->4、Authentication-> 5、JDBC Realm</p><p><strong>shiro.ini</strong></p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">zhangsan</span>=<span class="number">1111</span></span><br><span class="line"><span class="attr">lisi</span>=<span class="number">1111</span></span><br></pre></td></tr></tbody></table></figure><p><strong>AuthenticationDemo</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationDemo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//1、创建SecurityManager工厂 读取相应的配置文件</span></span><br><span class="line">        Factory<SecurityManager> factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">"classpath:shiro.ini"</span>);</span><br><span class="line">        <span class="comment">//2、通过SecurityManager工厂获取SecurityManager的实例</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        <span class="comment">//3、将SecurityManager对象 设置到运行环境中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//4、通过SecurityUtils获取主体Subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//5、加入登录的用户名zhangsan和1111，</span></span><br><span class="line">            UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"zhangsan"</span>, <span class="string">"1111"</span>);</span><br><span class="line">            <span class="comment">//进行用户身份验证</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">            <span class="comment">//通过subject判断用户是否通过验证</span></span><br><span class="line">            <span class="keyword">if</span> (subject.isAuthenticated()) {</span><br><span class="line">                System.out.println(<span class="string">"用户登录成功"</span>);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                System.out.println(<span class="string">"用户名或密码不正确"</span>);</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">catch</span> (AuthenticationException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="常见的异常信息及处理"><a href="#常见的异常信息及处理" class="headerlink" title="常见的异常信息及处理"></a>常见的异常信息及处理</h2><p>在认证过程中有一个父异常为：AuthenticationException。</p><p>该异常有几个子类：</p><ul><li><p>DisabledAccountException 账户失效异常</p></li><li><p>ExcessiveAttemptsException 尝试次数过多</p></li><li>UnknowAccountException 用户不正确</li><li>ExpiredCredentialsException 凭证过期异常</li><li>IncorrrectCredentialsException 凭证不正确</li></ul><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ul><li>通过shiro相关api，创建securityManager及获取Subject实例</li><li>封装token信息</li><li>通过<strong>subject.login(token)</strong>进行用户认证<ul><li><strong>Subject</strong>接收<strong>token</strong>，通过其实现类<strong>DelegatingSubject</strong>将<strong>token</strong>委托给<strong>SecurityManager</strong>来完成认证。<strong>SecurityManager</strong>是接口通过<strong>DefaultSecurityManager</strong>来完成相关的功能。由<strong>DefaultSecurityManager</strong>中<strong>login</strong>来完成认证过程。在<strong>login</strong>调用了该类<strong>authenticate</strong>()来完成认证。该方法是由<strong>AuthenticatingSecurityManager</strong>来完成的。在该类的<strong>authenticate</strong>()中，通过调用<strong>authenticator</strong>(认证器)来完成认证工作。<strong>Authenticator</strong>是由其默认实现类<strong>ModularRealmAuthentucator</strong>来完成认证。通过<strong>ModularRealmAuthentucator</strong>中的<strong>doAuthenticate</strong>来获取Realms信息。如果是单realm直接将token和realm中的数据进行比较，判断是否认证成功。如果是多realm那么需要通过<strong>Authentication Strategy</strong>来判断对应的认证工作。</li></ul></li><li>通过<strong>subject.isAuthenticate</strong>()来判断是否认证成功。</li></ul><h2 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h2><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-aspectj --></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.apache.shiro<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>shiro-aspectj<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>1.3.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="comment"><!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-cas --></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.apache.shiro<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>shiro-cas<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>1.3.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="comment"><!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-core --></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.apache.shiro<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>shiro-core<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>1.3.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="comment"><!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-ehcache --></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.apache.shiro<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>shiro-ehcache<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>1.3.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="comment"><!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-guice --></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.apache.shiro<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>shiro-guice<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>1.3.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="comment"><!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-quartz --></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.apache.shiro<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>shiro-quartz<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>1.3.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="comment"><!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring --></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.apache.shiro<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>shiro-spring<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>1.3.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="comment"><!-- https://mvnrepository.com/artifact/org.apache.shiro.tools/shiro-tools-hasher --></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.apache.shiro.tools<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>shiro-tools-hasher<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>1.3.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="comment"><!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-web --></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.apache.shiro<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>shiro-web<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>1.3.2<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="comment"><!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.slf4j<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>slf4j-log4j12<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>1.7.12<span class="tag"></<span class="name">version</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">scope</span>></span>test<span class="tag"></<span class="name">scope</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="comment"><!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>org.slf4j<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>slf4j-api<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>1.7.21<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>com.mchange<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>c3p0<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>0.9.5.5<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br><span class="line"> <span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">groupId</span>></span>mysql<span class="tag"></<span class="name">groupId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">artifactId</span>></span>mysql-connector-java<span class="tag"></<span class="name">artifactId</span>></span></span><br><span class="line">     <span class="tag"><<span class="name">version</span>></span>5.1.47<span class="tag"></<span class="name">version</span>></span></span><br><span class="line"> <span class="tag"></<span class="name">dependency</span>></span></span><br></pre></td></tr></tbody></table></figure><h1 id="三、JDBCRealm及Authentication-Strategy"><a href="#三、JDBCRealm及Authentication-Strategy" class="headerlink" title="三、JDBCRealm及Authentication Strategy"></a>三、JDBCRealm及Authentication Strategy</h1><p>1、使用shiro框架来完成认证工作，默认情况下使用的是IniRealm。如果需要使用其他Realm，name需要进行相关的配置。</p><p>2、Ini配置文件：</p><p>[main] section是配置应用程序SecurityManager实例及任何它的依赖组件（如Realms）的地方</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[main]</span></span><br><span class="line"><span class="attr">myRealm</span>=cn.sxt.realm.MyRealm</span><br><span class="line"><span class="comment"># 依赖注入</span></span><br><span class="line"><span class="attr">securityManager.reakm</span>=<span class="variable">$myRealm</span></span><br></pre></td></tr></tbody></table></figure><p>[users]section允许定义一组静态的用户账户。在这大部分拥有少数用户账户或用户账户不需要在运行时被动地创建的环境下是很有用的。</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">Zhangsan</span>=<span class="number">1111</span></span><br><span class="line"><span class="attr">Lisi</span>=<span class="number">2222</span>,role1,role2</span><br></pre></td></tr></tbody></table></figure><p>[roles]section允许把定义在[user]section中的角色与权限关联起来。另外，这在大部分拥有少数用户账户或账户或用户账户不需要在运行时被动态地创建的环境下是很有用的。</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">Zhangsan</span>=<span class="number">1111</span></span><br><span class="line"><span class="attr">Lisi</span>=<span class="number">2222</span>,role1,role2</span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="attr">role1</span>=user:add,user:delete</span><br></pre></td></tr></tbody></table></figure><p>3.使用JdbcRealm来完成身份认证</p><p>需要实现JdbcRealm</p><ul><li>需要为JdbcRealm设置dataSource</li><li>在指定的dataSource所对应的数据库中应用表users，该表中有username，password，password_salt等字段</li></ul><p>4.实现步骤：</p><ul><li>新建数据库表</li><li>配置shiro.ini文件</li><li>编写认证</li></ul><p>5.<em>Authentication Strategy</em>：认证策略，在shiro中有三种认证策略；</p><ul><li><em>AtLeastOneSuccessfulStrategy</em>：如果一个（或更多Realm）验证成功，则整体尝试被认为是成功的。如果没有一个成功，则整体尝试失败。</li><li>第一个成功则被认为成功</li><li>所有成功被认为成功</li></ul><h1 id="四、MD5加密"><a href="#四、MD5加密" class="headerlink" title="四、MD5加密"></a>四、MD5加密</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Md5Demo</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">//使用md5加密算法加密</span></span><br><span class="line">        Md5Hash md5 = <span class="keyword">new</span> Md5Hash(<span class="string">"1111"</span>);</span><br><span class="line">        System.out.println(<span class="string">"1111=="</span>+md5.toString());</span><br><span class="line">        <span class="comment">//加盐</span></span><br><span class="line">        md5 = <span class="keyword">new</span> Md5Hash(<span class="string">"1111"</span>, <span class="string">"sxt"</span>);</span><br><span class="line">        System.out.println(<span class="string">"1111=="</span>+md5.toString());</span><br><span class="line">        <span class="comment">//迭代次数</span></span><br><span class="line">        md5 = <span class="keyword">new</span> Md5Hash(<span class="string">"1111"</span>, <span class="string">"sxt"</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"1111=="</span>+md5.toString());</span><br><span class="line">        SimpleHash hash = <span class="keyword">new</span> SimpleHash(<span class="string">"md5"</span>, <span class="string">"1111"</span>, <span class="string">"sxt"</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(hash.toString());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1111</span>==b59c67bf196a4758191e42f76670ceba</span><br><span class="line"><span class="number">1111</span>==<span class="number">96</span>c0335dbdd59d920980f1c6a74ed1b0</span><br><span class="line"><span class="number">1111</span>==e41cd85110c7533e3f93b729b25235c3</span><br><span class="line">e41cd85110c7533e3f93b729b25235c3</span><br></pre></td></tr></tbody></table></figure><h1 id="六、授权"><a href="#六、授权" class="headerlink" title="六、授权"></a>六、授权</h1><p>1、授权：给身份认证通过的人，授予他可以访问某些资源的权限。</p><p>2、权限粒度：分为粗粒度和细粒度。</p><ul><li><p>粗粒度：对user的crud操作。</p></li><li><p>细粒度：对记录的操作。如：值允许查询id为1的user的工资。</p></li><li>shiro一般管理的是粗粒度。如：菜单、按钮、url。一般细粒度的权限是通过业务来管理的。</li></ul><p>3、角色：权限的集合。</p><p>4、权限表示规则：<strong>资源:操作:实例</strong>。可以用通配符表示：</p><ul><li>如：user:add 表示对user有添加的权限。user:* 表示对user具有所有操作的权限</li><li>user:delete:100表示对user标识为100的记录有删除的权限。</li></ul><p>5、shiro中的权限流程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/image-20191230173141540.png" alt="image-20191230173141540" title>                </div>                <div class="image-caption">image-20191230173141540</div>            </figure><h1 id="七、Shiro中的权限检查方式有3种"><a href="#七、Shiro中的权限检查方式有3种" class="headerlink" title="七、Shiro中的权限检查方式有3种"></a>七、Shiro中的权限检查方式有3种</h1><ul><li>编程式</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(subject.hasRole(<span class="string">"管理员"</span>)) {</span><br><span class="line"><span class="comment">//操作某个资源</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注解式</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequireRole</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>{</span><br><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>标签</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><shiro:hasPermission name=<span class="string">"user.update"</span>></span><br><span class="line"><a href="#">更新</a></span><br><span class="line"></shiro:hasPermission></span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="八、授权流程："><a href="#八、授权流程：" class="headerlink" title="八、授权流程："></a>八、授权流程：</h1><ul><li><p>获取subject主体</p></li><li><p>判断主体是否通过认证</p></li><li><p>调用subject.isPermitted*/hasRole*来进行权限的判断</p><ul><li>Subject是由其实现类DelegatingSubject来调用方法的，该类将处理交给了SecurityManager</li><li>SecurityManager是由其实现类DefaultSecurityManager来进行处理，该类的isPermitted来处理，其本质父类AuthorizingSecurityManager来处理的。该类将 处理交给了authorizer（授权器）</li><li>Authorizer由其实现类ModularRealmAuthorizer来处理该类可以调用对应的Realm来获取数据，在该类有PermissionResolver对权限字符串进行解析，在对应的Realm中也有对应的PermissionResolver交给WildcardPermissionResolver该类调用WildcardPermission来进行权限字符串的解析</li><li>返回处理结果</li></ul><h1 id="九、自定义Realm实现授权"><a href="#九、自定义Realm实现授权" class="headerlink" title="九、自定义Realm实现授权"></a>九、自定义Realm实现授权</h1><p>1、仅仅通过配置文件来指定权限不够灵活，并且不方便。在实际的应用中大多数情况下都是将用户信息，角色信息，权限信息保存到了数据库中。所以需要从数据库中去获取相关的数据信息。可以使用shiro提供的JdbcRealm来实现，也可以自定义realm来实现。使用jdbcRealm往往不够灵活，</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h1&gt;&lt;h2 id=&quot;什么是shiro&quot;&gt;&lt;a href=&quot;#什么是shiro&quot; class=&quot;headerlink&quot; title=&quot;什么是shiro&quot;&gt;&lt;/a&gt;什么是shiro&lt;/h2&gt;&lt;p&gt;shiro是基于java的开源的安全管理框架。可以完成认证，授权，会话管理，加密，缓存等功能。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git笔记</title>
    <link href="https://xifujiang.github.io//posts/d9283bc6/"/>
    <id>https://xifujiang.github.io//posts/d9283bc6/</id>
    <published>2019-12-19T01:05:31.891Z</published>
    <updated>2020-01-13T07:06:23.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、git-init搭建仓库"><a href="#一、git-init搭建仓库" class="headerlink" title="一、git init搭建仓库"></a>一、<code>git init</code>搭建仓库</h2><p>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库</p><p>这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><a id="more"></a><h2 id="二、git-add添加"><a href="#二、git-add添加" class="headerlink" title="二、git add添加"></a>二、<code>git add</code>添加</h2><p>所有的版本控制系统，其实只能跟踪文本文件的改动，比如<strong>TXT文件，网页，所有的程序代码</strong>等等。</p><p>把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></tbody></table></figure><h2 id="三、git-commit提交"><a href="#三、git-commit提交" class="headerlink" title="三、git commit提交"></a>三、<code>git commit</code>提交</h2><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m "wrote a readme file"</span><br></pre></td></tr></tbody></table></figure><p><code>git commit</code>命令执行成功后会告诉你：</p><p><code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；</p><p><code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><p>添加文件到Git仓库，分两步：</p><ol><li>使用命令<code>git add <file></code>，注意，可反复多次使用，添加多个文件；</li><li>使用命令<code>git commit -m <message></code>，完成。</li></ol><h2 id="四、git-status查看状态"><a href="#四、git-status查看状态" class="headerlink" title="四、git status查看状态"></a>四、<code>git status</code>查看状态</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add <file>..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- <file>..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></tbody></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><h2 id="五、git-diff查看文件具体修改内容"><a href="#五、git-diff查看文件具体修改内容" class="headerlink" title="五、git diff查看文件具体修改内容"></a>五、<code>git diff</code>查看文件具体修改内容</h2><p>查看某文件修改的具体内容</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></tbody></table></figure><ul><li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li><li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li></ul><h2 id="六、git-log查看日志，历史版本"><a href="#六、git-log查看日志，历史版本" class="headerlink" title="六、git log查看日志，历史版本"></a>六、<code>git log</code>查看日志，历史版本</h2><p>查看修改历史</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master)</span><br><span class="line">Author: Michael Liao <askxuefeng@gmail.com></span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL  //修改名</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao <askxuefeng@gmail.com></span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed //修改名</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao <askxuefeng@gmail.com></span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file //修改名</span><br></pre></td></tr></tbody></table></figure><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></tbody></table></figure><p><code>1094adb7b9b3807259d8cb349e7df1d4d6477073</code>是<code>commit id()</code>版本号，通过SHA1计算。</p><h2 id="七、git-reset-回退版本"><a href="#七、git-reset-回退版本" class="headerlink" title="七、git reset 回退版本"></a>七、<code>git reset</code> 回退版本</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></tbody></table></figure><p>git log 查看版本库的现在状态，发现最新版已经看不到了，已经回退</p><p>如果想回到原来的最新版，办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></tbody></table></figure><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code><strong>指针</strong>，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──> ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></tbody></table></figure><p>改为指向<code>add distributed</code>：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──> ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></tbody></table></figure><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><h2 id="八、git-reflog记录每次命令"><a href="#八、git-reflog记录每次命令" class="headerlink" title="八、git reflog记录每次命令"></a>八、<code>git reflog</code>记录每次命令</h2><p>可以通过这个命令查看历史操作，可以查看<code>commit id</code>，方便</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@{1}: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -> master) HEAD@{2}: commit: append GPL</span><br><span class="line">e475afc HEAD@{3}: commit: add distributed</span><br><span class="line">eaadf4e HEAD@{4}: commit (initial): wrote a readme file</span><br></pre></td></tr></tbody></table></figure><h2 id="九、工作区与暂存区"><a href="#九、工作区与暂存区" class="headerlink" title="九、工作区与暂存区"></a>九、工作区与暂存区</h2><p>工作区（Working Directory）：当前电脑创建的git管理的仓库。</p><p>版本区（Repository）：</p><p>Git的版本库里存了很多东西，其中最重要的就是称为<strong>stage</strong>（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:\blog\myblog\source\_posts\git\1" alt title>                </div>                <div class="image-caption"></div>            </figure><p>分支和<code>HEAD</code>的概念我们以后再讲。</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到<strong>暂存区</strong>；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容<strong>提交到当前分支</strong>。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>简单理解为，<strong>需要提交的文件修改通通放到暂存区</strong>，然后，<strong>一次性提交暂存区的所有修改</strong>。</p><p>修改文件，并<strong>add添加</strong>到暂存区后，状态变为</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:\blog\myblog\source\_posts\git\0" alt="git-stage" title>                </div>                <div class="image-caption">git-stage</div>            </figure><p>commit后，版本库变为下面图，暂存区没有任何内容。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:\blog\myblog\source\_posts\git\2" alt="git-stage-after-commit" title>                </div>                <div class="image-caption">git-stage-after-commit</div>            </figure><h2 id="十、git-checkout丢弃工作区的修改"><a href="#十、git-checkout丢弃工作区的修改" class="headerlink" title="十、git checkout丢弃工作区的修改"></a>十、<code>git checkout</code>丢弃工作区的修改</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></tbody></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在<strong>工作区</strong>的修改全部撤销，这里有两种情况：</p><ul><li><p>一种是<code>readme.txt</code>自修改后还<strong>没有被放到暂存区</strong>，现在，撤销修改就回到和版本库一模一样的状态；</p></li><li><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就<strong>回到添加到暂存区后的状态</strong>。</p></li></ul><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p><strong><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令</strong></p><h2 id="十一、git-reset-HEAD-lt-file-gt-撤销暂存区的内容，重新放回到工作区"><a href="#十一、git-reset-HEAD-lt-file-gt-撤销暂存区的内容，重新放回到工作区" class="headerlink" title="十一、git reset HEAD <file> 撤销暂存区的内容，重新放回到工作区"></a>十一、<code>git reset HEAD <file></code> 撤销暂存区的内容，重新放回到工作区</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Mreadme.txt</span><br></pre></td></tr></tbody></table></figure><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add <file>..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- <file>..." to discard changes in working directory)</span><br></pre></td></tr></tbody></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD <file></code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，<code>git reset xxxx</code>，不过前提是没有推送到远程库。</p><h2 id="十二、删除文件的解决办法。"><a href="#十二、删除文件的解决办法。" class="headerlink" title="十二、删除文件的解决办法。"></a>十二、删除文件的解决办法。</h2><p>如果先添加一个文件，并提交，然后把该文件给删了。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line">$ git commit -m "add test.txt"</span><br><span class="line">$ rm test.txt</span><br></pre></td></tr></tbody></table></figure><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add/rm <file>..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- <file>..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">deleted:    test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></tbody></table></figure><p>现在你有两个选择，1、一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rm test.txt</span><br><span class="line">$ git commit -m "remove test.txt"</span><br></pre></td></tr></tbody></table></figure><p>现在，文件就从版本库中被删除了。</p><p>2、另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></tbody></table></figure><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><h2 id="十三、设置SSH-Key"><a href="#十三、设置SSH-Key" class="headerlink" title="十三、设置SSH Key"></a>十三、设置SSH Key</h2><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C "youremail@example.com"</span><br></pre></td></tr></tbody></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p><p>点“Add Key”，你就应该看到已经添加的Key：</p><h2 id="十四、添加远程库"><a href="#十四、添加远程库" class="headerlink" title="十四、添加远程库"></a>十四、添加远程库</h2><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:xifujiang/learngit.git</span><br></pre></td></tr></tbody></table></figure><p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git push -u origin master</span><br></pre></td></tr></tbody></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，<strong>在以后的推送或者拉取时就可以简化命令</strong>。</p><p>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></tbody></table></figure><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改。</p><h2 id="十五、克隆地址"><a href="#十五、克隆地址" class="headerlink" title="十五、克隆地址"></a>十五、克隆地址</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 地址</span><br></pre></td></tr></tbody></table></figure><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p><p>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>Git鼓励大量使用分支：</p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch <name></code></p><p>切换分支：<code>git checkout <name></code>或者<code>git switch <name></code></p><p>创建+切换分支：<code>git checkout -b <name></code>或者<code>git switch -c <name></code></p><p>合并某分支到当前分支：<code>git merge <name></code></p><p>删除分支：<code>git branch -d <name></code></p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git push origin master</span><br></pre></td></tr></tbody></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git push origin dev</span><br></pre></td></tr></tbody></table></figure><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin <branch-name></code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin <branch-name></code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to <branch-name> origin/<branch-name></code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><ul><li>查看远程库信息，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、git-init搭建仓库&quot;&gt;&lt;a href=&quot;#一、git-init搭建仓库&quot; class=&quot;headerlink&quot; title=&quot;一、git init搭建仓库&quot;&gt;&lt;/a&gt;一、&lt;code&gt;git init&lt;/code&gt;搭建仓库&lt;/h2&gt;&lt;p&gt;通过&lt;code&gt;git init&lt;/code&gt;命令把这个目录变成Git可以管理的仓库&lt;/p&gt;
&lt;p&gt;这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java包名</title>
    <link href="https://xifujiang.github.io//posts/c38d43d9/"/>
    <id>https://xifujiang.github.io//posts/c38d43d9/</id>
    <published>2019-12-05T02:16:00.000Z</published>
    <updated>2020-01-13T07:06:23.586Z</updated>
    
    <content type="html"><![CDATA[<p>Java Bean、POJO、 Entity、 VO ， 其实都是java 对象，只不过用于不同场合罢了。</p><p>按照 Spring MVC 分层结构：</p><p>JavaBean: 表示层 （Presentation Layer）</p><p>Entity： 业务层 （Service layer）</p><p>Dao： 数据访问层 （data access layer）。</p><a id="more"></a><p>Entity接近原始数据，Model接近业务对象～<br>Entity：是专用于EF的对数据库表的操作，<br>Model：是为页面提供数据和数据校验的，所以两者可以并存<br>POJO：POJO是Plain OrdinaryJava Object的缩写不错，但是它通指没有使用Entity Beans的普通java对象，可以把POJO作为支持业务逻辑的协助类。<br>domain：domain这个包国外很多项目经常用到，字面意思是域的意思。</p><p>POJO实质上可以理解为简单的实体类，顾名思义POJO类的作用是方便 程序员使用数据库中的数据表，对于广大的程序员，可以很方便的将POJO类当做对象来进行使用，当然也是可以方便的调用其get,set方法。</p><p>　- JavaBean: 先说JavaBean，JavaBean更多的是一种规范，也即包含一组set和get方法的Java对象。</p><p>　- POJO: 普通的Java对象，对于属性一般实现了JavaBean的标准，另外还可以包含一些简单的业务逻辑(方法)。</p><p>　- PO: POJO在持久层的体现，对POJO持久化后就成了PO。PO更多的是跟数据库设计层面相关，一般PO与数据表对应，一个PO就是对应数据表的一条记录。</p><p>　- DAO: PO持久化到数据库是要进行相关的数据库操作的(CRUQ)，这些对数据库操作的方法会统一放到一个Java对象中，这就是DAO。<br>　- BO: POJO在业务层的体现，对于业务操作来说，更多的是从业务上来包装对象，如一个User的BO，可能包括name, age, sex, privilege, group等，这些属性在数据库中可能会在多张表中，因为每一张表对应一个PO，而我们的BO需要这些PO组合起来(或说重新拼装)才能成为业务上的一个完整对象。</p><p>　- VO(Value Object/View Object): POJO在表现层的体现。 当我们处理完数据时，需要展现时，这时传递到表现层的POJO就成了VO。它就是为了展现数据时用的。</p><p>　- DTO(Data Transfer Object): POJO在系统间传递时。当我们需要在两个系统间传递数据时，一种方式就是将POJO序列化后传递，这个传递状态的POJO就是DTO。</p><p>　- EJB(Enterprise JavaBean): 我认为它是一组”功能”JavaBean的集合。上面说了JavaBean是实现了一种规范的Java对象。这里说EJB是一组JavaBean，的意思是这一组JavaBean组合起来实现了某个企业组的业务逻辑。这里的一组JavaBean不是乱组合的，它们要满足能实现某项业务功能的搭配。找个比方，对于一身穿着来说，包括一顶帽子，一件衣服，一条裤子，两只鞋,这穿着就是EJB.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java Bean、POJO、 Entity、 VO ， 其实都是java 对象，只不过用于不同场合罢了。&lt;/p&gt;
&lt;p&gt;按照 Spring MVC 分层结构：&lt;/p&gt;
&lt;p&gt;JavaBean: 表示层 （Presentation Layer）&lt;/p&gt;
&lt;p&gt;Entity： 业务层 （Service layer）&lt;/p&gt;
&lt;p&gt;Dao： 数据访问层 （data access layer）。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xifujiang.github.io//posts/0/"/>
    <id>https://xifujiang.github.io//posts/0/</id>
    <published>2019-12-02T02:19:25.299Z</published>
    <updated>2020-01-13T07:06:23.613Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、线程"><a href="#1、线程" class="headerlink" title="1、线程"></a>1、线程</h1><h2 id="1、线程的类别"><a href="#1、线程的类别" class="headerlink" title="1、线程的类别"></a>1、线程的类别</h2><ul><li><p>Thread（类）、Runable、Callable、Future，后面三个都是接口。</p></li><li><p>Runable有个无返回值的run的抽象方法，使用时可通过实现类重写run方法，使用Thread封装实现类，然后运行。</p></li><li><p>Callable有一个有返回值V的<strong>call</strong>方法，并抛出Exception异常。使用时做Callable的实现类，使用FutureTask类做封装，再用Thread类对FutureTask做封装，运行</p><a id="more"></a></li><li><p>FutureTask继承RunableFuture，RunableFuture实现Runable和Callable</p></li><li><p>Thread的构造方法有对Runable的参数，重载的方法还有（Runable r, String name）</p></li></ul><h2 id="2、线程池，创建方式"><a href="#2、线程池，创建方式" class="headerlink" title="2、线程池，创建方式"></a>2、线程池，创建方式</h2><ul><li><p>创建大小不固定的线程池：类实现Runable，重写run方法</p></li><li><p>1、创建大小不固定的线程池：主函数创建线程池的方式，具有<strong>缓冲功能</strong>的线程池，系统根据需要创建线程，线程会被缓冲到线程池中，如果<strong>线程池大小超过了处理任务所需要的线程</strong>，线程池就会回收空闲的线程池，当处理任务增加时，线程池可以<strong>增加线程来处理任务</strong>，线程池<strong>不会对线程的大小进行限制</strong>，线程池的大小<strong>依赖于操作系统</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es=Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">ThreadChi tc=<span class="keyword">new</span> ThreadChi();</span><br><span class="line">    es.execute(tc);</span><br><span class="line">}</span><br><span class="line">es.shutdown();</span><br></pre></td></tr></tbody></table></figure></li><li><p>2、<strong>创建固定数量线程的线程池</strong>：创建具一个可重用的，有固定 数量的线程池，每次提交一个任务就提交一个线程，直到线程达到线程池大小，就不会创建新线程了，线程池的大小达到最大后达到稳定不变，如果一个线程</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es=Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">ThreadChi tc=<span class="keyword">new</span> ThreadChi();</span><br><span class="line">es.execute(tc);</span><br><span class="line">}</span><br><span class="line">es.shutdown();</span><br></pre></td></tr></tbody></table></figure></li><li><p>3、创建单线程的线程池</p><p>创建只有一个线程的线程池，按照提交顺序执行，跟上个数量为1的是一样</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es=Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">    ThreadChi tc=<span class="keyword">new</span> ThreadChi();</span><br><span class="line">    es.execute(tc);</span><br><span class="line">}</span><br><span class="line">es.shutdown();</span><br></pre></td></tr></tbody></table></figure></li><li><p>4、创建实时线程</p><p>创建一个线程池，大小可以设置，此线程支持定时以及周期性的执行任务 ,定时任务</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService es=Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">ThreadChi tc=<span class="keyword">new</span> ThreadChi();</span><br><span class="line"><span class="comment">//参数1：目标对象 </span></span><br><span class="line"><span class="comment">//参数2：隔多长时间开始执行线程    </span></span><br><span class="line"><span class="comment">//参数3：执行周期</span></span><br><span class="line"><span class="comment">//参数4：时间单位</span></span><br><span class="line">es.scheduleAtFixedRate(tc, <span class="number">3</span>, <span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="3、Spring线程池可以设置哪些参数"><a href="#3、Spring线程池可以设置哪些参数" class="headerlink" title="3、Spring线程池可以设置哪些参数"></a>3、Spring线程池可以设置哪些参数</h2><h3 id="一、ThreadPoolExecutor的重要参数"><a href="#一、ThreadPoolExecutor的重要参数" class="headerlink" title="一、ThreadPoolExecutor的重要参数"></a>一、ThreadPoolExecutor的重要参数</h3><p>1、corePoolSize：<strong>核心线程数</strong><br>        <strong>核心线程会一直存活</strong>，及时没有任务需要执行<br>        当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理<br>        设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭</p><p>​    2、queueCapacity：<strong>任务队列容量（阻塞队列）</strong><br>​        当核心线程数达到最大时，新任务会放在队列中排队等待执行</p><p>​    3、maxPoolSize：<strong>最大线程数</strong><br>​        当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务<br>​        当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常</p><p>​    4、 keepAliveTime：<strong>线程空闲时间</strong><br>​        当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize<br>​        如果allowCoreThreadTimeout=true，则会直到线程数量=0</p><p>​    5、allowCoreThreadTimeout：<strong>允许核心线程超时</strong><br>​    6、rejectedExecutionHandler：<strong>任务拒绝处理器</strong><br>​        两种情况会拒绝处理任务：<br>​            - 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务<br>​            - 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务<br>​        线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常<br>​        ThreadPoolExecutor类有几个内部实现类来处理这类情况：<br>​            - AbortPolicy 丢弃任务，抛运行时异常<br>​            - CallerRunsPolicy 执行任务<br>​            - DiscardPolicy 忽视，什么都不会发生<br>​            - DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务<br>​        实现RejectedExecutionHandler接口，可自定义处理器</p><h3 id="二、ThreadPoolExecutor执行顺序"><a href="#二、ThreadPoolExecutor执行顺序" class="headerlink" title="二、ThreadPoolExecutor执行顺序"></a>二、ThreadPoolExecutor执行顺序</h3><p><strong>线程池按以下行为执行任务</strong></p><pre><code>1. 当线程数**小于**核心线程数时，**创建线程**。    2. 当线程数**大于等于**核心线程数，且**任务队列未满时，将任务放入任务队列**。    3. 当线程数**大于等于**核心线程数，且**任务队列已满**    \- 若线程数**小于最大线程数**，创建**线程**    \- 若线程数**等于最大线程数**，抛出**异常，拒绝任务**</code></pre><h3 id="三、如何设置参数"><a href="#三、如何设置参数" class="headerlink" title="三、如何设置参数"></a>三、如何设置参数</h3><p>​    1、默认值<br>​        * corePoolSize=1<br>​        * queueCapacity=Integer.MAX_VALUE<br>​        * maxPoolSize=Integer.MAX_VALUE<br>​        * keepAliveTime=60s<br>​        * allowCoreThreadTimeout=false<br>​        * rejectedExecutionHandler=AbortPolicy()</p><p>​    2、如何来设置<br>​        * 需要根据几个值来决定<br>​            - tasks ：每秒的任务数，假设为500~1000<br>​            - taskcost：每个任务花费时间，假设为0.1s<br>​            - responsetime：系统允许容忍的最大响应时间，假设为1s<br>​        * 做几个计算<br>​            - corePoolSize = 每秒需要多少个线程处理？<br>​                * threadcount = tasks/(1/taskcost) =tasks<em>taskcout =  (500~1000)</em>0.1 = 50~100 个线程。corePoolSize设置应该大于50<br>​                * 根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可<br>​            - queueCapacity = (coreSizePool/taskcost)<em>responsetime<br>​                \</em> 计算可得 queueCapacity = 80/0.1<em>1 = 800。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行<br>​                \</em> 切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。<br>​            - maxPoolSize = (max(tasks)- queueCapacity)/(1/taskcost)<br>​                * 计算可得 maxPoolSize = (1000-800)/10 = 20<br>​                * （最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数<br>​            - rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理<br>​            - keepAliveTime和allowCoreThreadTimeout采用默认通常能满足</p><p>​    3、 以上都是理想值，实际情况下要根据机器性能来决定。如果在未达到最大线程数的情况机器cpu load已经满了，则需要通过升级硬件（呵呵）和优化代码，降低taskcost来处理。</p><h2 id="4、临界区，事件，信号量，互斥量"><a href="#4、临界区，事件，信号量，互斥量" class="headerlink" title="4、临界区，事件，信号量，互斥量"></a>4、临界区，事件，信号量，互斥量</h2><p>1、临界区:通过<strong>对多线程的串行化</strong>来<strong>访问公共资源</strong>或<strong>一段代码</strong>，速度快，适合控制数据访问。<br>2、互斥量:为协调共同<strong>对一个共享资源的单独访问</strong>而设计的。<br>3、信号量:为控制一个具有<strong>有限数量用户资源</strong>而设计。<br>4、事件:用来<strong>通知</strong>线程有一些事件已发生，从而启动后继任务的开始。</p><h2 id="5、锁优化（死锁、同步锁、异步锁、释放锁）"><a href="#5、锁优化（死锁、同步锁、异步锁、释放锁）" class="headerlink" title="5、锁优化（死锁、同步锁、异步锁、释放锁）"></a>5、锁优化（死锁、同步锁、异步锁、释放锁）</h2><p>1、线程同步：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是指多个线程通过特定的设置（如互斥量、事件对象、临界区）来控制线程之间的执行顺序。这里的同步不是同时进行。</span><br><span class="line">也就是说，线程之间通过同步建立起执行顺序的关系，如果没有同步，那线程之间是各自运行各自的！</span><br><span class="line">进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。</span><br><span class="line">其中并发又有伪并发和真并发，伪并发是指单核处理器的并发，真并发是指多核处理器的并发。</span><br></pre></td></tr></tbody></table></figure><p> 2、线程异步：</p><pre><code>异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立，在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。异步和多线程并不是一个同等关系，异步是最终目的，多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。</code></pre><p>3、线程互斥：</p><pre><code>是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。 线程互斥可以看成是一种特殊的线程同步。</code></pre><p>二、死锁<br>1、定义</p><p>两个或两个以上的线程均持有对方不会释放的资源，在相互请求这些不释放的资源而处于一种永久的等待状态。</p><p>一句话描述：多个并发线程因争夺（互斥）资源而产生相互等待的现象。</p><p>2、典型的两种死锁的情形：</p><p>(1)线程自己锁住自己：<br>       一般情况下，如果一个线程先后调用两次lock()，由于锁已经被占用，该线程会一直挂起等待占有锁的线程释放锁，然而锁正是被自己占用，该线程又被挂起而没机会释放锁。因此，就永远处于挂起状态了，于是就形成了死锁。<br>(2)多线程抢夺资源被困<br>       线程1锁住了A，接着尝试对B进行加锁，同时线程2已经锁住了B，又尝试着对A加锁。为了得到彼此的资源A和B，线程1和线程2将永远的阻塞下去，这样就发生了死锁。</p><p>3、死锁的产生四个必要条件：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">互斥条件：资源不能被共享，具有排它性，即一个资源只能被一个线程占用，直到被改线程释放。</span><br><span class="line">请求与保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</span><br><span class="line">非剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用。</span><br><span class="line">循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。</span><br></pre></td></tr></tbody></table></figure><h1 id="2、JVM与Java底层"><a href="#2、JVM与Java底层" class="headerlink" title="2、JVM与Java底层"></a>2、JVM与Java底层</h1><h2 id="0、内存机制"><a href="#0、内存机制" class="headerlink" title="0、内存机制"></a>0、内存机制</h2><p>程序计数器</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">较小的内存空间，线程所执行的字节码的行号指示器，线程私有</span><br><span class="line">Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。每个线程都有一个独立的程序计数器。</span><br><span class="line">1、如果执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址</span><br><span class="line">2、如果正在执行的是Native方法，这个计数器值则为空。</span><br></pre></td></tr></tbody></table></figure><p>Java虚拟机栈</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程私有的，生命周期与线程相同。</span><br><span class="line">虚拟机栈描述的是Java方法执行的内存模型。</span><br><span class="line">每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</span><br><span class="line">通常我们讲的栈就是局部变量表部分。</span><br><span class="line">局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char.....）、对象引用（reference类型）、returnArrdress类型（指向了一条字节码指令的地址）</span><br></pre></td></tr></tbody></table></figure><p>本地方法栈</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本地方法栈则为虚拟机使用到的Native方法服务。</span><br><span class="line">本地方法栈区域也会抛出StackOverflowError的OutOfMemoryError异常</span><br></pre></td></tr></tbody></table></figure><p>Java堆</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是JVM所管理的内存最大的一块。</span><br><span class="line">唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</span><br><span class="line">java堆是垃圾收集器管理的主要区域，有时候也称为GC堆</span><br><span class="line">Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</span><br><span class="line">如果在堆中没有完成实例分配，并且堆也无法再扩展时。会抛出OutOfMemoryError异常</span><br></pre></td></tr></tbody></table></figure><p>方法区</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法区是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</span><br><span class="line">方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</span><br><span class="line">运行时常量池是方法区的一部分，</span><br></pre></td></tr></tbody></table></figure><h2 id="1、new-Integer-和Integer-valueOf"><a href="#1、new-Integer-和Integer-valueOf" class="headerlink" title="1、new Integer()和Integer.valueOf()"></a>1、new Integer()和Integer.valueOf()</h2><p>new Interger()</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Interger引用类型变量a中储存在堆中开辟的空间的地址，地址中储存100</span></span><br><span class="line"> Integer a=<span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br></pre></td></tr></tbody></table></figure><p>Interger.valueOf</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接调用Interger的属性valueOf,将int类型的10，隐式加包为Interger类型的10</span></span><br><span class="line"><span class="comment">//再将转化后的10储存在Interger引用类型变量a中</span></span><br><span class="line">Integer a=Integer.valueOf(<span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure><p>两者的区别</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a=<span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer b=<span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer c=Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">Integer d=Integer.valueOf(<span class="number">100</span>);</span><br><span class="line">System.out.println(a==b);  <span class="comment">//false</span></span><br><span class="line">System.out.println(c==d);  <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure><p>a,b只是储存了一个地址，100在堆中的储存地址，因此a,b进行比较输出结果肯定为false。<br>c,d中储存的是通过Interger.valueOf隐式加包后的100，c,d中储存的类型相同值也相同两者进行比较输出结果肯定为true。</p><h2 id="2、String用-拼接字符串"><a href="#2、String用-拼接字符串" class="headerlink" title="2、String用+拼接字符串"></a>2、String用+拼接字符串</h2><p>String每用+拼接一次，每次都会新建一次StringBuilder，会<strong>减慢效率</strong>。</p><p>StringBuilder的append，只会创建一次StringBuilder。</p><h2 id="3、JVM内存模型，五大区域可能产生的异常"><a href="#3、JVM内存模型，五大区域可能产生的异常" class="headerlink" title="3、JVM内存模型，五大区域可能产生的异常"></a>3、JVM内存模型，五大区域可能产生的异常</h2><h3 id="JVM内存区域划分"><a href="#JVM内存区域划分" class="headerlink" title="JVM内存区域划分"></a>JVM内存区域划分</h3><p>Java虚拟机内存区域可以分为两部分：线程私有区域，线程共享区域。</p><p><strong>线程私有区域</strong><br>1.程序计数器</p><blockquote><p>程序计数器,记录当前正在执行的字节码的地址，通俗而言就是记录当前执行到的的字节码的行号，如果当前正在执行的是一个本地方法的话，该值为空（Undifined）</p></blockquote><p>程序计数器的作用</p><blockquote><p>Java虚拟机的多线程是通过轮流切换CPU时间片的方式来实现的，任意时刻，一个单核处理器只能执行一个线程中的指令。为了在发生线程切换后，CPU能从正确的位置继续执行，因此需要程序计数器。程序计数器只能记录所在线程的执行行号，每个线程都有属于自己的程序计数器，因此属于线程私有的。</p></blockquote><p>可能的异常或者错误</p><blockquote><p>因为程序计数器只记录字节码的行号，因此所占内存空间特别小，不会发生OOM和StackOverflow。（也是唯一一块不会抛出OOM的内存区域）。</p></blockquote><p>2.Java虚拟机栈</p><blockquote><p>Java虚拟机栈，描述Java方法执行的内存模型，方法调用时，都会创建一个栈帧，<strong>栈帧中存储方法的局部变量表，操作数栈，动态链接，方法出口等信息</strong>。每一个方法从调用过程，就对应一个栈帧在虚拟机栈中入栈和出栈的过程。</p></blockquote><p>局部变量表</p><blockquote><p>局部变量表存储编译器可知的数据类型（8大基本数据类型和对象引用），因为Java是一门跨平台的语言，因此这些数据类型的大小在编译器间就是已知的，因此局部变量表的内存空间在编译期间就已经分配完毕，且在运行期间不会再改变。</p></blockquote><p>可能的异常或者错误</p><blockquote><p>当方法调用的栈深度超过虚拟机运行的栈深度时（没有出口的方法递归调用），就会抛出StackOverflow错误。一般而言栈的深度是可以扩展的，当扩展时无法再申请到内存时就会抛出OutOfMemroy错误。那么到底抛出哪个错误呢？在单线程情况下抛出Stackoverflow，多线程下抛出OOM。</p></blockquote><p>3.本地方法栈</p><blockquote><p>本地方法栈的作用与Java虚拟机栈的作用基本是一致的只是，本地方法栈上执行的是Native方法，而虚拟机栈上执行的是Java方法而言。而且堆本地方法栈的使用并没有严格规定，因此有的虚拟机直接将两部分合二为一。</p></blockquote><p>可能的异常或者错误</p><blockquote><p>与虚拟机栈一样该区域也可能抛出StackOverflow和OOM，且原因和本地方法栈是一样的。</p></blockquote><p>线程共享区域<br>1.Java堆</p><blockquote><p>Java堆在虚拟机启动时创建，是Java虚拟机管理的内存的最大的一块。Java堆是垃圾回收器管理的主要区域，因此也成为GC堆。Java堆上存放对象实例数据和数组，但并非所有的对象实例和数组都在堆上分配。Java堆在逻辑上是连续的，在物理地址上一般是不连续的。</p></blockquote><p>可能的异常或者错误</p><blockquote><p>当堆中的对象所占内存达到最大值，这时候再创建新对象就会抛出OOM。堆可以通过-Xmx和-Xms来控制相应的大小。</p></blockquote><p>2.方法区</p><blockquote><p>方法区也是各个线程共享的区域，该区域主要存放加载的类信息，常量，静态变量，编译后的代码等。方法区也成为永久代，在JDK8更名为元空间。</p></blockquote><blockquote><p>永久代并不意味着数据进入方法区就永久存在，此区域的内存回收主要是针对常量池的回收以及对类型的卸载，其中对类型的卸载条件要苛刻很多。</p></blockquote><p>可能的异常或者错误</p><blockquote><p>当方法区无法满足内存需求时就会抛出OOM错误。</p></blockquote><p>3.运行时常量池（方法区的一部分）</p><blockquote><p>运行时常量池也是线程共享的内存区域，该区域保存字面量和符号引用。</p></blockquote><p>字面常量：</p><blockquote><p>字符串(如 “abc”)<br>final修饰的变量（final int a = 10;）<br>基本类型的值等信息(10,true,null等)。<br>符号引用：</p></blockquote><blockquote><p>类和接口的全限定名；<br>字段即属性的名称和描述符<br>方法的名称和描述符<br>可能抛出的错误</p></blockquote><blockquote><p>运行时常量池是是方法区的一部分，因此在无法满足内存需求时，也会抛出OOM。</p></blockquote><h2 id="4、关于内存溢出产生的死循环"><a href="#4、关于内存溢出产生的死循环" class="headerlink" title="4、关于内存溢出产生的死循环"></a>4、关于内存溢出产生的死循环</h2><p>数组越界</p><p>while循环等</p><h2 id="5、gc-垃圾回收机制-线程，优先级"><a href="#5、gc-垃圾回收机制-线程，优先级" class="headerlink" title="5、gc()垃圾回收机制 线程，优先级"></a>5、gc()垃圾回收机制 线程，优先级</h2><h2 id="6、Java中的运算符有哪些"><a href="#6、Java中的运算符有哪些" class="headerlink" title="6、Java中的运算符有哪些"></a>6、Java中的运算符有哪些</h2><h2 id="7、String-intern"><a href="#7、String-intern" class="headerlink" title="7、String.intern()"></a>7、String.intern()</h2><p>源码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>返回字符串对象的规范化表示形式。</p><p>一个初始时为空的字符串池，它由类 String 私有地维护。</p><p>当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。</p><p>所有字面值字符串和字符串赋值常量表达式都是内部的。</p><p>返回：</p><p>一个字符串，内容与此字符串相同，但它保证来自字符串池中。</p><h2 id="8、程序中有哪些地方保存数据"><a href="#8、程序中有哪些地方保存数据" class="headerlink" title="8、程序中有哪些地方保存数据"></a>8、程序中有哪些地方保存数据</h2><p><strong>寄存器</strong></p><p>这是最快的保存区域，因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。</p><p><strong>堆栈</strong></p><p>驻留于常规RAM（随机访问存储器）区域，但可通过它的“堆栈指针”获得处理的直接支持。堆栈指针若向下移，会创建新的内存；若向上移，则会释放那些内存。这是一种特别快、特别有效的数据保存方式，仅次于寄存器。创建程序时，Java编译器必须准确地知道堆栈内保存的所有数据的“长度”以及“存在时间”。这是由于它必须生成相应的代码，以便向上和向下移动指针。这一限制无疑影响了程序的灵活性，所以尽管有些Java 数据要保存在堆栈里——特别是对象句柄，但Java 对象并不放到其中。</p><p><strong>堆</strong></p><p>一种常规用途的内存池（也在RAM区域），其中保存了Java对象。和堆栈不同，“内存堆”或“堆”（Heap）最吸引人的地方在于编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间。因此，用堆保存数据时会得到更大的灵活性。要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存。当然，为达到这种灵活性，必然会付出一定的代价：在堆里分配存储空间时会花掉更长的时间！</p><p><strong>静态存储</strong></p><p>这儿的“静态”（Static）是指“位于固定位置”（尽管也在RAM里）。程序运行期间，静态存储的数据将随时等候调用。可用static关键字指出一个对象的特定元素是静态的。但Java 对象本身永远都不会置入静态存储空间。</p><p><strong>常数存储</strong></p><p>常数值通常直接置于程序代码内部。这样做是安全的，因为它们永远都不会改变。有的常数需要严格地保护，所以可考虑将它们置入只读存储器（ROM）。</p><p><strong>非RAM 存储</strong></p><p>若数据完全独立于一个程序之外，则程序不运行时仍可存在，并在程序的控制范围之外。其中两个最主要的例子便是“流式对象”和“固定对象”。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复成普通的、基于RAM 的对象。Java 1.1 提供了对Lightweight persistence 的支持。未来的版本甚至可能提供更完整的方案。</p><h2 id="9、jdk动态代理"><a href="#9、jdk动态代理" class="headerlink" title="9、jdk动态代理"></a>9、jdk动态代理</h2><p>JDK动态代理是代理模式的一种实现方式，其只能代理接口。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">　　<span class="comment">/*</span></span><br><span class="line"><span class="comment">　　使用JDK动态代理，创建代理对象</span></span><br><span class="line"><span class="comment">　　参数1：类加载器</span></span><br><span class="line"><span class="comment">　　参数2：所有实现的接口</span></span><br><span class="line"><span class="comment">　　参数3：方法调用的接口，Star接口中每个方法都会调用一次</span></span><br><span class="line"><span class="comment">　　*/</span></span><br><span class="line">　　Star s2 = (Star) Proxy.newProxyInstance(</span><br><span class="line">　　　　s1.getClass().getClassLoader(),</span><br><span class="line">　　　　<span class="keyword">new</span> Class[]{Star.class},</span><br><span class="line">　　<span class="keyword">new</span> InvocationHandler() {</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对每个方法进行功能增强</span></span><br><span class="line"><span class="comment">参数1：代理对象，不能直接调用，不然出现递归</span></span><br><span class="line"><span class="comment">参数2：每个方法对象，如：sing() act()，每个方法都会调用一次</span></span><br><span class="line"><span class="comment">参数3：方法传递的参数，如：歌名</span></span><br><span class="line"><span class="comment">返回值：调用的方法的返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">　　<span class="comment">//如果是演出的方法，判断是否小于1000，如果小于则不演出，否则调用原来的方法</span></span><br><span class="line">　　String methodName = method.getName();</span><br><span class="line">　　<span class="keyword">if</span> (<span class="string">"act"</span>.equals(methodName)) {</span><br><span class="line">　　<span class="comment">//得到演示参数值</span></span><br><span class="line">　　<span class="keyword">int</span> money = (<span class="keyword">int</span>) args[<span class="number">0</span>];</span><br><span class="line">　　<span class="keyword">if</span> (money < <span class="number">1000</span>) {</span><br><span class="line">　　　　System.out.println(<span class="string">"费用太低，不演出了"</span>);</span><br><span class="line">　　<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">　　}</span><br><span class="line">}</span><br><span class="line">　　<span class="comment">//其它的情况就调用真实对象原来的方法</span></span><br><span class="line">　　<span class="keyword">return</span> method.invoke(s1, args); <span class="comment">//真实对象，方法的参数</span></span><br><span class="line">　　}</span><br><span class="line">});</span><br><span class="line">   </span><br><span class="line">　　<span class="comment">//fans请自己喜欢的明星出场唱歌，拍戏</span></span><br><span class="line">　　s2.sing(<span class="string">"只因你太美"</span>);</span><br><span class="line">　　<span class="comment">//费用过低不满足</span></span><br><span class="line">　　s2.act(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">　　}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="10、反射机制"><a href="#10、反射机制" class="headerlink" title="10、反射机制"></a>10、反射机制</h2><h2 id="11、IO"><a href="#11、IO" class="headerlink" title="11、IO"></a>11、IO</h2><h2 id="12、lang包"><a href="#12、lang包" class="headerlink" title="12、lang包"></a>12、lang包</h2><h2 id="13、StringBuffer和StringBuilder"><a href="#13、StringBuffer和StringBuilder" class="headerlink" title="13、StringBuffer和StringBuilder"></a>13、StringBuffer和StringBuilder</h2><h2 id="14、运行报错和编译报错"><a href="#14、运行报错和编译报错" class="headerlink" title="14、运行报错和编译报错"></a>14、运行报错和编译报错</h2><h2 id="15、内存泄露与内存溢出"><a href="#15、内存泄露与内存溢出" class="headerlink" title="15、内存泄露与内存溢出"></a>15、内存泄露与内存溢出</h2><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达的路径来避免垃圾回收机制清楚这些对象。</p><p>内存泄漏：强引用所指向的对象不会被回收，可能导致内存泄漏，虚拟机宁愿抛出OOM也不会去回收他指向的对象</p><p>内存泄露：系统已经不能再分配出你所需要的空间，比如你需要100M的空间，系统只剩90M了，这就叫内存溢出</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h2 id="九大内置对象"><a href="#九大内置对象" class="headerlink" title="九大内置对象"></a>九大内置对象</h2><h2 id="等价类划分"><a href="#等价类划分" class="headerlink" title="等价类划分"></a>等价类划分</h2><h2 id="三大集合"><a href="#三大集合" class="headerlink" title="三大集合"></a>三大集合</h2><h2 id="八大基本数据类型"><a href="#八大基本数据类型" class="headerlink" title="八大基本数据类型"></a>八大基本数据类型</h2><h1 id="3、继承与实现"><a href="#3、继承与实现" class="headerlink" title="3、继承与实现"></a>3、继承与实现</h1><h2 id="1、继承是什么"><a href="#1、继承是什么" class="headerlink" title="1、继承是什么"></a>1、继承是什么</h2><h2 id="2、接口的作用"><a href="#2、接口的作用" class="headerlink" title="2、接口的作用"></a>2、接口的作用</h2><h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><h2 id="继承与聚合"><a href="#继承与聚合" class="headerlink" title="继承与聚合"></a>继承与聚合</h2><h1 id="4、关键字"><a href="#4、关键字" class="headerlink" title="4、关键字"></a>4、关键字</h1><h2 id="1、final修饰类的特征"><a href="#1、final修饰类的特征" class="headerlink" title="1、final修饰类的特征"></a>1、final修饰类的特征</h2><h2 id="2、static修饰类的特征"><a href="#2、static修饰类的特征" class="headerlink" title="2、static修饰类的特征"></a>2、static修饰类的特征</h2><h2 id="3、Object的一些方法-gt-线程的一些方法"><a href="#3、Object的一些方法-gt-线程的一些方法" class="headerlink" title="3、Object的一些方法 ->线程的一些方法"></a>3、Object的一些方法 ->线程的一些方法</h2><h2 id="4、同步锁可以锁什么-sync"><a href="#4、同步锁可以锁什么-sync" class="headerlink" title="4、同步锁可以锁什么 sync"></a>4、同步锁可以锁什么 sync</h2><h2 id="5、volatile关于jmm内存模型，可保证原子的操作吗"><a href="#5、volatile关于jmm内存模型，可保证原子的操作吗" class="headerlink" title="5、volatile关于jmm内存模型，可保证原子的操作吗"></a>5、volatile关于jmm内存模型，可保证原子的操作吗</h2><h1 id="4、Spring"><a href="#4、Spring" class="headerlink" title="4、Spring"></a>4、Spring</h1><h2 id="1、Spring的理解"><a href="#1、Spring的理解" class="headerlink" title="1、Spring的理解"></a>1、Spring的理解</h2><h2 id="2、-Autwired-和-Resource区别"><a href="#2、-Autwired-和-Resource区别" class="headerlink" title="2、@Autwired 和 @Resource区别"></a>2、@Autwired 和 @Resource区别</h2><h2 id="3、spring注入方式"><a href="#3、spring注入方式" class="headerlink" title="3、spring注入方式"></a>3、spring注入方式</h2><h2 id="4、拦截器和过滤器的底层"><a href="#4、拦截器和过滤器的底层" class="headerlink" title="4、拦截器和过滤器的底层"></a>4、拦截器和过滤器的底层</h2><h2 id="5、bean的作用域问题"><a href="#5、bean的作用域问题" class="headerlink" title="5、bean的作用域问题"></a>5、bean的作用域问题</h2><h2 id="6、编译内核"><a href="#6、编译内核" class="headerlink" title="6、编译内核"></a>6、编译内核</h2><h2 id="7、面向对象和面向切面"><a href="#7、面向对象和面向切面" class="headerlink" title="7、面向对象和面向切面"></a>7、面向对象和面向切面</h2><h2 id="8、mybatis的一对多，多对一，以及多对对的配置和使用"><a href="#8、mybatis的一对多，多对一，以及多对对的配置和使用" class="headerlink" title="8、mybatis的一对多，多对一，以及多对对的配置和使用"></a>8、mybatis的一对多，多对一，以及多对对的配置和使用</h2><h1 id="5、数据库"><a href="#5、数据库" class="headerlink" title="5、数据库"></a>5、数据库</h1><h2 id="1、模糊查询"><a href="#1、模糊查询" class="headerlink" title="1、模糊查询"></a>1、模糊查询</h2><h2 id="2、索引有哪些"><a href="#2、索引有哪些" class="headerlink" title="2、索引有哪些"></a>2、索引有哪些</h2><h1 id="8、前后端值传递"><a href="#8、前后端值传递" class="headerlink" title="8、前后端值传递"></a>8、前后端值传递</h1><h1 id="分布式开发-注意并发"><a href="#分布式开发-注意并发" class="headerlink" title="分布式开发 注意并发"></a>分布式开发 注意并发</h1><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="重定向状态码"><a href="#重定向状态码" class="headerlink" title="重定向状态码"></a>重定向状态码</h2><h2 id="操作系统命令：网络、连接等命令"><a href="#操作系统命令：网络、连接等命令" class="headerlink" title="操作系统命令：网络、连接等命令"></a>操作系统命令：网络、连接等命令</h2><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>客户端向服务器端发送SYN包；服务器端向客户端发送SYN+ACK；客户端回复ACK。</p><h2 id="访问一个网站，浏览器工作的流程"><a href="#访问一个网站，浏览器工作的流程" class="headerlink" title="访问一个网站，浏览器工作的流程"></a>访问一个网站，浏览器工作的流程</h2><h1 id="数据库连接过程"><a href="#数据库连接过程" class="headerlink" title="数据库连接过程"></a>数据库连接过程</h1><p>1、加载驱动</p><p>2、建立连接</p><p>3、写sql语句</p><p>4、创建statement、preparedStatement</p><p>5、ResultSet接收</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、线程&quot;&gt;&lt;a href=&quot;#1、线程&quot; class=&quot;headerlink&quot; title=&quot;1、线程&quot;&gt;&lt;/a&gt;1、线程&lt;/h1&gt;&lt;h2 id=&quot;1、线程的类别&quot;&gt;&lt;a href=&quot;#1、线程的类别&quot; class=&quot;headerlink&quot; title=&quot;1、线程的类别&quot;&gt;&lt;/a&gt;1、线程的类别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Thread（类）、Runable、Callable、Future，后面三个都是接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Runable有个无返回值的run的抽象方法，使用时可通过实现类重写run方法，使用Thread封装实现类，然后运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Callable有一个有返回值V的&lt;strong&gt;call&lt;/strong&gt;方法，并抛出Exception异常。使用时做Callable的实现类，使用FutureTask类做封装，再用Thread类对FutureTask做封装，运行&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebMagic</title>
    <link href="https://xifujiang.github.io//posts/a896d992/"/>
    <id>https://xifujiang.github.io//posts/a896d992/</id>
    <published>2019-12-01T12:04:27.199Z</published>
    <updated>2020-01-13T07:06:23.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、架构介绍"><a href="#1、架构介绍" class="headerlink" title="1、架构介绍"></a>1、架构介绍</h1><h2 id="1-1、四大组件"><a href="#1-1、四大组件" class="headerlink" title="1.1、四大组件"></a>1.1、四大组件</h2><p>WebMagic的结构分为Downloader、PageProcessor、Scheduler、Pipeline四大组件，并由Spider将彼此组织起来。这四大组件对应爬虫声明周期中的下载、处理、管理和持久化等功能。WebMagic的设计参考了Scapy，但是实现方式更Java化一些。</p><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/70" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h2 id="1-2、用于数据流转的对象"><a href="#1-2、用于数据流转的对象" class="headerlink" title="1.2、用于数据流转的对象"></a>1.2、用于数据流转的对象</h2><p>1、Request</p><blockquote><p>request是对url地址的一层封装，一个Request对应一个url地址。</p><p>它是PageProcessor与Downloader交互的载体，也是PageProcessor控制Downloader唯一方式。</p></blockquote><p>2、Page</p><blockquote><p>Page代表了从Downloader下载到的一个页面——可能是HTML，也可能是Json或者其他文本格式的内容。</p><p>Page是WebMagic抽取过程的核心对象，它提供一些方法可供抽取、结果保存等。</p></blockquote><p>3、ResultItems</p><blockquote><p>ResultItems相当于一个Map，它保存PageProcessor处理的结果供Pipeline使用。它的API与Map很类似，值得注意的是它有一个字段skip，若设置为true，则不应被Pipeline处理。</p></blockquote><h1 id="2、实现PageProcessor"><a href="#2、实现PageProcessor" class="headerlink" title="2、实现PageProcessor"></a>2、实现PageProcessor</h1><h2 id="2-1抽取元素Selectable"><a href="#2-1抽取元素Selectable" class="headerlink" title="2.1抽取元素Selectable"></a>2.1抽取元素Selectable</h2><p>webMageic里使用的三种抽取技术：<strong>XPath、正则表达式和CSS选择器</strong>。对于 JSON格式的内容，可使用JsonPath进行解析。</p><h2 id="2-2-抽取元素API"><a href="#2-2-抽取元素API" class="headerlink" title="2.2 抽取元素API"></a>2.2 抽取元素API</h2><p>Selectable相关的抽取元素链式API是WebMagic的一个核心 功能。使用Selectable接口，可以直接完成页面元素的链式抽取，也无需去关心抽取的细节。</p><p>从刚才的例子中可以看到，page.getHtml()返回的是一个Html对象，它实现了Selectable接口。这个接口包含的方法分为两类：抽取部分和获取结果部分。</p><table><thead><tr><th>方法</th><th>说明</th><th></th></tr></thead><tbody><tr><td>xpath(String xpath)</td><td>使用XPath选择</td><td>html.xpath(“//div[@class=’title’]”)</td></tr><tr><td>$(String selector)</td><td>使用Css选择器选择</td><td>html.$(“div.title”)</td></tr><tr><td>$(String selector, String attr)</td><td>使用Css选择器选择</td><td>html.$(“div.title”,”text”)</td></tr><tr><td>css(String selector)</td><td>功能同$(),使用Css选择器选择</td><td>html.css(“div.title”)</td></tr><tr><td>links()</td><td>选择所有链接</td><td>html.links()</td></tr><tr><td>regex(String regex)</td><td>使用正则表达式抽取</td><td>html.regex(“\(.\*?)\“)</td></tr></tbody></table><p>不同API获取一个或多个元素</p><table><thead><tr><th></th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>get()</td><td>返回一条String类型的结果</td><td>String link = html.links().get()</td></tr><tr><td>toString()</td><td>同get()，返回一条String类型的结果</td><td>String link = html.links().toString()</td></tr><tr><td>all()</td><td>返回所有抽取结果</td><td>List links = html.links().all()</td></tr></tbody></table><h1 id="3、实现多页面爬虫流程"><a href="#3、实现多页面爬虫流程" class="headerlink" title="3、实现多页面爬虫流程"></a>3、实现多页面爬虫流程</h1><p><strong>开始-> 列表页面 -> 获取url（url去重） -> url加入任务 ->结束</strong></p><h2 id="3-1-Scheduler组件"><a href="#3-1-Scheduler组件" class="headerlink" title="3.1 Scheduler组件"></a>3.1 Scheduler组件</h2><p>Scheduler是WebMagic中进行URL管理的组件。</p><p>作用：</p><blockquote><p>对待抓取的URL队列进行管理。</p><p>对已抓取的URL进行去重。</p></blockquote><p>WebMagic内置了几个常用的Scheduler。</p><table><thead><tr><th>类</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>DulicateRemovedScheduler</td><td>抽象基类，提供一些模板方法</td><td>继承它可以实现自己的功能</td></tr><tr><td>QueueScheduler</td><td>使用内存队列保存待抓取URL</td><td></td></tr><tr><td>PriorityScheduler</td><td>使用带有优先级的内存队列保存待抓取URL</td><td>耗费内存较QueueScheduler更大，但是当设置request.priority之后，只能使用PriorityScheduler才可使优先级生效</td></tr><tr><td>FileCacheQueueScheduler</td><td>使用文件保存抓取URL，可以在关闭程序并下次启动时，从之前抓取到的URL继续抓取</td><td>需指定路径，会建立.urls.txt和.cursor.txt</td></tr><tr><td>RedisScheduler</td><td>使用R额滴神保存抓取队列，可进行多台机器同时合作抓取</td><td>需要安装并启动redis</td></tr></tbody></table><p>去重部分被单独抽象成一个接口：DuplicateRemover，从而可以为同一个Scheduler选择不同的去重方式，以适应不同的需要，目前提供两种去重方式。</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>HashSetDuplicateRemover</td><td>使用HashSet来进行去重，占用内存较大</td></tr><tr><td>BloomFilterDuplicateRemover</td><td>使用BloomFilter来进行去重，占用内存较小，但是可能漏抓页面</td></tr></tbody></table><h2 id="3-2-三种去重方式"><a href="#3-2-三种去重方式" class="headerlink" title="3.2 三种去重方式"></a>3.2 三种去重方式</h2><ul><li><p><strong>HashSet</strong></p><p>使用Java中的HashSet不能重复的特点去重</p><p>优点：容易理解，使用方便。</p><p>缺点：占用内存大，性能较低。</p></li><li><p><strong>Redis去重</strong></p><p>使用Redis的<strong>set</strong>进行去重。</p><p>优点：速度快（Redis本身速度快），去重不会占有爬虫服务器的资源，可以处理更大数据量的数据爬取</p><p>缺点：需要准备Redis服务器，增加开发和使用成本。</p></li><li><p><strong>布隆过滤器（BloomFilter）</strong></p><p><strong>优点：</strong>占用的内存要比使用HashSet要小的多，也适合大量数据的去重操作。</p><p><strong>缺点：</strong>有误判的可能。没有重复可能会判断重复，但是重复的数据一定会判断重复。</p><p><strong>介绍：</strong></p><p>布隆过滤器是一种space efficient的概率型数据结构，用于判断一个元素是否在集合中。在垃圾邮件过滤黑白名单方法、爬虫（crawler）的网址判重模块中等等经常被用到。</p><p>哈希表也能用于判断元素是否在集合中，但布隆过滤器只需要哈希表的1/8或1.4的空间复杂度就能完成同样的问题。布隆过滤器可以插入元素，但不可以删除已有元素。其中的元素越多，误报率越大，但是漏报是不可能的。</p><p><strong>原理：</strong></p><p>布隆过滤器需要的是位数组（二进制数组），全部赋值为0，对于有n个元素的集合S={S1, S2…Sn}，通过k个映射函数{f1,f2,…..fk}，将集合S中的每个元素Sj（1<=j<=n）映射为k个值{g1,g2,….gk}，然后再将位数组array中相对应的array[g1],array[g2]….array[gk]置为1。</p><p>【注】：网站去重为例，对于一个url列表，一个url可以对应一组kv集合，也就是说可以获得多个v，把得到的v，将对应数组中的数值置为1。若下个网站遇到相同的位置已经是1，则该网站已经出现过，会被去重。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、架构介绍&quot;&gt;&lt;a href=&quot;#1、架构介绍&quot; class=&quot;headerlink&quot; title=&quot;1、架构介绍&quot;&gt;&lt;/a&gt;1、架构介绍&lt;/h1&gt;&lt;h2 id=&quot;1-1、四大组件&quot;&gt;&lt;a href=&quot;#1-1、四大组件&quot; class=&quot;headerlink&quot; title=&quot;1.1、四大组件&quot;&gt;&lt;/a&gt;1.1、四大组件&lt;/h2&gt;&lt;p&gt;WebMagic的结构分为Downloader、PageProcessor、Scheduler、Pipeline四大组件，并由Spider将彼此组织起来。这四大组件对应爬虫声明周期中的下载、处理、管理和持久化等功能。WebMagic的设计参考了Scapy，但是实现方式更Java化一些。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xifujiang.github.io//posts/0/"/>
    <id>https://xifujiang.github.io//posts/0/</id>
    <published>2019-11-21T11:42:01.012Z</published>
    <updated>2020-01-13T07:06:23.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、数据库"><a href="#一、数据库" class="headerlink" title="一、数据库"></a>一、数据库</h1><h2 id="1、left-join-和-inner-join的区别"><a href="#1、left-join-和-inner-join的区别" class="headerlink" title="1、left join 和 inner join的区别"></a>1、left join 和 inner join的区别</h2><a id="more"></a><p>1、举例a、b表：</p><table><thead><tr><th>bId</th><th>bNum</th></tr></thead><tbody><tr><td>1</td><td>20</td></tr><tr><td>2</td><td>30</td></tr></tbody></table><table><thead><tr><th>aId</th><th>aNum</th></tr></thead><tbody><tr><td>1</td><td>10</td></tr><tr><td>2</td><td>20</td></tr><tr><td>3</td><td>30</td></tr></tbody></table><p>left join以左表为准</p><p>select * from a left join b on a.aId=b.bId;</p><table><thead><tr><th>aId</th><th>aNum</th><th>bId</th><th>bNum</th></tr></thead><tbody><tr><td>1</td><td>10</td><td>1</td><td>20</td></tr><tr><td>2</td><td>20</td><td>2</td><td>30</td></tr><tr><td>3</td><td>30</td><td>NULL</td><td>NULL</td></tr></tbody></table><p>inner join 选两张表都有的，一一相等的</p><table><thead><tr><th>aId</th><th>aNum</th><th>bId</th><th>bNum</th></tr></thead><tbody><tr><td>1</td><td>10</td><td>1</td><td>20</td></tr><tr><td>2</td><td>20</td><td>2</td><td>30</td></tr></tbody></table><p><strong>left join 会保留左边表的数据，而inner join是等值连接，必须满足条件才会有数据。</strong> left join的速度比inner join快些。</p><h2 id="2、drop、truncate、delete区别"><a href="#2、drop、truncate、delete区别" class="headerlink" title="2、drop、truncate、delete区别"></a>2、drop、truncate、delete区别</h2><p><strong>最基本：</strong></p><ul><li>drop直接删掉表。</li><li>truncate删除表中数据，再插入时自增长id又从1开始。</li><li>delete删除表中数据，可以加where字句。</li></ul><h2 id="3-触发器的作用？"><a href="#3-触发器的作用？" class="headerlink" title="3.触发器的作用？"></a>3.触发器的作用？</h2><blockquote><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p></blockquote><h2 id="4-什么是存储过程？用什么来调用？"><a href="#4-什么是存储过程？用什么来调用？" class="headerlink" title="4.什么是存储过程？用什么来调用？"></a><strong>4.什么是存储过程？用什么来调用？</strong></h2><blockquote><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说<strong>只需创建一次，以后在该程序中就可以调用多次</strong>。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>调用：</strong></p><p>1）可以用一个命令对象来调用存储过程。</p><p>2）可以供外部程序调用，比如：java程序。</p></blockquote><h2 id="5-什么叫视图？游标是什么？"><a href="#5-什么叫视图？游标是什么？" class="headerlink" title="5.什么叫视图？游标是什么？"></a><strong>5.什么叫视图？游标是什么？</strong></h2><blockquote><p><strong>视图：</strong></p><p>是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p><strong>游标：</strong></p><p>是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是<strong>需要逐条处理数据的时候</strong>，游标显得十分重要。</p></blockquote><h2 id="6-非关系型数据库和关系型数据库区别，优势比较"><a href="#6-非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="6.非关系型数据库和关系型数据库区别，优势比较?"></a><strong>6.非关系型数据库和关系型数据库区别，优势比较?</strong></h2><blockquote><p><strong>非关系型数据库的优势：</strong></p><ul><li><strong>性能：</strong>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li><li><strong>可扩展性：</strong>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ul><p><strong>关系型数据库的优势：</strong></p><ul><li><strong>复杂查询：</strong>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li><strong>事务支持：</strong>使得对于安全性能很高的数据访问要求得以实现。</li></ul></blockquote><h2 id="7、范式"><a href="#7、范式" class="headerlink" title="7、范式"></a>7、范式</h2><p>第一范式：（确保每列保持原子性），所有的字段值都是不可分解的原子值。</p><p>第二范式：（确保表中的每列都和主键相关）在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>第三范式：（确保每列都和主键列直接相关，而不是间接相关）数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><h2 id="8、索引"><a href="#8、索引" class="headerlink" title="8、索引"></a>8、索引</h2><h4 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a><strong>1.什么是索引？</strong></h4><blockquote><p><strong>何为索引：</strong></p><p>数据库索引，是数据库管理系统中一个<strong>排序的数据结构</strong>，索引的实现通常使用<strong>B树及其变种B+树</strong>。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p></blockquote><h4 id="2-索引的作用？它的优点缺点是什么？"><a href="#2-索引的作用？它的优点缺点是什么？" class="headerlink" title="2.索引的作用？它的优点缺点是什么？"></a><strong>2.索引的作用？它的优点缺点是什么？</strong></h4><blockquote><p><strong>索引作用：</strong></p><p>协助快速查询、更新数据库表中数据。</p><p>为表设置索引要付出代价的：</p><ul><li>一是增加了数据库的存储空间</li><li>二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)</li></ul></blockquote><h3 id="3-索引的优缺点？"><a href="#3-索引的优缺点？" class="headerlink" title="3.索引的优缺点？"></a><strong>3.索引的优缺点？</strong></h3><blockquote><p><strong>创建索引可以大大提高系统的性能（优点）：</strong></p><p>1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p><strong>增加索引也有许多不利的方面(缺点)：</strong></p><p>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p></blockquote><h4 id="4-哪些列适合建立索引、哪些不适合建索引？"><a href="#4-哪些列适合建立索引、哪些不适合建索引？" class="headerlink" title="4.哪些列适合建立索引、哪些不适合建索引？"></a><strong>4.哪些列适合建立索引、哪些不适合建索引？</strong></h4><blockquote><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p><p><strong>一般来说，应该在这些列上创建索引：</strong></p><p>（1）在经常需要搜索的列上，可以加快搜索的速度；</p><p>（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p><p>（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p><p>（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p><p>（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p><p>（6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p><strong>对于有些列不应该创建索引：</strong></p><p>（1）对于那些在查询中很少使用或者参考的列不应该创建索引。</p><p>这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>（2）对于那些只有很少数据值的列也不应该增加索引。</p><p>这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>（3）对于那些定义为text, image和bit数据类型的列不应该增加索引。</p><p>这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>(4)当修改性能远远大于检索性能时，不应该创建索引。</p><p>这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p></blockquote><h3 id="5-什么样的字段适合建索引"><a href="#5-什么样的字段适合建索引" class="headerlink" title="5.什么样的字段适合建索引"></a><strong>5.什么样的字段适合建索引</strong></h3><blockquote><p>唯一、不为空、经常被查询的字段</p><h4 id="6-MySQL-B-Tree索引和Hash索引的区别"><a href="#6-MySQL-B-Tree索引和Hash索引的区别" class="headerlink" title="6.MySQL B+Tree索引和Hash索引的区别?"></a><strong>6.MySQL B+Tree索引和Hash索引的区别?</strong></h4><p><strong>Hash索引和B+树索引的特点：</strong></p><ul><li>Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;</li><li>B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;</li></ul><p><strong>为什么不都用Hash索引而使用B+树索引？</strong></p><ol><li>Hash索引仅仅能满足”=”,”IN”和””查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</li><li>Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</li><li>Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</li><li>Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</li><li>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。</li></ol></blockquote><h2 id="9、事务"><a href="#9、事务" class="headerlink" title="9、事务"></a>9、事务</h2><h4 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a><strong>1.什么是事务？</strong></h4><blockquote><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p></blockquote><h4 id="2-事务四大特性（ACID）原子性、一致性、隔离性、持久性"><a href="#2-事务四大特性（ACID）原子性、一致性、隔离性、持久性" class="headerlink" title="2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?"></a><strong>2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?</strong></h4><blockquote><p><strong>原子性（Atomicity）:</strong><br>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p><strong>一致性（Consistency）:</strong><br>事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p><p><strong>隔离性（Isolation）:</strong><br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p><p><strong>持久性（Durability）:</strong><br>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p></blockquote><p>!!!!!</p><p>事务隔离级别为：<strong>未提交读</strong>时，写数据只会锁住相应的行。</p><p>事务隔离级别为：<strong>可重复读</strong>时，写数据会锁住整张表。</p><p>事务隔离级别为：<strong>串行化</strong>时，读写数据都会锁住整张表。</p><p>隔离级别越高，越能保证数据的完整性和一致性，但是<strong>对并发性能的影响也越大</strong></p><h2 id="10、JDBC连接步骤"><a href="#10、JDBC连接步骤" class="headerlink" title="10、JDBC连接步骤"></a>10、JDBC连接步骤</h2><blockquote><p>1、加载JDBC驱动</p><p>2、建立连接</p><p>3、写SQL语句</p><p>4、得到preparedStatement</p><p>5、执行sql，得到结果集ResultSet</p><p>6、处理结果集</p><p>7、关闭资源</p></blockquote><h2 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2><p>1、存储引擎，包括myisam，innoDB，锁。</p><p>2、缓存</p><p>3、执行计划、SQL运行</p><p>4、分表</p><p>5、读写分离、主从复制</p><p>6、碎片整理</p><p>7、备份</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、数据库&quot;&gt;&lt;a href=&quot;#一、数据库&quot; class=&quot;headerlink&quot; title=&quot;一、数据库&quot;&gt;&lt;/a&gt;一、数据库&lt;/h1&gt;&lt;h2 id=&quot;1、left-join-和-inner-join的区别&quot;&gt;&lt;a href=&quot;#1、left-join-和-inner-join的区别&quot; class=&quot;headerlink&quot; title=&quot;1、left join 和 inner join的区别&quot;&gt;&lt;/a&gt;1、left join 和 inner join的区别&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xifujiang.github.io//posts/0/"/>
    <id>https://xifujiang.github.io//posts/0/</id>
    <published>2019-11-21T11:40:28.576Z</published>
    <updated>2020-01-13T07:06:23.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="redis支持的数据类型"><a href="#redis支持的数据类型" class="headerlink" title="redis支持的数据类型"></a>redis支持的数据类型</h2><p>String，hash（哈希），List（列表），set（集合），zset（有序集合）</p><a id="more"></a><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务器宕机了内存数据丢失。</p><p><strong>持久化方式</strong>：RDB(默认) 和 AOF</p><p><strong>RDB</strong>：redis DataBase</p><p>功能核心函数rdbSave（生成RDB文件）和rdbLoad（从文件加载内存）两个函数</p><p><strong>AOF</strong>：Append-only file</p><p><strong>比较</strong>：</p><blockquote><p>1、AOF文件比RDB更新频率高，优先使用AOF还原数据。</p><p>2、AOF比RDB更安全也更大</p><p>3、RDB性能比AOF好</p><p>4、如果两个都配了优先加载AOF</p></blockquote><h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><p><strong>单机版</strong>：</p><blockquote><p>特点：简单</p><p>问题：1、内存容量有限 2、处理能力有限 3、无法高可用。</p></blockquote><p><strong>主从复制</strong>：</p><blockquote><p>有多个redis服务器，数据从主服务器（master）复制到从服务器（slave），数据写入主服务器，从服务器负责读取数据。</p><p>特点：</p><p>1、master/slave 角色</p><p>2、master/slave 数据相同</p><p>3、降低 master 读压力在转交从库</p><p>问题：</p><p>无法保证高可用</p><p>没有解决 master 写的压力</p></blockquote><p><strong>哨兵</strong>：</p><blockquote><p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p><p>监控（Monitoring）：    Sentinel  会不断地检查你的主服务器和从服务器是否运作正常。</p><p>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p><p>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</p><p>特点：</p><p>1、保证高可用</p><p>2、监控各个节点</p><p>3、自动故障迁移</p><p>缺点：主从模式，切换需要时间丢数据</p><p>没有解决 master 写的压力</p></blockquote><p><strong>集群</strong>（proxy）：</p><blockquote><p>Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。</p><p>特点：</p><p>1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins </p><p>2、支持失败节点自动删除</p><p>3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致</p><p>缺点：增加了新的 proxy，需要维护其高可用。</p></blockquote><p><strong>集群（直连型）：</strong></p><blockquote><p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p><p>特点：</p><p>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</p><p>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p><p>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</p><p>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</p><p>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p><p>缺点：</p><p>1、资源隔离性较差，容易出现相互影响的情况。</p><p>2、数据通过异步复制,不保证数据的强一致性</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;redis支持的数据类型&quot;&gt;&lt;a href=&quot;#redis支持的数据类型&quot; class=&quot;headerlink&quot; title=&quot;redis支持的数据类型&quot;&gt;&lt;/a&gt;redis支持的数据类型&lt;/h2&gt;&lt;p&gt;String，hash（哈希），List（列表），set（集合），zset（有序集合）&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xifujiang.github.io//posts/0/"/>
    <id>https://xifujiang.github.io//posts/0/</id>
    <published>2019-11-21T10:32:11.282Z</published>
    <updated>2020-01-13T07:06:23.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、线程"><a href="#一、线程" class="headerlink" title="一、线程"></a>一、线程</h1><h2 id="1、线程的类别"><a href="#1、线程的类别" class="headerlink" title="1、线程的类别"></a>1、线程的类别</h2><ul><li>Thread（类）、Runable、Callable、Future，后面三个都是接口。</li><li>Runable有个无返回值的run的抽象方法，使用时可通过实现类重写run方法，使用Thread封装实现类，然后运行。</li></ul><a id="more"></a><ul><li>Callable有一个有返回值V的<strong>call</strong>方法，并抛出Exception异常。使用时做Callable的实现类，使用FutureTask类做封装，再用Thread类对FutureTask做封装，运行</li><li>FutureTask继承RunableFuture，RunableFuture实现Runable和Callable</li><li>Thread的构造方法有对Runable的参数，重载的方法还有（Runable r, String name）</li></ul><h2 id="2、线程池，创建方式"><a href="#2、线程池，创建方式" class="headerlink" title="2、线程池，创建方式"></a>2、线程池，创建方式</h2><ul><li><p>创建大小不固定的线程池：类实现Runable，重写run方法</p></li><li><p>1、创建大小不固定的线程池：主函数创建线程池的方式，具有<strong>缓冲功能</strong>的线程池，系统根据需要创建线程，线程会被缓冲到线程池中，如果<strong>线程池大小超过了处理任务所需要的线程</strong>，线程池就会回收空闲的线程池，当处理任务增加时，线程池可以<strong>增加线程来处理任务</strong>，线程池<strong>不会对线程的大小进行限制</strong>，线程池的大小<strong>依赖于操作系统</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es=Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">ThreadChi tc=<span class="keyword">new</span> ThreadChi();</span><br><span class="line">    es.execute(tc);</span><br><span class="line">}</span><br><span class="line">es.shutdown();</span><br></pre></td></tr></tbody></table></figure></li><li><p>2、<strong>创建固定数量线程的线程池</strong>：创建具一个可重用的，有固定 数量的线程池，每次提交一个任务就提交一个线程，直到线程达到线程池大小，就不会创建新线程了，线程池的大小达到最大后达到稳定不变，如果一个线程</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es=Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">ThreadChi tc=<span class="keyword">new</span> ThreadChi();</span><br><span class="line">es.execute(tc);</span><br><span class="line">}</span><br><span class="line">es.shutdown();</span><br></pre></td></tr></tbody></table></figure></li><li><p>3、创建单线程的线程池</p><p>创建只有一个线程的线程池，按照提交顺序执行，跟上个数量为1的是一样</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es=Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">    ThreadChi tc=<span class="keyword">new</span> ThreadChi();</span><br><span class="line">    es.execute(tc);</span><br><span class="line">}</span><br><span class="line">es.shutdown();</span><br></pre></td></tr></tbody></table></figure></li><li><p>4、创建实时线程</p><p>创建一个线程池，大小可以设置，此线程支持定时以及周期性的执行任务，定时任务</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService es=Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">ThreadChi tc=<span class="keyword">new</span> ThreadChi();</span><br><span class="line"><span class="comment">//参数1：目标对象 </span></span><br><span class="line"><span class="comment">//参数2：隔多长时间开始执行线程    </span></span><br><span class="line"><span class="comment">//参数3：执行周期</span></span><br><span class="line"><span class="comment">//参数4：时间单位</span></span><br><span class="line">es.scheduleAtFixedRate(tc, <span class="number">3</span>, <span class="number">1</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></tbody></table></figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、线程&quot;&gt;&lt;a href=&quot;#一、线程&quot; class=&quot;headerlink&quot; title=&quot;一、线程&quot;&gt;&lt;/a&gt;一、线程&lt;/h1&gt;&lt;h2 id=&quot;1、线程的类别&quot;&gt;&lt;a href=&quot;#1、线程的类别&quot; class=&quot;headerlink&quot; title=&quot;1、线程的类别&quot;&gt;&lt;/a&gt;1、线程的类别&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Thread（类）、Runable、Callable、Future，后面三个都是接口。&lt;/li&gt;
&lt;li&gt;Runable有个无返回值的run的抽象方法，使用时可通过实现类重写run方法，使用Thread封装实现类，然后运行。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xifujiang.github.io//posts/0/"/>
    <id>https://xifujiang.github.io//posts/0/</id>
    <published>2019-11-18T12:41:17.234Z</published>
    <updated>2020-01-13T07:06:23.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NIO原理解析"><a href="#NIO原理解析" class="headerlink" title="NIO原理解析"></a>NIO原理解析</h1><h2 id="BIO的缺点"><a href="#BIO的缺点" class="headerlink" title="BIO的缺点"></a>BIO的缺点</h2><p>两个地方有阻塞——并发需要多线程支持——多线程会造成服务器资源浪费</p><a id="more"></a><h4 id="高并发量引起的问题"><a href="#高并发量引起的问题" class="headerlink" title="高并发量引起的问题"></a>高并发量引起的问题</h4><p>一个使用传统阻塞I/O的系统,如果还是使用传统的一个请求对应一个线程这种模式,<strong>一旦有高并发的大量请求</strong>,就会有如下问题： </p><p>1、<strong>线程不够用</strong>, 就算使用了线程池复用线程也无济于事; </p><p>2、阻塞I/O模式下,会有大量的<strong>线程被阻塞</strong>,一直在等待数据,这个时候的线程被挂起,只能干等,<strong>CPU利用率很低</strong>,换句话说,系统的<strong>吞吐量差</strong>; </p><p>3、如果网络I/O堵塞或者有<strong>网络抖动或者网络故障</strong>等,线程的阻塞时间可能很长。整个系统也变的<strong>不可靠</strong>;</p><h2 id="NIO的设计思路"><a href="#NIO的设计思路" class="headerlink" title="NIO的设计思路"></a>NIO的设计思路</h2><p>设计初衷：<strong>利用单线程处理并发</strong></p><p>初始设计缺陷：</p><blockquote><p>for循环在Java应用程序中——–>OS———–> java—jni—自己写的一个c</p><p>for循环太多，且可能大多无意义———->epoll</p></blockquote><p>redis——单线程——C——epoll</p><p>epoll性能大于select</p><h1 id="IO和NIO的区别"><a href="#IO和NIO的区别" class="headerlink" title="IO和NIO的区别"></a>IO和NIO的区别</h1><p>原有的 IO 是面向流的、阻塞的，NIO 则是面向块的、非阻塞的。</p><h4 id="怎么理解IO是面向流的、阻塞的"><a href="#怎么理解IO是面向流的、阻塞的" class="headerlink" title="怎么理解IO是面向流的、阻塞的"></a>怎么理解IO是面向流的、阻塞的</h4><p>java1.4以前的io模型，一连接对一个线程。</p><p>原始的IO是面向流的，不存在缓存的概念。Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区</p><p>Java IO的各种流是阻塞的，这意味着当一个线程调用read或 write方法时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了。</p><p><img src="https:////upload-images.jianshu.io/upload_images/13957164-549c6e2b66765298.png?imageMogr2/auto-orient/strip|imageView2/2/w/586/format/webp" alt="img"></p><p>阻塞I/O模型</p><h4 id="怎么理解NIO是面向块的、非阻塞的"><a href="#怎么理解NIO是面向块的、非阻塞的" class="headerlink" title="怎么理解NIO是面向块的、非阻塞的"></a>怎么理解NIO是面向块的、非阻塞的</h4><p>NIO是<strong>面向缓冲区</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性。</p><p>Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p><p>通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来,根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分配10000个。</p><h1 id="NIO的核心实现"><a href="#NIO的核心实现" class="headerlink" title="NIO的核心实现"></a>NIO的核心实现</h1><p>在标准IO API中，你可以操作字节流和字符流，但在新IO中，你可以操作通道和缓冲，数据总是从通道被读取到缓冲中或者从缓冲写入到通道中。</p><p>NIO核心API Channel, Buffer, Selector</p><h4 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a>通道Channel</h4><p>NIO的通道类似于流，但有些区别如下：</p><p>\1. 通道可以同时进行读写，而流只能读或者只能写</p><p>\2. 通道可以实现异步读写数据</p><p>\3. 通道可以从缓冲读数据，也可以写数据到缓冲: </p><p><img src="https:////upload-images.jianshu.io/upload_images/13957164-c970757320fbbc30.png?imageMogr2/auto-orient/strip|imageView2/2/w/338/format/webp" alt="img"></p><p>可以从通道读取数据到缓冲区，也可以把缓冲区的数据写到通道中</p><h4 id="缓存Buffer"><a href="#缓存Buffer" class="headerlink" title="缓存Buffer"></a>缓存Buffer</h4><p>缓冲区本质上是一个可以写入数据的内存块，然后可以再次读取，该对象提供了一组方法，可以更轻松地使用内存块，使用缓冲区读取和写入数据通常遵循以下四个步骤：</p><p>\1. 写数据到缓冲区；</p><p>\2. 调用buffer.flip()方法；</p><p>\3. 从缓冲区中读取数据；</p><p>\4. 调用buffer.clear()或buffer.compat()方法；</p><p>当向buffer写入数据时，buffer会记录下写了多少数据，一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式，在读模式下可以读取之前写入到buffer的所有数据，一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。</p><p><strong>Buffer在与Channel交互时，需要一些标志:</strong></p><p>buffer的大小/容量 - <strong>Capacity</strong></p><p>作为一个内存块，Buffer有一个固定的大小值，用参数capacity表示。</p><p>当前读/写的位置 - <strong>Position</strong></p><p>当写数据到缓冲时，position表示当前待写入的位置，position最大可为capacity – 1；当从缓冲读取数据时，position表示从当前位置读取。</p><p>信息末尾的位置 - <strong>limit</strong></p><p>在写模式下，缓冲区的limit表示你最多能往Buffer里写多少数据； 写模式下，limit等于Buffer的capacity，意味着你还能从缓冲区获取多少数据。</p><p>下图展示了buffer中三个关键属性capacity，position以及limit在读写模式中的说明：</p><p><img src="https:////upload-images.jianshu.io/upload_images/13957164-8c4827d042813fce.png?imageMogr2/auto-orient/strip|imageView2/2/w/506/format/webp" alt="img"></p><p>buffer中三个关键属性capacity，position以及limit在读写模式中的说明</p><p>缓冲区常用的操作</p><p><strong>向缓冲区写数据：</strong></p><p>​    \1. 从Channel写到Buffer；</p><p>​    \2. 通过Buffer的put方法写到Buffer中；</p><p><strong>从缓冲区读取数据：</strong></p><p>​    \1. 从Buffer中读取数据到Channel；</p><p>​    \2. 通过Buffer的get方法从Buffer中读取数据；</p><p><strong>flip方法：</strong></p><p>​     将Buffer从写模式切换到读模式，将position值重置为0，limit的值设置为之前position的值；</p><p><strong>clear方法 vs compact方法：</strong></p><p>​       clear方法清空缓冲区；compact方法只会清空已读取的数据，而还未读取的数据继续保存在Buffer中；</p><h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>一个组件，可以检测多个NIO channel，看看读或者写事件是否就绪。</p><p>多个Channel以事件的方式可以注册到同一个Selector，从而达到用一个线程处理多个请求成为可能。</p><p><img src="https:////upload-images.jianshu.io/upload_images/13957164-539fcf908e51b229.png?imageMogr2/auto-orient/strip|imageView2/2/w/783/format/webp" alt="img"></p><p>一个thread对应多个channel,一个channel处理一个请求。</p><p><img src="https:////upload-images.jianshu.io/upload_images/13957164-3d8041ee5b735b73.png?imageMogr2/auto-orient/strip|imageView2/2/w/462/format/webp" alt="img"></p><p>当你调用Selector的select()或者 selectNow() 方法它只会返回有数据读取的SelectableChannel的实例.</p><h2 id="模拟一个单线程的处理高并发的应用"><a href="#模拟一个单线程的处理高并发的应用" class="headerlink" title="模拟一个单线程的处理高并发的应用"></a>模拟一个单线程的处理高并发的应用</h2><h2 id="模拟JVM（C-C-）实现socket对象的源码"><a href="#模拟JVM（C-C-）实现socket对象的源码" class="headerlink" title="模拟JVM（C C++）实现socket对象的源码"></a>模拟JVM（C C++）实现socket对象的源码</h2><h2 id="模拟一个C语言-JVM当中实现NIO"><a href="#模拟一个C语言-JVM当中实现NIO" class="headerlink" title="模拟一个C语言 JVM当中实现NIO"></a>模拟一个C语言 JVM当中实现NIO</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NIO原理解析&quot;&gt;&lt;a href=&quot;#NIO原理解析&quot; class=&quot;headerlink&quot; title=&quot;NIO原理解析&quot;&gt;&lt;/a&gt;NIO原理解析&lt;/h1&gt;&lt;h2 id=&quot;BIO的缺点&quot;&gt;&lt;a href=&quot;#BIO的缺点&quot; class=&quot;headerlink&quot; title=&quot;BIO的缺点&quot;&gt;&lt;/a&gt;BIO的缺点&lt;/h2&gt;&lt;p&gt;两个地方有阻塞——并发需要多线程支持——多线程会造成服务器资源浪费&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hadoop详细学习</title>
    <link href="https://xifujiang.github.io//posts/a5ead4c6/"/>
    <id>https://xifujiang.github.io//posts/a5ead4c6/</id>
    <published>2019-09-13T09:50:11.087Z</published>
    <updated>2020-01-13T02:44:01.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、hadoop"><a href="#1、hadoop" class="headerlink" title="1、hadoop"></a>1、hadoop</h1><h2 id="1-1-hadoop介绍"><a href="#1-1-hadoop介绍" class="headerlink" title="1.1 hadoop介绍"></a>1.1 hadoop介绍</h2><p>1）hadoop是一个由Apache基金会所开发的分布式系统基础架构。</p><p>2）主要解决海量数据的存储和海量数据的分析计算问题。</p><p>3）Hadoop生态圈</p><a id="more"></a><h2 id="1-2-Lucence框架"><a href="#1-2-Lucence框架" class="headerlink" title="1.2 Lucence框架"></a>1.2 Lucence框架</h2><p>1）Lucene框架使Doug Cutting开创的开源软件，用户Java书写代码，实现与Google类似的全文搜索功能，它提供了全文检索引擎的架构，包括完整的查询引擎和索引引擎。</p><p>2）2001年年底Lucene成为Apache基金会的一个子项目。</p><p>3）对于海量数据的场景，Lucence面对与Google同样的困难，存储数据困难，检索速度慢。</p><p>4）学习和模仿Google解决这些问题的办法：微型版Nutch。</p><p>5）Google是Haddop的思想之源。</p><p>6）2003-2004年，Google公开了部分GFS和MapReduce思想的细节，以此为基础Doug Cutting等人用了2年业余时间实现了DFS和MapReduce机制，使Nutch性能飙升。</p><p>7）2005年Hadoop作为Lucene的子项目Nutch的一部分正式引入Apache基金会。</p><p>8）2006年3月份，Map-Reduce和Nutch Distributed File System（NDFS）分别被纳入称为Hadoop的项目中。</p><p>9）名字来源于Doug Cutting儿子的玩具大象。</p><h2 id="1-3-hadoop三大发行版本"><a href="#1-3-hadoop三大发行版本" class="headerlink" title="1.3 hadoop三大发行版本"></a>1.3 hadoop三大发行版本</h2><p>Apache、Cloudera、Hortonworks。</p><h2 id="1-4-hadoop的优势（面试）"><a href="#1-4-hadoop的优势（面试）" class="headerlink" title="1.4 hadoop的优势（面试）"></a>1.4 hadoop的优势（面试）</h2><p>1)高可靠性：Hadoop底层维护多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失。</p><p>2）高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点。</p><p>3）高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度。</p><p>4）高容错性：能够自动将失败的任务重新分配。</p><h2 id="1-5-hadoop1-x-和hadoop2-x区别"><a href="#1-5-hadoop1-x-和hadoop2-x区别" class="headerlink" title="1.5 hadoop1.x 和hadoop2.x区别"></a>1.5 hadoop1.x 和hadoop2.x区别</h2><p><strong>hadoop1.x组成：</strong></p><ul><li>Common（辅助工具）、HDFS（数据存储）、MapReduce（计算+资源调度）</li><li>CPU 8  内存：128MB 磁盘 8T</li></ul><p><strong>hadoop2.x组成：</strong></p><ul><li>Common（辅助工具）、HDFS（数据存储）、MapReduce（计算）、yarn（资源调度）</li><li>CPU 8  内存：128MB 磁盘 8T</li></ul><p>对比：hadoop1.x时代，MapReduce既处理运算，又处理资源调度，耦合性较大。hadoop1.x时代，增加了Yarn。Yarn只负责资源的调度，MapReduce只负责运算。</p><h2 id="1-6-组件架构"><a href="#1-6-组件架构" class="headerlink" title="1.6 组件架构"></a>1.6 组件架构</h2><h3 id="1、hdfs架构概述"><a href="#1、hdfs架构概述" class="headerlink" title="1、hdfs架构概述"></a>1、hdfs架构概述</h3><p>1）NameNode（nn）：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、福本数、文件权限），以及每个文件的块列表和块所在的DataNode等。</p><p>2）DataNode（dn）：在本地文件系统存储文件数据，以及数据的校验和。</p><p>3）Secondary NameNode（2nn）：用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。加快启动速度。</p><h3 id="2、Yarn架构"><a href="#2、Yarn架构" class="headerlink" title="2、Yarn架构"></a>2、Yarn架构</h3><p>1）ResourceManager （RM）主要作用如下</p><p>（1）处理客户端请求</p><p>（2）监控NodeManager</p><p>（3）启动或监控ApplicationMaster（集群中运行的一个job）</p><p>（4）资源的分配与调度</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/yarn架构.png" alt="yarn架构" title>                </div>                <div class="image-caption">yarn架构</div>            </figure><p>2）NodeManager（NM）主要作用如下</p><p>（1）管理单个节点上的资源</p><p>（2）<strong>处理来自</strong>ResourceManager<strong>的命令</strong></p><p>（3）<strong>处理来自</strong>ApplicationMaster<strong>的命令</strong></p><p>3）ApplicationMaster（AM）作用如下</p><p>（1）负责数据的切分</p><p>（2）为某个程序申请资源并分配给内部的任务</p><p>（3）任务的监控与容错</p><p>4）Container</p><p>container是Yarn中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘、网络等。</p><h3 id="3、MapReduce架构概述"><a href="#3、MapReduce架构概述" class="headerlink" title="3、MapReduce架构概述"></a>3、MapReduce架构概述</h3><p>MapReduce将计算过程分为两个阶段：Map和Reduce</p><p>1）Map阶段<strong>并行处理</strong>输入数据。</p><p>2）Reduce阶段对Map结果进行汇总</p><h2 id="1-7-大数据技术生态体系"><a href="#1-7-大数据技术生态体系" class="headerlink" title="1.7 大数据技术生态体系"></a>1.7 大数据技术生态体系</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/大数据技术生态体系.png" alt="大数据技术生态体系" title>                </div>                <div class="image-caption">大数据技术生态体系</div>            </figure><p>图中涉及的技术名词解释如下：</p><p>1）<strong>Sqoop</strong>：Sqoop是一款开源的工具，主要用于在Hadoop、Hive与传统的数据库(MySql)间进行**数据的迁移，可以将一个关系型数据库（例如 ：MySQL，Oracle 等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。</p><p>2）<strong>Flume</strong>：Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量<strong>日志采集</strong>、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；同时，Flume提供对数据进行简单处理，并写到各种数据接受方（可定制）的能力。</p><p>3）<strong>Kafka</strong>：Kafka是一种<strong>高吞吐量的分布式发布订阅消息系统</strong>，有如下特性：</p><p>（1）通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。</p><p>（2）高吞吐量：即使是<strong>非常普通的硬件Kafka也可以支持每秒数百万的消息</strong>。</p><p>（3）支持通过Kafka服务器和消费机集群来分区消息。</p><p>（4）支持Hadoop<strong>并行数据加载</strong>。</p><p>4）<strong>Storm</strong>：Storm用于“连续计算”，对<strong>数据流做连续查询</strong>，在计算时就将结果以流的形式输出给用户。</p><p>5）<strong>Spark</strong>：Spark是当前最流行的开源大数据内存计算框架。可以基于Hadoop上存储的大数据进行<strong>计算</strong>。</p><p>6）<strong>Oozie</strong>：Oozie是一个管理Hdoop作业（job）的工作流程调度管理系统。</p><p>7）<strong>Hbase</strong>：HBase是一个分布式的、面向列的开源数据库。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。</p><p>8）<strong>Hive</strong>：Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供简单的SQL查询功能，可以将SQL语句转换为MapReduce任务进行运行。 其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p><p>10）<strong>R语言</strong>：R是用于统计分析、绘图的语言和操作环境。R是属于GNU系统的一个自由、免费、源代码开放的软件，它是一个用于统计计算和统计制图的优秀工具。</p><p>11）<strong>Mahout</strong>：Apache Mahout是个可扩展的机器学习和数据挖掘库。</p><p>12）<strong>ZooKeeper</strong>：Zookeeper是Google的Chubby一个开源的实现。它是一个针对大型分布式系统的可靠协调系统，提供的功能包括：配置维护、名字服务、 分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p><h2 id="1-8-hadoop重要目录"><a href="#1-8-hadoop重要目录" class="headerlink" title="1.8 hadoop重要目录"></a>1.8 hadoop重要目录</h2><p>（1）bin目录：存放对Hadoop相关服务（HDFS,YARN）进行操作的脚本</p><p>（2）etc目录：Hadoop的配置文件目录，存放Hadoop的配置文件</p><p>（3）lib目录：存放Hadoop的本地库（对数据进行压缩解压缩功能）</p><p>（4）sbin目录：存放启动或停止Hadoop相关服务的脚本</p><p>（5）share目录：存放Hadoop的依赖jar包、文档、和官方案例</p><h2 id="1-9完全分布式运行模式"><a href="#1-9完全分布式运行模式" class="headerlink" title="1.9完全分布式运行模式"></a>1.9完全分布式运行模式</h2><p>1、准备三台客户机（关闭防火墙、静态ip、主机名称）</p><p>2、安装JDK</p><p>3、配置环境变量</p><p>4、安装hadoop</p><p>5、配置环境变量</p><p>6、配置集群</p><p>7、单点启动</p><p>8、配置ssh</p><p>9、群起并测试集群</p><h1 id="2、HDFS"><a href="#2、HDFS" class="headerlink" title="2、HDFS"></a>2、HDFS</h1><h2 id="2、1-介绍"><a href="#2、1-介绍" class="headerlink" title="2、1 介绍"></a>2、1 介绍</h2><p>产生背景：数据量大，一个操作系统存不过来，<strong>需要一种系统管理多台机器上的文件</strong></p><p>定义：HDFS(Hadoop Distributed File System)，<strong>分布式文件管理系统。</strong>用于存储文件，通过目录树来定位文件。</p><p>使用场景：适合一次写入，多次读出的场景，且不支持文件的修改。</p><h2 id="2-2-1-优点"><a href="#2-2-1-优点" class="headerlink" title="2.2.1 优点"></a>2.2.1 优点</h2><p>1、高容错性</p><p>（1）数据自动<strong>保存多个副本</strong>。通过增加副本的形式，提高容错性。</p><p>（2）某个副本丢失后，可以<strong>自动恢复</strong></p><p>2、适合处理大数据</p><p>（1）数据规模：那个处理数据规模达到<strong>GB、TB、甚至PB级别</strong>的数据；</p><p>（2）文件规模：能够处理<strong>百万规模以上的文件数量</strong>，数量相当之大。</p><p>3、可构建在廉价机器上，通过多副本机制，提高可靠性。</p><h2 id="2-2-2-缺点"><a href="#2-2-2-缺点" class="headerlink" title="2.2.2 缺点"></a>2.2.2 缺点</h2><p>1）不适合<strong>低延时数据</strong>访问，比如毫秒级的存储数据，是做不到的。</p><p>2）无法高效的<strong>对大量小文件</strong>进行存储。</p><p>（1）存储大量小文件的话，它会占用NameNode大量的内存来<strong>存储文件目录</strong>和<strong>块信息</strong>。这样是不可取的，因为<strong>NameNode的内存总是有限</strong>的；</p><p>（2）小文件存储的<strong>寻址时间会超过读取时间</strong>，它违反了HDFS的设计目标。</p><p>3）<strong>不支持并发写入、文件随机修改</strong>。</p><p>（1）一个文件只能有一个写，不允许 多个线程同时写。</p><p>（2）仅支持数据append（追加），不支持文件的随机修改。</p><h2 id="2-3-组件功能"><a href="#2-3-组件功能" class="headerlink" title="2.3 组件功能"></a>2.3 组件功能</h2><p>1）NameNode（nn）：就是Master，它是一个管理者。</p><p>（1）<strong>管理HDFS的名称空间</strong>；</p><p>（2）配置<strong>副本策略</strong>；</p><p>（3）<strong>管理数据块（Block）映射信息</strong>；</p><p>（4）<strong>处理客户端读写请求</strong>。</p><p>2）DataNode：就是slave。NameNode下达命令。DataNode执行实际的操作。</p><p>（1）<strong>存储实际的数据块</strong>；</p><p>（2）<strong>执行数据块的读/写操作</strong>。</p><p>3）client：客户端</p><p>（1）文件切分。文件上传HDFS的时候，Client将文件切分成一个一个的Block，然后进行上传；</p><p>（2）与NameNode交互，获取文件的位置信息；</p><p>（3）与DataNode交互，读取或者写入数据；</p><p>（4）Client提供一些命令来管理HDFS，比如NameNode格式化；</p><p>（5）Client可以通过一些命令来访问HDFS，比如对HDFS增删查改操作；</p><p>4）Secondary NameNode：并非NameNode的热备。当NameNode挂掉的时候，它并不能替代NameNode并提供服务。</p><p>（1）辅助NameNode，分担其工作量，比如<strong>定期合并Fsimage和Edits</strong>，并推送给NameNode；</p><p>（2）在紧急情况下，可辅助恢复NameNode。</p><h2 id="2-4-文件块大小"><a href="#2-4-文件块大小" class="headerlink" title="2.4 文件块大小"></a>2.4 文件块大小</h2><p>HDFS中的文件在物理上是分块存储（Block），块的大小可以通过配置参数（dfs.blocksize）来规定，默认大小在Hadoop2.x版本中是128M，老版中是64M。</p><p> 1、集群中的block，2、如果寻址时间约为10ms，即查到目标block的时间为10ms，3寻址时间为传输时间的1%时，则为最佳状态。因此，传输时间=10ms/0.01=1000ms=1s。4 而目前磁盘的传输速率普遍为100MB/s。</p><p>思考：为什么块的大小不能设置太小，也不能设置太大？</p><p>1）HDFS的块设置太小，会增加寻址时间，程序一直在找块的开始位置；</p><p>2）如果块设置的太大，从磁盘传输数据的时间会明显大于定位这个块开始位置所需要的时间。导致程序在处理这块数据时。会非常慢。</p><p>总结：HDFS块的大小设置主要取决于磁盘传输速率。</p><h2 id="2-5-HDFS的数据流（面试重点）"><a href="#2-5-HDFS的数据流（面试重点）" class="headerlink" title="2.5 HDFS的数据流（面试重点）"></a>2.5 HDFS的数据流（面试重点）</h2><h3 id="1、HDFS的写数据流程"><a href="#1、HDFS的写数据流程" class="headerlink" title="1、HDFS的写数据流程"></a>1、HDFS的写数据流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/HDFS的写数据流程.png" alt="1568448314627" title>                </div>                <div class="image-caption">1568448314627</div>            </figure><p>然后重复3-7步骤</p><h3 id="2、网络拓扑-节点距离计算"><a href="#2、网络拓扑-节点距离计算" class="headerlink" title="2、网络拓扑-节点距离计算"></a>2、网络拓扑-节点距离计算</h3><p>节点距离：两个节点到达最近的共同祖先的距离总和。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/网络拓扑-节点距离计算.png" alt="1568448821111" title>                </div>                <div class="image-caption">1568448821111</div>            </figure><h3 id="3、副本节点选择"><a href="#3、副本节点选择" class="headerlink" title="3、副本节点选择"></a>3、副本节点选择</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/机架选择" alt="1568449200994" title>                </div>                <div class="image-caption">1568449200994</div>            </figure><h3 id="4、HDFS的读数据流程"><a href="#4、HDFS的读数据流程" class="headerlink" title="4、HDFS的读数据流程"></a>4、HDFS的读数据流程</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/HDFS的读数据流程.png" alt="1568449571543" title>                </div>                <div class="image-caption">1568449571543</div>            </figure><h2 id="2-6-NameNode和SecondaryNameNode（面试开发重点）"><a href="#2-6-NameNode和SecondaryNameNode（面试开发重点）" class="headerlink" title="2.6 NameNode和SecondaryNameNode（面试开发重点）"></a>2.6 NameNode和SecondaryNameNode（面试开发重点）</h2><h3 id="1、NN和2NN工作机制"><a href="#1、NN和2NN工作机制" class="headerlink" title="1、NN和2NN工作机制"></a>1、NN和2NN工作机制</h3><p>思考：NameNode中的元数据是存储在哪里的？</p><p>首先，我们做个<strong>假设</strong>，如果存储在NameNode节点的磁盘中，因为<strong>经常需要进行随机访问，还有响应客户请求</strong>，必然是<strong>效率过低</strong>。因此，<strong>元数据需要存放在内存</strong>中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此<strong>产生在磁盘中备份元数据的FsImage</strong>。</p><p>这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新FsImage，就会导致<strong>效率过低</strong>，但如果不更新，就会发生一致性问题，一旦NameNode节点断电，就会产生数据丢失。因此，引入Edits文件(只进行追加操作，效率很高)。<strong>每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到Edits中。这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。</strong></p><p>但是，如果长时间添加数据到Edits中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间过长。因此，需要定期进行FsImage和Edits的合并，如果这个操作由NameNode节点完成，又会效率过低。因此，<strong>引入一个新的节点SecondaryNamenode，专门用于FsImage和Edits的合并。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/namenode工作机制" alt="1568450098120" title>                </div>                <div class="image-caption">1568450098120</div>            </figure><ol><li>第一阶段：NameNode启动</li></ol><p>（1）<strong>第一次启动</strong>NameNode<strong>格式化后</strong>，<strong>创建Fsimage</strong>和<strong>Edits文件</strong>。如果<strong>不是第一次启动</strong>，<strong>直接加载</strong>编辑日志和镜像文件到内存。</p><p>（2）客户端<strong>对元数据进行增删改</strong>的请求。</p><p>（3）NameNode<strong>记录操作日志</strong>，<strong>更新滚动日志</strong>。</p><p>（4）NameNode在<strong>内存中对数据进行增删改</strong>。</p><p>\2. 第二阶段：Secondary NameNode工作</p><p>​       （1）Secondary NameNode询问NameNode是否需要<strong>CheckPoint</strong>。直接带回NameNode是否检查结果。</p><p>​       （2）Secondary NameNode请求执行CheckPoint。</p><p>​       （3）NameNode滚动正在写的Edits日志。</p><p>​       （4）将<strong>滚动前的编辑日志和镜像文件拷贝</strong>到Secondary NameNode。</p><p>​       （5）Secondary NameNode加载<strong>编辑日志和镜像文件到内存，并合并</strong>。</p><p>​       （6）<strong>生成新的镜像文件fsimage.chkpoint</strong>。</p><p>​       （7）<strong>拷贝</strong>fsimage.chkpoint到NameNode。</p><p>​       （8）NameNode将fsimage.chkpoint<strong>重新命名</strong>成fsimage。</p><p>注：</p><p><strong>NN和2NN</strong>工作机制详解：</p><p>Fsimage：NameNode内存中元数据序列化后形成的文件。</p><p>Edits：记录客户端<strong>更新元数据信息</strong>的每一步操作（可通过Edits运算出元数据）。</p><p>NameNode启动时，先滚动Edits并生成一个空的edits.inprogress，然后加载Edits和Fsimage到内存中，此时NameNode内存就持有最新的元数据信息。Client开始对NameNode发送元数据的增删改的请求，这些请求的操作首先会被记录到edits.inprogress中（查询元数据的操作不会被记录在Edits中，因为查询操作不会更改元数据信息），如果此时NameNode挂掉，重启后会从Edits中读取元数据的信息。然后，NameNode会在内存中执行元数据的增删改的操作。</p><p>由于Edits中记录的操作会越来越多，Edits文件会越来越大，导致NameNode在启动加载Edits时会很慢，所以需要对Edits和Fsimage进行合并（所谓合并，就是将Edits和Fsimage加载到内存中，照着Edits中的操作一步步执行，最终形成新的Fsimage）。SecondaryNameNode的作用就是帮助NameNode进行Edits和Fsimage的合并工作。</p><p>SecondaryNameNode首先会询问是否需要（触发需要满足两个条件中的任意一个，定时时间到和中数据写满了）。直接带回是否检查结果。执行操作，首先会让滚动并生成一个空的，滚动的目的是给打个标记，以后所有新的操作都写入，其他未合并的和会拷贝到的本地，然后将拷贝的和加载到内存中进行合并，生成，然后将拷贝给，重命名为后替换掉原来的。在启动时就只需要加载之前未合并的和即可，因为合并过的中的元数据信息已经被记录在中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/Fsimage和Edits概念.png" alt="1568451755272" title>                </div>                <div class="image-caption">1568451755272</div>            </figure><h2 id="2-7-DataNode-工作机制"><a href="#2-7-DataNode-工作机制" class="headerlink" title="2.7 DataNode 工作机制"></a>2.7 DataNode 工作机制</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/DataNode工作机制.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="2-7-1DataNode掉线时限参数设置"><a href="#2-7-1DataNode掉线时限参数设置" class="headerlink" title="2.7.1DataNode掉线时限参数设置"></a>2.7.1DataNode掉线时限参数设置</h3><p>1、DataNode进程死亡或者网络故障造成DataNode无法与NameNode通信</p><p>2、NameNode不会立即把该节点判定为死亡，要经过一段时间，这段时间暂称作超时时长。</p><p>3、HDFS默认的超时时长为10分钟+30秒。</p><p>4=如果定义超时时间为TimeOut，则超时时长的计算公式为：timeout = 2<em>XXX(分钟)+10\</em>YYY（秒）。</p><h3 id="2-7-2-服役新数据节点、退役旧数据节点"><a href="#2-7-2-服役新数据节点、退役旧数据节点" class="headerlink" title="2.7.2  服役新数据节点、退役旧数据节点"></a>2.7.2  服役新数据节点、退役旧数据节点</h3><p>1、添加白名单</p><p>2、黑名单退役 </p><p>3、不允许白名单和黑名单中同时出现同一个主机名称。</p><h2 id="2-8-HDFS新特性"><a href="#2-8-HDFS新特性" class="headerlink" title="2.8 HDFS新特性"></a>2.8 HDFS新特性</h2><h3 id="2-8-1-集群间的数据拷贝"><a href="#2-8-1-集群间的数据拷贝" class="headerlink" title="2.8.1 集群间的数据拷贝"></a>2.8.1 集群间的数据拷贝</h3><p>1．scp实现两个远程主机之间的文件复制</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scp -r hello.txt [root@hadoop103:/user/atguigu/hello.txt](mailto:root@hadoop103:/user/atguigu/hello.txt)             // 推 push</span><br><span class="line"></span><br><span class="line">scp -r [root@hadoop103:/user/atguigu/hello.txt  hello.txt](mailto:root@hadoop103:/user/atguigu/hello.txt  hello.txt) // 拉 pull</span><br><span class="line"></span><br><span class="line">scp -r [root@hadoop103:/user/atguigu/hello.txt](mailto:root@hadoop103:/user/atguigu/hello.txt) root@hadoop104:/user/atguigu   //是通过本地主机中转实现两个远程主机的文件复制；如果在两个远程主机之间ssh没有配置的情况下可以使用该方式。</span><br></pre></td></tr></tbody></table></figure><p>2．采用distcp命令实现两个Hadoop集群之间的递归数据复制</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[atguigu@hadoop102 hadoop-2.7.2]$  bin/hadoop distcp</span><br><span class="line">hdfs://haoop102:9000/user/atguigu/hello.txt hdfs://hadoop103:9000/user/atguigu/hello.txt</span><br></pre></td></tr></tbody></table></figure><h3 id="2-8-2-小文件存档"><a href="#2-8-2-小文件存档" class="headerlink" title="2.8.2 小文件存档"></a>2.8.2 小文件存档</h3><p>1、HDFS存储小文件的弊端</p><p><strong>大量的小文件会消耗NameNode中的大部分内存</strong>。但注意，存储小文件所需要的磁盘容量与数据块的大小无关。</p><p>2、解决存储小文件的办法之一</p><p>HDFS存档文件或HAR文件，是一个更高效的文件存档工具，它将文件存入HDFS块，在减少NameNode内存使用的同时，允许对文件进行透明的访问。<strong>也就是说HDFS存档问你件对内还是一个一个独立文件，对NameNode而言却是一个整体，减少了NameNode的内存</strong></p><p>3、实操</p><p>1）先启动hadoop集群</p><p>2）把某目录下的所有文件归档成xx.har的归档文件，并把归档后文件存储到xxx/output路径下。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# hadoop archive -archiveName input.har -p /data/input /data/out</span><br></pre></td></tr></tbody></table></figure><p>3）查看归档</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# hadoop fs -ls -R har:///data/out/input.har</span><br><span class="line">-rw-r--r--   3 root supergroup         38 2019-09-15 23:21 har:///data/out/input.har/1</span><br><span class="line">-rw-r--r--   3 root supergroup         26 2019-09-15 23:21 har:///data/out/input.har/2</span><br><span class="line">-rw-r--r--   3 root supergroup         97 2019-09-13 22:54 har:///data/out/input.har/wc.input</span><br></pre></td></tr></tbody></table></figure><p>4）解归档文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -cp har:/// data/output/input.har/*    /data</span><br></pre></td></tr></tbody></table></figure><h3 id="2-8-3-回收站功能参数"><a href="#2-8-3-回收站功能参数" class="headerlink" title="2.8.3 回收站功能参数"></a>2.8.3 回收站功能参数</h3><p>1、默认值fs.trash.interval = 0, 0表示禁用回收站；其他值表示设置文件的存活时间。</p><p>2、默认值fs.trash.checkpoint.interval = 0，检查回收站的间隔时间。如果该值为0，则该值设置和fs.trash.interval的参数值相等。</p><p>3、要求：fs.trash.checkpoint.interval <= fs.trash.interval 。</p><h2 id="2-9-HDFS-HA高可用"><a href="#2-9-HDFS-HA高可用" class="headerlink" title="2.9 HDFS HA高可用"></a>2.9 HDFS HA高可用</h2><p>策略：<strong>消除单点故障</strong></p><h3 id="2-9-1HDFS-HA工作要点"><a href="#2-9-1HDFS-HA工作要点" class="headerlink" title="2.9.1HDFS-HA工作要点"></a>2.9.1HDFS-HA工作要点</h3><ol><li>元数据管理方式需要改变</li></ol><p>内存中各自保存一份元数据；</p><p>Edits日志<strong>只有Active</strong>状态的NameNode节点可以做<strong>写操作</strong>；</p><p>两个NameNode<strong>都可以读取Edits</strong>；</p><p>共享的Edits放在一个<strong>共享存储中管理</strong>（qjournal和NFS两个主流实现）；</p><ol start="2"><li>需要一个状态管理功能模块</li></ol><p>实现了一个zkfailover，常驻在每一个namenode所在的节点，每一个zkfailover负责监控自己所在NameNode节点，利用zk进行状态标识，当需要进行状态切换时，由zkfailover来负责切换，切换时需要防止brain split现象的发生。</p><ol start="3"><li><p>必须保证两个NameNode之间能够ssh无密码登录</p></li><li><p>隔离（Fence），即同一时刻<strong>仅仅有一个</strong>NameNode<strong>对外</strong>提供服务</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/HDFS-HA故障转移机制.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h1 id="3、MapReduce"><a href="#3、MapReduce" class="headerlink" title="3、MapReduce"></a>3、MapReduce</h1><p>定义：MapReduce是一个<strong>分布式运算程序</strong>的编程框架，是用户开发“基于Hadoop的<strong>数据分析</strong>应用”的核心框架。</p><p>核心功能是将<strong>用户编写的业务逻辑代码</strong>和<strong>自带默认组件</strong>整合成一个完整的分布式运算程序，<strong>并发</strong>运行在一个Hadoop集群上。</p><h2 id="3-1-优缺点"><a href="#3-1-优缺点" class="headerlink" title="3.1 优缺点"></a>3.1 优缺点</h2><p>1、优点：</p><p>1、MapReeduce<strong>易于编程</strong>：它简单的实现一些接口，就可以完成一个分布式程序。</p><p>2、<strong>良好的扩展性</strong>。通过<strong>简单的增加机器</strong>来扩展计算能力。</p><p>3、<strong>高容错性</strong>：如果一台机器宕机，它可以把上面的计算任务转移到另一个节点上运行，不至于这个任务运行的失败。</p><p>4、适合PB级以上<strong>海量数据的离线处理</strong></p><p>缺点：</p><p>1、<strong>不擅长实时计算</strong></p><p>2、<strong>不擅长流式计算</strong>：流式计算的输入数据时动态的，而MapReduce的输入数据集是静态的。</p><p>3、<strong>不擅长DAG（有向图）计算</strong>：多个应用程序存在依赖关系，后一个应用程序的输入为前一个的输出。在这种情况下，MapReduce并不是不能做，<strong>而是使用后，每个MapReduce作业的输出结果都会写入到磁盘，造成大量的磁盘IO，导致性能非常的低下。</strong></p><h2 id="3-2-核心编程思想"><a href="#3-2-核心编程思想" class="headerlink" title="3.2 核心编程思想"></a>3.2 核心编程思想</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/MapReduce核心编程思想.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>一个完整的MapReduce程序在分布式运行时有三类实例进程：</p><p>1）MrAppMaster：负责整个程序的过程调度及状态协调</p><p>2）MapTask：负责Map阶段的整个数据处理流程。</p><p>3）ReduceTask：负责Reduce阶段的整个数据处理流程。</p><h2 id="3-3-编程规范"><a href="#3-3-编程规范" class="headerlink" title="3.3 编程规范"></a>3.3 编程规范</h2><p>1、Mapper阶段</p><p>（1）用户自定义的Mapper要继承自己的父类</p><p>（2）Mapper的输入数据时KV对的形式（KV的类型可自定义）</p><p>（3）Mapper中的业务逻辑写在map（）方法中</p><p>（4）Mapper的输出数据时KV对的形式（KV的类型可自定义）</p><p>（5）map（）方法（MapTask进程）对每一个<K, V>调用一次</p><p>2、Reducer阶段</p><p>（1）用户自定义的Reducer要继承自己的父类</p><p>（2）Reducer的输入数据类型对应Mapper的输出数据类型，也是KV</p><p>（3）Reducer的业务逻辑卸载reduce（）方法中</p><p>（4）ReducerTask进程对每一组相同的k的<k,v>组调用一次reduce()方法</p><p>3、Driver阶段</p><p>相当于Yarn集群的客户端，用于提交我们整个程序到Yarn集群，提交的是封装了MapReduce程序相关运行参数的job对象。</p><h2 id="3-4-wordcount"><a href="#3-4-wordcount" class="headerlink" title="3.4 wordcount"></a>3.4 wordcount</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/wordcount程序执行过程.png)" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h2 id="3-5-序列化和反序列化（重要）"><a href="#3-5-序列化和反序列化（重要）" class="headerlink" title="3.5 序列化和反序列化（重要）"></a>3.5 序列化和反序列化（重要）</h2><h3 id="3-5-1-定义与作用"><a href="#3-5-1-定义与作用" class="headerlink" title="3.5.1 定义与作用"></a>3.5.1 定义与作用</h3><p>序列化就是把<strong>内存中的对象，转换成字节序列</strong>（或其他数据传输协议）以便于<strong>存储到磁盘（持久化）</strong>和<strong>网络传输</strong>。</p><p>反序列化就是将字节序列（或其他数据传输协议）或者是磁盘的持久化数据，转换成内存中的对象。</p><p>为什么要序列化：对象只生存在内存里，关机断电就莫得了，序列化可以存储“活的”对象，可以将“活的”对象发送到远程计算机。</p><p>！！！为什么不用java的序列化</p><p>java的序列化是重量级序列化框架，一个对象被序列化后，会附带很多额外的信息（各种校验信息，Header，继承体系等），不便于在网络中高效传输。所以，Hadoop自己开发了一套序列化机制（Writable）。</p><p>hadoop<strong>序列化的特点</strong>：</p><p>1）紧凑：高效实用存储空间。</p><p>2）快速：读写数据的额外开销小。</p><p>3）可扩展：随着通信协议的升级而可升级</p><p>4）互操作：支持多语言的交互</p><h3 id="3-5-2-操作"><a href="#3-5-2-操作" class="headerlink" title="3.5.2 操作"></a>3.5.2 操作</h3><p>七步走：</p><p>（1）必须实现Writable接口</p><p>（2）反序列化时，需要反射调用空参构造函数，所以必须有空参构造</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FlowBean</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(DataOutput out)</span> <span class="keyword">throws</span> IOException </span>{       out.writeLong(upFlow);       </span><br><span class="line">out.writeLong(downFlow);       </span><br><span class="line">out.writeLong(sumFlow);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>（4）重写反序列化方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFields</span><span class="params">(DataInput   in)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">upFlow   = in.readLong();       </span><br><span class="line">downFlow   = in.readLong();       </span><br><span class="line">sumFlow   = in.readLong();   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>（5）注意反序列化的顺序和序列化的顺序完全一致</p><p>（6）要想把结果显示在文件中，需要重写toString()，可用”\t”分开，方便后续用。</p><p>（7）如果需要将自定义的bean放在key中传输，则还需要实现Comparable接口，因为MapReduce框中的Shuffle过程要求对key必须能排序。详见后面排序案例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(FlowBean o)</span>   </span>{       <span class="comment">//   倒序排列，从大到小       return this.sumFlow > o.getSumFlow() ? -1 : 1;   </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-6-2-切片与MapTask并行度决定机制"><a href="#3-6-2-切片与MapTask并行度决定机制" class="headerlink" title="3.6.2 切片与MapTask并行度决定机制"></a>3.6.2 切片与MapTask并行度决定机制</h3><p>1．问题引出</p><p>MapTask的并行度决定Map阶段的任务处理并发度，进而影响到整个Job的处理速度。</p><p>思考：1G的数据，启动8个MapTask，可以提高集群的并发处理能力。那么1K的数据，也启动8个MapTask，会提高集群性能吗？MapTask并行任务是否越多越好呢？哪些因素影响了MapTask并行度？                                                  </p><p>2．MapTask并行度决定机制</p><p><strong>数据块：</strong>Block是<strong>HDFS物理上</strong>把数据分成一块一块。</p><p><strong>数据切片：</strong>数据切片只是在<strong>逻辑</strong>上对输入进行分片，并不会在磁盘上将其切分成片进行存储。</p><p><img src="http://47.103.115.69/pic/数据切片与MapTask并行度决定机制.png" alt="img"></p><h3 id="3-6-3-FileInputFormat切片源码解析："><a href="#3-6-3-FileInputFormat切片源码解析：" class="headerlink" title="3.6.3 FileInputFormat切片源码解析："></a>3.6.3 FileInputFormat切片源码解析：</h3><p>重点：</p><p>默认情况：切片大小= blocksize</p><p>每次切片时，要判断切完剩余部分是否大于块的1.1倍，不大于1.1倍就划分1块切片</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/FileInputFormat切片源码解析.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>切片时不考虑数据集整体，而是<strong>逐个对每一个文件单独切片</strong>。</p><h3 id="3-6-4-FileInputFormat切片大小的参数配置"><a href="#3-6-4-FileInputFormat切片大小的参数配置" class="headerlink" title="3.6.4 FileInputFormat切片大小的参数配置"></a>3.6.4 FileInputFormat切片大小的参数配置</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/FileInputFormat切片大小的参数配置.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h3 id="3-6-5-CombineTextInputFormat切片机制"><a href="#3-6-5-CombineTextInputFormat切片机制" class="headerlink" title="3.6.5 CombineTextInputFormat切片机制"></a>3.6.5 CombineTextInputFormat切片机制</h3><p>框架默认的TextInputFormat切片机制是对任务按文件规划切片，<strong>不管文件多小，都会是一个单独的切片</strong>，都会交给一个MapTask，这样如果有大量小文件，就会<strong>产生大量的MapTask</strong>，处理<strong>效率极其低下</strong>。</p><p>1、应用场景：</p><p><strong>CombineTextInputFormat</strong>用于小文件过多的场景，它可以将多个小文件从逻辑上规划到一个切片中，这样，多个小文件就可以交给一个MapTask处理。</p><p>2、虚拟存储切片最大值设置</p><p><strong>CombineTextInputFormat.setMaxInputSplitSize(job, 4194304)</strong>;// 4m</p><p>注意：虚拟存储切片最大值设置最好根据实际的小文件大小情况来设置具体的值。</p><p>3、切片机制</p><p>生成切片过程包括：虚拟存储过程和切片过程二部分。！！！！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/CombineTextInputFormat切片机制.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h2 id="3-6-MapReduce详细工作流程"><a href="#3-6-MapReduce详细工作流程" class="headerlink" title="3.6 MapReduce详细工作流程"></a>3.6 MapReduce详细工作流程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\jo\AppData\Roaming\Typora\typora-user-images\1568639170123.png" alt="1568639170123" title>                </div>                <div class="image-caption">1568639170123</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="C:\Users\jo\AppData\Roaming\Typora\typora-user-images\1568639177258.png" alt="1568639177258" title>                </div>                <div class="image-caption">1568639177258</div>            </figure><h2 id="3-7-Shuffle机制"><a href="#3-7-Shuffle机制" class="headerlink" title="3.7 Shuffle机制"></a>3.7 Shuffle机制</h2><h3 id="3-7-1-Partition分区"><a href="#3-7-1-Partition分区" class="headerlink" title="3.7.1 Partition分区"></a>3.7.1 Partition分区</h3><p>1、问题引出</p><p>要求将统计结果<strong>按照条件输出到不同文件中</strong>（分区）。比如：将统计结果按照手机归属地不同省份输出到不同文件中（分区）</p><p>2、默认Partitioner分区</p><p>Map方法之后，Reduce方法之前的数据处理过程称之为Shuffle。如图4-14所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/shuffle机制.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h3 id="3-7-2-WritableComparable排序"><a href="#3-7-2-WritableComparable排序" class="headerlink" title="3.7.2 WritableComparable排序"></a>3.7.2 WritableComparable排序</h3><p>排序概述：</p><blockquote><p>​    排序是MapReduce框架中最重要的操作之一。</p><p>​    MapTask和ReduceTask均会对数据按照Key进行排序。该操作属于Hadoop的默认行为。任何应用程序中的数据均会被排序，而不管逻辑上是否需要。</p><p>​    默认排序是按照字典顺序排序，且实现该排序的方法是快速排序。</p><p>​    对于MapTask，它会将处理的结果暂时放到环形缓冲区中，当环形缓冲区使用率达到一定阈值后，再对缓冲区中的数据进行一次快速排序，并将这些有序数据溢写到磁盘上，而当数据处理完毕后，它会对磁盘上所有文件进行归并排序。</p><p>​    对于ReduceTask，它从每个MapTask上远程拷贝相应的数据文件，如果文件大小超过一定阈值，则溢写磁盘上，否则存储在内存中。如果磁盘上文件数目达到一定阈值，则进行一次归并排序以生成一个更大文件；如果内存中文件大小或者数目超过一定阈值，则进行一次合并后将数据溢写到磁盘上。当所有数据拷贝完毕后，ReduceTask统一对内存和磁盘上的所有数据进行一次归并排序。</p></blockquote><p>排序的分类</p><blockquote><p>​    1、部分排序</p><p>​    MapReduce根据输入记录的键对数据集排序。保证输出的每个文件内部有序。</p><p>​    2、全排序</p><p>​    最终输出结果只有一个文件，且文件内部有序。实现方法是只设置一个ReduceTask。但该方法在处理大型文件时效率极低，因为一台机器处理所有文件，完全丧失了MapReduce所提供的并行架构。</p><p>​    3、辅助排序（GroupingComparator分组）</p><p>​    在Reduce端对key进行分组。应用于：在接收的key为bean对象时，想让一个或几个字段相同（全部字段比较不相同）的key进入到同一个reduce方法时，可以采用分组排序。</p><p>​    4、二次排序</p><p>​    在自定义排序过程中，如果compareTo中的判断条件为两个即为二次排序。</p></blockquote><p>1、实现全排序</p><p>2、实现区内排序</p><h3 id="3-7-3-Combiner合并"><a href="#3-7-3-Combiner合并" class="headerlink" title="3.7.3 Combiner合并"></a>3.7.3 Combiner合并</h3><p>（1）Combiner是MR程序中Mapper和Reducer之外的一种组件。</p><p>（2）Combiner组件的父类就是Reducer</p><p>（3）Combiner和Reducer的区别在于运行的位置</p><p>Combiner是在每一个MapTask所在的节点运行</p><p>Reducer是接收全局所有Mapper的输出结果</p><p>（4）Combiner的意义就是对每一个MapTask的输出进行局部汇总，以减小网络传输量。</p><p>（5）Combiner能够应用的前提是不能影响最终的业务逻辑，而且Combiner的输出kv应该跟Reducer的输入kv类型对应起来。</p><p><strong>order举例</strong></p><h2 id="3-8-MapReduce-shuffle-工作机制（面试）"><a href="#3-8-MapReduce-shuffle-工作机制（面试）" class="headerlink" title="3.8 MapReduce +shuffle 工作机制（面试）"></a>3.8 MapReduce +shuffle 工作机制（面试）</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/MapTask工作机制.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>（1）Read阶段：MapTask通过用户编写的RecordReader，从输入InputSplit中解析出一个个key/value。</p><p>​       （2）Map阶段：该节点主要是将解析出的key/value交给用户编写map()函数处理，并产生一系列新的key/value。</p><p>​       （3）Collect收集阶段：在用户编写map()函数中，当数据处理完成后，一般会调用OutputCollector.collect()输出结果。在该函数内部，它会将生成的key/value分区（调用Partitioner），并写入一个环形内存缓冲区中。</p><p>​       （4）Spill阶段：即“溢写”，当环形缓冲区满后，MapReduce会将数据写到本地磁盘上，生成一个临时文件。需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作。</p><p>​       溢写阶段详情：</p><p>​       步骤1：利用快速排序算法对缓存区内的数据进行排序，排序方式是，先按照分区编号Partition进行排序，然后按照key进行排序。这样，经过排序后，数据以分区为单位聚集在一起，且同一分区内所有数据按照key有序。</p><p>​       步骤2：按照分区编号由小到大依次将每个分区中的数据写入任务工作目录下的临时文件output/spillN.out（N表示当前溢写次数）中。如果用户设置了Combiner，则写入文件之前，对每个分区中的数据进行一次聚集操作。</p><p>​       步骤3：将分区数据的元信息写到内存索引数据结构SpillRecord中，其中每个分区的元信息包括在临时文件中的偏移量、压缩前数据大小和压缩后数据大小。如果当前内存索引大小超过1MB，则将内存索引写到文件output/spillN.out.index中。</p><p>​       （5）Combine阶段：当所有数据处理完成后，MapTask对所有临时文件进行一次合并，以确保最终只会生成一个数据文件。</p><p>​       当所有数据处理完后，MapTask会将所有临时文件合并成一个大文件，并保存到文件output/file.out中，同时生成相应的索引文件output/file.out.index。</p><p>​       在进行文件合并过程中，MapTask以分区为单位进行合并。对于某个分区，它将采用多轮递归合并的方式。每轮合并io.sort.factor（默认10）个文件，并将产生的文件重新加入待合并列表中，对文件排序后，重复以上过程，直到最终得到一个大文件。</p><p>​       让每个MapTask最终只生成一个数据文件，可避免同时打开大量文件和同时读取大量小文件产生的随机读取带来的开销。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/Reduece工作机制.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>（1）Copy阶段：ReduceTask从各个MapTask上远程拷贝一片数据，并针对某一片数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。</p><p>​       （2）Merge阶段：在远程拷贝数据的同时，ReduceTask启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多。</p><p>​       （3）Sort阶段：按照MapReduce语义，用户编写reduce()函数输入数据是按key进行聚集的一组数据。为了将key相同的数据聚在一起，Hadoop采用了基于排序的策略。由于各个MapTask已经实现对自己的处理结果进行了局部排序，因此，ReduceTask只需对所有数据进行一次归并排序即可。</p><p>​       （4）Reduce阶段：reduce()函数将计算结果写到HDFS上。</p><h2 id="3-9-Join多种应用"><a href="#3-9-Join多种应用" class="headerlink" title="3.9 Join多种应用"></a>3.9 Join多种应用</h2><h3 id="3-9-1-Reduce-Join"><a href="#3-9-1-Reduce-Join" class="headerlink" title="3.9.1 Reduce Join"></a>3.9.1 Reduce Join</h3><p>1、Reduce Join工作原理：</p><blockquote><p>​     Map端的主要工作：为来自不同表或文件的key/value对，<strong>打标签以区别不同来源的记录</strong>。然后用连接字段作为key，其余部分和新加的标志作为value，最后进行输出。</p><p>​    Reduce端的主要工作：在Reduce端以连接字段作为key的分组已经完成，我们只需要在每一个分组当中<strong>将那些来源于不同文件的记录（在Map阶段已经打标志）分开</strong>，最后进行合并就OK了。</p></blockquote><p>2、缺点及解决方案</p><blockquote><p>​    缺点：这种方式中，合并的操作是在Reduce阶段完成，Reduce端的处理压力太大，Map节点的运算负载则很低，资源利用率不高，且在Reduce阶段极易产生数据倾斜。</p><p>​    解决方案：Map端实现数据合并</p></blockquote><h3 id="3-9-2-Map-Join"><a href="#3-9-2-Map-Join" class="headerlink" title="3.9.2 Map Join"></a>3.9.2 Map Join</h3><blockquote><p>1．使用场景</p><p>Map Join适用于一张表十分小、一张表很大的场景。</p><p>2．优点</p><p>思考：在Reduce端处理过多的表，非常容易产生数据倾斜。怎么办？</p><p>在Map端缓存多张表，提前处理业务逻辑，这样增加Map端业务，减少Reduce端数据的压力，尽可能的减少数据倾斜。</p><p>3．具体办法：采用DistributedCache</p><p>​       （1）在Mapper的setup阶段，将文件读取到缓存集合中。</p><p>​       （2）在驱动函数中加载缓存。</p><p>// 缓存普通文件到Task运行节点。</p><p>job.addCacheFile(new URI(“file://e:/cache/pd.txt”));</p></blockquote><h2 id="3-10-计数器应用"><a href="#3-10-计数器应用" class="headerlink" title="3.10 计数器应用"></a>3.10 计数器应用</h2><p>hadoop为每个作业维护若干内置计数器，以描述多项指标。例如，某些计数器记录已处理的字节数和记录数，使用户可监控已处理的输入数据量和已产生的输出数据量</p><p>1、计数器API</p><p>（1）采用枚举的方式统计计数</p><p>（2）采用计数器组、计数器名称的方式统计</p><p>（3）计数结果在程序运行后的控制台上查看。</p><h2 id="3-11-数据清洗（ETL）"><a href="#3-11-数据清洗（ETL）" class="headerlink" title="3.11 数据清洗（ETL）"></a>3.11 数据清洗（ETL）</h2><h2 id="3-12-Hadoop数据压缩"><a href="#3-12-Hadoop数据压缩" class="headerlink" title="3.12 Hadoop数据压缩"></a>3.12 Hadoop数据压缩</h2><h3 id="3-12-1-压缩概念"><a href="#3-12-1-压缩概念" class="headerlink" title="3.12.1 压缩概念"></a>3.12.1 压缩概念</h3><p>压缩概述：</p><blockquote><p>压缩技术能够有效减少底层存储系统（HDFS）读写字节数。压缩提高了网络带宽和磁盘空间的效率。在运行MR程序时，I/O操作、网络数据传输、Shuffle和Merge要花大量的时间，尤其是<strong>数据规模很大和工作负载密集的情况下</strong>，因此，使用数据压缩显得非常重要。</p><p>数据压缩对于节省资源、最小化磁盘I/O和网络传输非常有帮助。可以在任意MapReduce阶段启动压缩。</p></blockquote><p>压缩策略和原则</p><blockquote><p><strong>优化策略</strong></p><p>通过对Mapper、Reducer运行过程的数据进行压缩，以减少磁盘IO，提高MR程序运行速度。</p><p>注意：采用压缩技术减少了磁盘IO，但同时也增加了CPU运算负担。所以，压缩特性运用得当能提高性能，但运用不当也可能降低性能。</p><p><strong>压缩原则</strong>：</p><p>1、运算密集型的job，少用压缩</p><p>2、IO密集型的job，多用压缩</p></blockquote><h3 id="3-12-2-MR支持的压缩编码"><a href="#3-12-2-MR支持的压缩编码" class="headerlink" title="3.12.2 MR支持的压缩编码"></a>3.12.2 MR支持的压缩编码</h3><table><thead><tr><th>压缩格式</th><th>hadoop自带？</th><th>算法</th><th>文件扩展名</th><th>是否可切分</th><th>换成压缩格式后，原来的程序是否需要修改</th></tr></thead><tbody><tr><td>DEFLATE</td><td>是，直接使用</td><td>DEFLATE</td><td>.deflate</td><td>否</td><td>和文本处理一样，不需要修改</td></tr><tr><td>Gzip</td><td>是，直接使用</td><td>DEFLATE</td><td>.gz</td><td>否</td><td>和文本处理一样，不需要修改</td></tr><tr><td>bzip2</td><td>是，直接使用</td><td>bzip2</td><td>.bz2</td><td>是</td><td>和文本处理一样，不需要修改</td></tr><tr><td>LZO</td><td>否，需要安装</td><td>LZO</td><td>.lzo</td><td>是</td><td>需要建索引，还需要指定输入格式</td></tr><tr><td>Snappy</td><td>否，需要安装</td><td>Snappy</td><td>.snappy</td><td>否</td><td>和文本处理一样，不需要修改</td></tr></tbody></table><p>为了支持多种压缩/解压缩算法，Hadoop引入了编码/解码器，如下表所示。</p><table><thead><tr><th>压缩格式</th><th>对应的编码/解码器</th></tr></thead><tbody><tr><td>DEFLATE</td><td>org.apache.hadoop.io.compress.DefaultCodec</td></tr><tr><td>gzip</td><td>org.apache.hadoop.io.compress.GzipCodec</td></tr><tr><td>bzip2</td><td>org.apache.hadoop.io.compress.BZip2Codec</td></tr><tr><td>LZO</td><td>com.hadoop.compression.lzo.LzopCodec</td></tr><tr><td>Snappy</td><td>org.apache.hadoop.io.compress.SnappyCodec</td></tr></tbody></table><p>压缩性能的比较</p><table><thead><tr><th>压缩算法</th><th>原始文件大小</th><th>压缩文件大小</th><th>压缩速度</th><th>解压速度</th></tr></thead><tbody><tr><td>gzip</td><td>8.3GB</td><td>1.8GB</td><td>17.5MB/s</td><td>58MB/s</td></tr><tr><td>bzip2</td><td>8.3GB</td><td>1.1GB</td><td>2.4MB/s</td><td>9.5MB/s</td></tr><tr><td>LZO</td><td>8.3GB</td><td>2.9GB</td><td>49.3MB/s</td><td>74.6MB/s</td></tr></tbody></table><p><a href="http://google.github.io/snappy/" target="_blank" rel="noopener">http://google.github.io/snappy/</a></p><p>On a single core of a Core i7 processor in 64-bit mode, Snappy compresses at about 250 MB/sec or more and decompresses at about 500 MB/sec or more.</p><h3 id="3-12-3-压缩方式选择"><a href="#3-12-3-压缩方式选择" class="headerlink" title="3.12.3 压缩方式选择"></a>3.12.3 压缩方式选择</h3><p>Gzip压缩：</p><blockquote><p>优点：压缩率比较高，压缩/解压速度快；hadoop本身支持，在应用中处理Gzip格式的文件就和直接处理文本一样；大部分Linux系统都自带Gzip命令，使用方便。</p><p>缺点：不支持split。</p><p>应用场景：<strong>当每个文件压缩之后130M以内的（1个块大小内），都可以考虑Gzip压缩格式</strong>。例如说一天或者一个小时的日志压缩成一个Gzip文件。</p></blockquote><p>Bzip2压缩：</p><blockquote><p>优点：支持split，具有很高的压缩率，比Gzip压缩率都高；Hadoop本身自带，使用方便。</p><p>缺点：压缩/解压速度慢。</p><p>应用场景：适合<strong>对速度要求不高，但需要较高的压缩率的时候</strong>；或者<strong>输出之后的数据比较大</strong>，处理之后的数据需要压缩存档减少磁盘空间并以后数据用得比较少的情况；或者对<strong>单个很大的文本文件想压缩减少存储空间</strong>，同时又需要支持split，而且兼容之前的应用程序的情况。</p></blockquote><p>Lzo</p><blockquote><p>优点：<strong>压缩/解压速度也比较快</strong>，合理的压缩率，支持split，是Hadoop中最流行的压缩格式；可以在linux系统下安装lzop命令，使用方便。</p><p>缺点：压缩率比Gzip要低一些；Hadoop本身不支持，需要安装；在应用中对Lzo格式的文件需要做一些特殊处理（为了支持split需要建索引，还需要指定InputFormat为Lzo格式）。</p><p>应用场景：<strong>一个很大的文本文件，压缩之后还大于200M以上的可以考虑，而且单个文件越大，Lzo优点越明显</strong>。</p></blockquote><p>Snappy</p><blockquote><p>优点：高速压缩速度和合理的压缩率。</p><p>缺点：不支持Split；压缩率比Gzip要低；Hadoop本身不支持，需要安装。</p><p>应用场景：<strong>当MapReduce作业的Map输出的数据比较大的时候，作为Map到Reduce的中间数据</strong>的压缩格式；或者<strong>作为一个MapReduce作业的输出和另一个MapReduce作业的输入。</strong></p></blockquote><h3 id="3-12-4-压缩位置的选择"><a href="#3-12-4-压缩位置的选择" class="headerlink" title="3.12.4 压缩位置的选择"></a>3.12.4 压缩位置的选择</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/MapReduce数据压缩" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h1 id="5、Yarn资源调度器"><a href="#5、Yarn资源调度器" class="headerlink" title="5、Yarn资源调度器"></a>5、Yarn资源调度器</h1><p><strong>Yarn</strong>是一个资源调度平台，负责为运算程序<strong>提供服务器运算资源</strong>，相当于一个分布式操作系统平台，而<strong>MapReduce</strong>等运算程序则相当于运行于<strong>操作系统之上的应用程序</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/Yarn架构" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p><img src="http://47.103.115.69/pic/Yarn工作机制" alt="img"></p><p>工作机制详解</p><p>​       （1）MR程序提交到客户端所在的节点。</p><p>​       （2）YarnRunner向ResourceManager申请一个Application。</p><p>​       （3）RM将该应用程序的资源路径返回给YarnRunner。</p><p>​       （4）该程序将运行所需资源提交到HDFS上。</p><p>​       （5）程序资源提交完毕后，申请运行mrAppMaster。</p><p>​       （6）RM将用户的请求初始化成一个Task。</p><p>​       （7）其中一个NodeManager领取到Task任务。</p><p>​       （8）该NodeManager创建容器Container，并产生MRAppmaster。</p><p>​       （9）Container从HDFS上拷贝资源到本地。</p><p>​       （10）MRAppmaster向RM 申请运行MapTask资源。</p><p>​       （11）RM将运行MapTask任务分配给另外两个NodeManager，另两个NodeManager分别领取任务并创建容器。</p><p>​       （12）MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动MapTask，MapTask对数据分区排序。</p><p>​        （13）MrAppMaster等待所有MapTask运行完毕后，向RM申请容器，运行ReduceTask。</p><p>​       （14）ReduceTask向MapTask获取相应分区的数据。</p><p>​       （15）程序运行完毕后，MR会向RM申请注销自己。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/作业提交过程之MapReduce" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h1 id="6、优化"><a href="#6、优化" class="headerlink" title="6、优化"></a>6、优化</h1><h2 id="6-1-MapReduce优化"><a href="#6-1-MapReduce优化" class="headerlink" title="6.1 MapReduce优化"></a>6.1 MapReduce优化</h2><p>MapReduce程序效率的瓶颈在于两点：</p><blockquote><p>1、计算机性能</p><p>​    CPU、内存、磁盘健康、网络</p><p>2、I/O操作优化</p><p>（1）数据倾斜</p><p>（2）Map和Reduce数设置不合理</p><p>（3）Map运行时间太长，导致Reduce等待过久</p><p>（4）小文件过多</p><p>（5）大量的不可分块超大文件</p><p>（6）Spill次数过多</p><p>（7）Merge次数过多等。</p></blockquote><p>优化方法：</p><p>1、数据输入</p><p>（1）<strong>合并小文件</strong>：在执行MR任务前将小文件进行合并，大量的小文件会产生大量的Map任务，增大Map任务装载次数，而任务的装载比较耗时，从而导致MR运行较慢。</p><p>（2）采用CombineTextInputFormat来作为输入，解决输入端大量小文件场景。</p><p>2、Map阶段</p><p>（1）<strong>减少溢写（Spill）次数</strong>：通过调整io.sort.mb及sort.spill.percent参数值，增大触发Spill的内存上限，减少Spill次数，从而减少磁盘IO.</p><p>（2）<strong>减少合并（Merge）次数</strong>：通过调整io.sort.factor参数，增大Merge的文件数目，减少Merge的次数，从而缩短MR处理时间。</p><p>（3）<strong>在Map之后，不影响业务逻辑前提下，先进行Combine处理，减少I/O</strong>。</p><p>3、Reduce阶段</p><p>（1）<strong>合理设置Map和Reduce数</strong>。</p><p>（2）<strong>设置Map、Reduce共存</strong>。调整slowstart.completedmaps参数，使Map运行到一定程度后，Reduce也开始运行，减少Reduce的等待时间。</p><p>（3）<strong>规避使用Reduce</strong>：因为Reduce在用于连接数据集的时候将会产生大量的网络消耗。</p><p>（4）<strong>合理设置Reduce端的Buffer</strong>。</p><p>4、I/O传输</p><p>（1）<strong>采用数压缩的方式</strong></p><p>（2）<strong>使用SequenceFile二进制文件</strong></p><p>5、数据倾斜问题</p><blockquote><p>1）数据倾斜现象</p><p>数据频率倾斜——某一个区域的数据量要远远大于其他区域。</p><p>数据大小倾斜——部分记录的大小远远大于平均值。</p><p>2）减少数据倾斜的方法</p><p>1）抽样和范围分区</p><p>2）自定义分区</p><p>3）Combine</p><p>4）采用Map Join， 尽量避免Reduce Join。</p></blockquote><h2 id="6-2HDFS小文件优化"><a href="#6-2HDFS小文件优化" class="headerlink" title="6.2HDFS小文件优化"></a>6.2HDFS小文件优化</h2><h3 id="6-2-1-HDFS小文件弊端"><a href="#6-2-1-HDFS小文件弊端" class="headerlink" title="6.2.1 HDFS小文件弊端"></a>6.2.1 HDFS小文件弊端</h3><p>HDFS上每个文件都要在NameNode上建立一个索引，这个索引的大小约为150byte，这样当小文件比较多的时候，就会产生很多的索引文件，<strong>一方面会大量占用NameNode的内存空间，另一方面就是索引文件过大使得索引速度变慢。</strong></p><h3 id="6-2-2-HDFS小文件解决方案"><a href="#6-2-2-HDFS小文件解决方案" class="headerlink" title="6.2.2 HDFS小文件解决方案"></a>6.2.2 HDFS小文件解决方案</h3><p>小文件的优化无非以下几种方式：</p><p>（1）在数据采集的时候，就将小文件或小批数据合成大文件再上传HDFS。</p><p>（2）在业务处理之前，在HDFS上使用MapReduce程序对小文件进行合并。</p><p>（3）在MapReduce处理时，可采用CombineTextInputFormat提高效率。</p><h1 id="1、MAVEN内存溢出"><a href="#1、MAVEN内存溢出" class="headerlink" title="1、MAVEN内存溢出!"></a>1、MAVEN内存溢出!</h1><p>（1）MAVEN install时候JVM内存溢出</p><p>处理方式：在环境配置文件和maven的执行文件均可调整MAVEN_OPT的heap大小。（详情查阅MAVEN 编译 JVM调优问题，如：<a href="http://outofmemory.cn/code-snippet/12652/maven-outofmemoryerror-method）" target="_blank" rel="noopener">http://outofmemory.cn/code-snippet/12652/maven-outofmemoryerror-method）</a></p><p>（2）编译期间maven报错。可能网络阻塞问题导致依赖库下载不完整导致，多次执行命令（一次通过比较难）：</p><p>[root@hadoop101 hadoop-2.7.2-src]#mvn package -Pdist,nativeN -DskipTests -Dtar</p><p>（3）报ant、protobuf等错误，插件下载未完整或者插件版本问题，最开始链接有较多特殊情况，同时推荐</p><p>DataNode和NameNode进程同时只能工作一个。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/clusterId不统一.png" alt="clusterId不统一" title>                </div>                <div class="image-caption">clusterId不统一</div>            </figure><p>10）执行命令不生效，粘贴word中命令时，遇到-和长–没区分开。导致命令失效</p><p>解决办法：尽量不要粘贴word中代码。</p><p>11）jps发现进程已经没有，但是重新启动集群，提示进程已经开启。原因是在linux的根目录下/tmp目录中存在启动的进程临时文件，将集群相关进程删除掉，再重新启动集群。</p><p>12）jps不生效。</p><p>原因：全局变量hadoop java没有生效。解决办法：需要source /etc/profile文件。</p><p>13）8088端口连接不上</p><p>[atguigu@hadoop102 桌面]$ cat /etc/hosts</p><p>注释掉如下代码</p><p>#127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</p><p>#::1         hadoop102</p><p>​                                                    </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、hadoop&quot;&gt;&lt;a href=&quot;#1、hadoop&quot; class=&quot;headerlink&quot; title=&quot;1、hadoop&quot;&gt;&lt;/a&gt;1、hadoop&lt;/h1&gt;&lt;h2 id=&quot;1-1-hadoop介绍&quot;&gt;&lt;a href=&quot;#1-1-hadoop介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 hadoop介绍&quot;&gt;&lt;/a&gt;1.1 hadoop介绍&lt;/h2&gt;&lt;p&gt;1）hadoop是一个由Apache基金会所开发的分布式系统基础架构。&lt;/p&gt;
&lt;p&gt;2）主要解决海量数据的存储和海量数据的分析计算问题。&lt;/p&gt;
&lt;p&gt;3）Hadoop生态圈&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue项目创建过程</title>
    <link href="https://xifujiang.github.io//posts/0/"/>
    <id>https://xifujiang.github.io//posts/0/</id>
    <published>2019-08-08T03:08:59.729Z</published>
    <updated>2020-01-13T06:48:16.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、Vue-项目创建过程"><a href="#1、Vue-项目创建过程" class="headerlink" title="1、Vue 项目创建过程"></a>1、Vue 项目创建过程</h1><h2 id="1-1项目搭建过程"><a href="#1-1项目搭建过程" class="headerlink" title="1.1项目搭建过程"></a>1.1项目搭建过程</h2><ul><li><p>创建项目</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> vue init webpack projectname</span><br></pre></td></tr></tbody></table></figure></li><li><p>运行项目</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> npm run dev</span><br></pre></td></tr></tbody></table></figure></li></ul><a id="more"></a><h2 id="1-2-遇到的问题解决方法"><a href="#1-2-遇到的问题解决方法" class="headerlink" title="1.2 遇到的问题解决方法"></a>1.2 遇到的问题解决方法</h2><p>新手创建时死机是经常出现的事，解决办法如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、清除缓存 npm clean --force （可能是这个，不太记得了）</span><br><span class="line">2、更新  npm install</span><br><span class="line">3、chromedriver无法下载，应该是谷歌退出中国网站不让访问，只能下载本地的网址。</span><br></pre></td></tr></tbody></table></figure><h2 id="1-3-项目前期准备"><a href="#1-3-项目前期准备" class="headerlink" title="1.3 项目前期准备"></a>1.3 项目前期准备</h2><p>举个栗子：</p><h3 id="1-3-1-新建前端界面"><a href="#1-3-1-新建前端界面" class="headerlink" title="1.3.1  新建前端界面"></a>1.3.1  新建前端界面</h3><p>前端页面开发页面组件存放于<strong>src\components</strong>文件夹中，新建一个Login组件。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">template</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">div</span>></span></span><br><span class="line">      用户名:<span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"loginForm.username"</span> <span class="attr">placeholder</span>=<span class="string">"请输入用户名"</span>/></span></span><br><span class="line">      <span class="tag"><<span class="name">br</span>></span><span class="tag"><<span class="name">br</span>></span></span><br><span class="line">      密码： <span class="tag"><<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">v-model</span>=<span class="string">"loginForm.password"</span> <span class="attr">placeholder</span>=<span class="string">"请输入密码"</span>/></span></span><br><span class="line">      <span class="tag"><<span class="name">br</span>></span><span class="tag"><<span class="name">br</span>></span></span><br><span class="line">      <span class="tag"><<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"login"</span>></span>登录<span class="tag"></<span class="name">button</span>></span></span><br><span class="line">  <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">template</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">script</span>></span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">  export default {</span></span><br><span class="line"><span class="undefined">    name: 'Login',</span></span><br><span class="line"><span class="undefined">    data () {</span></span><br><span class="line"><span class="undefined">      return {</span></span><br><span class="line"><span class="undefined">        loginForm: {</span></span><br><span class="line"><span class="undefined">          username: '',</span></span><br><span class="line"><span class="undefined">          password: ''</span></span><br><span class="line"><span class="undefined">        },</span></span><br><span class="line"><span class="undefined">        responseResult: []</span></span><br><span class="line"><span class="undefined">      }</span></span><br><span class="line"><span class="undefined">    },</span></span><br><span class="line"><span class="undefined">    methods: {</span></span><br><span class="line"><span class="undefined">      login () {</span></span><br><span class="line"><span class="undefined">        this.$axios</span></span><br><span class="line"><span class="undefined">          .post('/login', {</span></span><br><span class="line"><span class="undefined">            username: this.loginForm.username,</span></span><br><span class="line"><span class="undefined">            password: this.loginForm.password</span></span><br><span class="line"><span class="undefined">          })</span></span><br><span class="line"><span class="undefined">          .then(successResponse => {</span></span><br><span class="line"><span class="undefined">            if (successResponse.data.code === 200) {</span></span><br><span class="line"><span class="undefined">              this.$router.replace({path: '/index'})</span></span><br><span class="line"><span class="undefined">            }</span></span><br><span class="line"><span class="undefined">          })</span></span><br><span class="line"><span class="undefined">          .catch(failResponse => {</span></span><br><span class="line"><span class="undefined">          })</span></span><br><span class="line"><span class="undefined">      }</span></span><br><span class="line"><span class="undefined">    }</span></span><br><span class="line"><span class="undefined">  }</span></span><br><span class="line"><span class="undefined"></span><span class="tag"></<span class="name">script</span>></span></span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-2-前端相关配置——设置反向代理"><a href="#1-3-2-前端相关配置——设置反向代理" class="headerlink" title="1.3.2 前端相关配置——设置反向代理"></a>1.3.2 前端相关配置——设置反向代理</h3><p>修改 <strong>src\main.js</strong> 代码如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="comment">// 设置反向代理，前端请求默认发送到 http://localhost:8443/api</span></span><br><span class="line"><span class="keyword">var</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line">axios.defaults.baseURL = <span class="string">'http://localhost:8443/api'</span></span><br><span class="line"><span class="comment">// 全局注册，之后可在其他组件中通过 this.$axios 发送数据</span></span><br><span class="line">Vue.prototype.$axios = axios</span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue({</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: { App },</span><br><span class="line">  template: <span class="string">'<App/>'</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-3-前端相关配置——设置页面路由"><a href="#1-3-3-前端相关配置——设置页面路由" class="headerlink" title="1.3.3 前端相关配置——设置页面路由"></a>1.3.3 前端相关配置——设置页面路由</h3><p>修改 <strong>src\router\index.js</strong> 代码如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="comment">// 导入刚才编写的组件</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'@/components/Login'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router({</span><br><span class="line">  routes: [</span><br><span class="line">  <span class="comment">// 下面都是固定的写法</span></span><br><span class="line">    {</span><br><span class="line">      path: <span class="string">'/login'</span>,</span><br><span class="line">      name: <span class="string">'Login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="1-3-4-前端相关配置——跨域支持"><a href="#1-3-4-前端相关配置——跨域支持" class="headerlink" title="1.3.4 前端相关配置——跨域支持"></a>1.3.4 前端相关配置——跨域支持</h3><p>为了让后端能够访问到前端的资源，需要配置跨域支持。</p><p>在 <strong>config\index.js</strong> 中，找到 proxyTable 位置，修改为以下内容</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: {</span><br><span class="line">  <span class="string">'/api'</span>: {</span><br><span class="line">    target: <span class="string">'http://localhost:8443'</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">    pathRewrite: {</span><br><span class="line">      <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-4-各种-npm-安装"><a href="#1-4-各种-npm-安装" class="headerlink" title="1.4 各种 npm 安装"></a>1.4 各种 npm 安装</h3><h3 id="1-4-1-element安装与配置"><a href="#1-4-1-element安装与配置" class="headerlink" title="1.4.1 element安装与配置"></a>1.4.1 element安装与配置</h3><p>1、安装命令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></tbody></table></figure><p>2、main.js 中引入和使用ElementUI</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import ElementUI from 'element-ui'</span><br><span class="line">import 'element-ui/lib/theme-chalk/index.css'</span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1、Vue-项目创建过程&quot;&gt;&lt;a href=&quot;#1、Vue-项目创建过程&quot; class=&quot;headerlink&quot; title=&quot;1、Vue 项目创建过程&quot;&gt;&lt;/a&gt;1、Vue 项目创建过程&lt;/h1&gt;&lt;h2 id=&quot;1-1项目搭建过程&quot;&gt;&lt;a href=&quot;#1-1项目搭建过程&quot; class=&quot;headerlink&quot; title=&quot;1.1项目搭建过程&quot;&gt;&lt;/a&gt;1.1项目搭建过程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建项目&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt; vue init webpack projectname&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行项目&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt; npm run dev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git上传仓库步骤</title>
    <link href="https://xifujiang.github.io//posts/0/"/>
    <id>https://xifujiang.github.io//posts/0/</id>
    <published>2019-07-15T09:33:15.538Z</published>
    <updated>2020-01-13T02:46:41.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git上传仓库步骤"><a href="#git上传仓库步骤" class="headerlink" title="git上传仓库步骤"></a>git上传仓库步骤</h1><p>有关git上传仓库步骤，请享用。</p><a id="more"></a><ul><li>1、新建仓库</li><li>2、git config –global user.name “xxx”</li><li>3、git config –global user.email “xxx”</li><li>进入文件夹后初始化  git init</li><li>git add .</li><li>git pull –rebase 地址  //该步骤是复制之前的master，使得版本<strong>代码相同!!</strong></li><li>git commit -m “xxx1.version”</li><li>git push 地址 </li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;git上传仓库步骤&quot;&gt;&lt;a href=&quot;#git上传仓库步骤&quot; class=&quot;headerlink&quot; title=&quot;git上传仓库步骤&quot;&gt;&lt;/a&gt;git上传仓库步骤&lt;/h1&gt;&lt;p&gt;有关git上传仓库步骤，请享用。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hbase笔记</title>
    <link href="https://xifujiang.github.io//posts/346bfea7/"/>
    <id>https://xifujiang.github.io//posts/346bfea7/</id>
    <published>2019-05-09T07:36:00.000Z</published>
    <updated>2019-08-05T06:12:52.634Z</updated>
    
    <content type="html"><![CDATA[<p>通用命令</p><pre><code>status: 提供HBase的状态，例如，服务器的数量。version: 提供正在使用HBase版本。    table_help: 表引用命令提供帮助。whoami: 提供有关用户的信息。</code></pre><p>数据定义语言（表操作命令）。</p><a id="more"></a><pre><code>create: 创建一个表。list: 列出HBase的所有表。disable: 禁用表。is_disabled: 验证表是否被禁用。enable: 启用一个表。    is_enabled: 验证表是否已启用。describe: 提供了一个表的描述。alter: 改变一个表。exists: 验证表是否存在。drop: 从HBase中删除表。drop_all: 丢弃在命令中给出匹配“regex”的表。Java Admin API: 在此之前所有的上述命令，Java提供了一个通过API编程来管理实现DDL功能。在这个org.apache.hadoop.hbase.client包中有HBaseAdmin和HTableDescriptor 这两个重要的类提供DDL功能。</code></pre><p>数据操纵语言    </p><pre><code>put: 把指定列在指定的行中单元格的值在一个特定的表。get: 取行或单元格的内容。delete: 删除表中的单元格值。deleteall: 删除给定行的所有单元格。scan: 扫描并返回表数据。count: 计数并返回表中的行的数目。truncate: 禁用，删除和重新创建一个指定的表。Java client API: 在此之前所有上述命令，Java提供了一个客户端API来实现DML功能，CRUD（创建检索更新删除）操作更多的是通过编程，在org.apache.hadoop.hbase.client包下。 在此包HTable 的 Put和Get是重要的类。</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190509153139371/20190509033145167.png" alt="创建样本模式 列族" title>                </div>                <div class="image-caption">创建样本模式 列族</div>            </figure><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code>create 'emp', 'personal data', 'perfessional data'</code></pre><h3 id="更改列族单元格的最大数目"><a href="#更改列族单元格的最大数目" class="headerlink" title="更改列族单元格的最大数目"></a>更改列族单元格的最大数目</h3><pre><code>hbase> alter 't1', NAME => 'f1', VERSIONS => 5</code></pre><p>表范围运算符<br>    使用alter，可以设置和删除表范围，运算符，如MAX_FILESIZE，READONLY，MEMSTORE_FLUSHSIZE，DEFERRED_LOG_FLUSH等。</p><pre><code>#设置只读hbase>alter 't1', READONLY(option)</code></pre><p>alter ‘emp’, READONLY<br>alter ‘t1’, METHOD => ‘table_att_unset’, NAME => ‘MAX_FILESIZE’</p><h3 id="drop-在删除一个表之前必须先将其禁用。"><a href="#drop-在删除一个表之前必须先将其禁用。" class="headerlink" title="drop 在删除一个表之前必须先将其禁用。"></a>drop 在删除一个表之前必须先将其禁用。</h3><pre><code>hbase(main):018:0> disable 'emp'hbase(main):019:0> drop 'emp'</code></pre><h3 id="HBase创建数据"><a href="#HBase创建数据" class="headerlink" title="HBase创建数据"></a>HBase创建数据</h3><pre><code>put 命令,add() - Put类的方法put() - HTable 类的方法</code></pre><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190509153139371/20190509042637784.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>使用put命令，可以插入行到一个表。它的语法如下：</p><pre><code>put '<table name>', 'row1', '<colfamily:colname>','<value>'</code></pre><p>插入第一行</p><pre><code>put 'emp', '1','personal data:name','xifu'put 'emp', '1', 'personal data:city','taizhou'put 'emp', '1', 'perfessional data:designation','manager'put 'emp', '1', 'perfessional data:salary','50000'</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通用命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;status: 提供HBase的状态，例如，服务器的数量。
version: 提供正在使用HBase版本。    
table_help: 表引用命令提供帮助。
whoami: 提供有关用户的信息。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数据定义语言（表操作命令）。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python爬虫笔记</title>
    <link href="https://xifujiang.github.io//posts/65abd992/"/>
    <id>https://xifujiang.github.io//posts/65abd992/</id>
    <published>2019-03-28T06:34:00.000Z</published>
    <updated>2019-12-01T12:04:15.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、爬虫如何抓取网页数据"><a href="#一、爬虫如何抓取网页数据" class="headerlink" title="一、爬虫如何抓取网页数据"></a>一、爬虫如何抓取网页数据</h1><p>网页三大特征：<br>1、网页都有自己的唯一的URL（统一资源定位符）来进行定位。<br>2、网页都使用HTML(超文本标记语言)来描述页面信息。<br>3、网页都使用HTTP/HTTPS(超文本传输协议)协议来传输HTML数据。</p><a id="more"></a><p>爬虫的设计思路<br>1、首先确定需要爬取的网页URL地址。<br>2、通过HTTP/HTTP协议协议来获取对应的HTML页面。<br>3、提取HTML页面里有用的数据：<br>    a.如果是需要的数据，就保存起来。<br>    b.如果是页面里的其他URL，那就继续执行第二步。</p><p>#为什么选择Python做爬虫？<br>PHP：是世界上最好的语言，但他天生不是干爬虫的，对多线程，异步支持不够好。爬虫是工具性程序，对速度和效率的要求比较高。<br>Java爬虫生态圈很完善，是Python爬虫最大的对手。但是Java语言本身很笨重，代码量很大。爬虫经常需要修改部分采集代码，所以Java不合适。<br>C/C++运行效率和性能几乎最强，但是学习成本很高。代码成型比较慢。能用C/C++做爬虫，只能说是能力的表现，但不是正确的选择。<br>Python语法优美、代码简介、开发效率高、支持的模块多，相关HTTP请求模块<br>还有强大的爬虫Scrapy，以及成熟高效的scrapy-redis分布式策略。<br>而且，调用其他接口也非常方便（胶水语言）</p><h1 id="二、如何抓取HTML页面："><a href="#二、如何抓取HTML页面：" class="headerlink" title="二、如何抓取HTML页面："></a>二、如何抓取HTML页面：</h1><pre><code>HTTP请求的处理，urllib、urllib2、requests处理后的请求可以模拟浏览器发送请求，获取服务器响应的文件</code></pre><p>#解析服务器响应的内容<br>    re、xpath、BeautifulSoup4（bs4）、jsonpath、pyquery等<br>    使用某种描述性一样来给我们需要提取的数据定义一个匹配规则<br>    符合这个规则的数据就会被匹配</p><p>#如何采集动态HTML、验证码的处理<br>    通过动态页面采集，Selenium+PhantomJS(无界面)：模拟真实浏览器加载js、ajax等非静态的数据。<br>    Tesseract：机器学习库，机器图像识别系统，可以处理简单的验证码，复杂的验证码可以通过手动输入/专门的打码平台。<br>    sccrapy框架：（Scrapy，Pyspider）<br>        搞定制性高性能（异步网络框架 twisterd），所以数据下载速度非常快，提供了数据存储、数据下载、提取规则等组件。<br>    分布式策略：scrapy-redis，在Scrapy的基础上添加了一套以Redis数据库为核心的一套组件。让Scrapy框架支持分布式的功能。主要在Redis里做请求指纹去重、请求分配、数据临时存储。</p><h1 id="三、爬虫–反爬虫–反反爬虫-之间的斗争："><a href="#三、爬虫–反爬虫–反反爬虫-之间的斗争：" class="headerlink" title="三、爬虫–反爬虫–反反爬虫 之间的斗争："></a>三、爬虫–反爬虫–反反爬虫 之间的斗争：</h1><pre><code>其实怕重做到最后，最头疼的不是复杂的页面，也是灰色的数据，而是网站另一边的反爬虫人员。User-Agent、代理、验证码、动态数据加载、加密数据。数据价值、是否值的去费劲做反爬虫。1. 机器成本 + 人力成本 > 数据价值，就不反了，一般做到封IP就结束了。2、面子的战争......爬虫和反爬虫之间的斗争，最后一定是爬虫获胜。为什么？只要是真实用户可以浏览的网页数据，爬虫就一定能爬下来！</code></pre><p>#根据使用场景 分为 ：通用爬虫  聚焦爬虫<br>1通用爬虫：搜索引擎用的爬虫系统。<br>1、目标：就是尽可能吧互联网上所有的网页下载下来，放到本地服务器里形成备份；<br>    再对这些网页做相关处理（提取关键字、去掉广告），最后提供一个用户检索接口。<br>2、抓取流程：<br>    a） 首选选取一部分已有的URL，把这些URL放到待爬取队列。<br>    b） 从队列里取出这些URL，然后解析DNS得到主机IP，然后去这个IP对应的服务器里下载HTML页面，保存到搜索引擎的本地服务器。之后把这个爬过的URL放入已爬取队列。<br>    c）分析这些网页内容，找出网页里其他的URL链接，继续执行第二步，直到爬取条件结束。<br>3、搜索引擎如何获取一个新网站的URL:<br>    A).主动向搜索引擎提交网址,<br>    B).向其他网站里设置网站的外链。<br>    C).搜索引擎会和DNS服务商进行合作，可以快速收录新的网站。<br>    <code>DNS：就是把域名解析成IP的一种技术。</code><br>4、通用爬虫并不是万物皆可爬，它也需要遵守规则：<br>Robots协议：协议会指明通用爬虫可以爬取网页的权限。<br>Robots.txt 只是一个建议。并不是所有爬虫都遵守，一般只有大型的搜索引擎爬虫才会遵守。咱们个人写的爬虫，就不用管了。<br>5、通用爬虫工作流程：爬取网页 - 存储数据 - 内容处理 - 提供检索/排名服务<br>6、搜索引擎排名：<br>    ·PageRank值：根据网站的流量（点击量/浏览量/人气）统计，流量越高，网站越值钱，排名越靠前。<br>    ·竞价排名：谁给钱多，谁排名就高。<br>7、通用爬虫的缺点：<br>    1、只能提供和文本相关的内容（HTML、Word、PDF）等等，但是不能提供多媒体（音乐、图片、视频）和二进制文件（程序、脚本）等。<br>    2、提供的结果千篇一律，不能针对不同背景领域的人提供不同的搜索结果。<br>    3、不能理解人类语义上的检索。</p><p>2聚焦爬虫：爬虫程序员写的针对某种内容爬虫。<br>面向主题爬虫、面向需求爬虫：会针对某种特定的内容去爬取信息，而且会保证信息和需求息息相关。</p><p>http的端口号：80；<br>https的端口是：443；</p><p>Python自带的模块：/usr/lib/python2.7/urllib2.py</p><p>Python的第三方模块： /usr/local/lib/python2.7/site-packages</p><p>urllib2 默认的 User-Agent：Python-urllib/2.7</p><p>User-Agent: 是爬虫和反爬虫斗争的第一步，养成好习惯，发送请求带User-Agent</p><p>response 是服务器响应的类文件，除了支持文件操作的方法外，还支持以下常用的方法：</p><p><em>返回 HTTP的响应码，成功返回200，4服务器页面出错，5服务器问题</em></p><p>print response.getcode()</p><p><em>返回 返回实际数据的实际URL，防止重定向问题</em><br>print response.geturl()</p><p><em>返回 服务器响应的HTTP报头</em><br>print response.info()</p><h1 id="四、User-Agent-历史："><a href="#四、User-Agent-历史：" class="headerlink" title="四、User-Agent 历史："></a>四、User-Agent 历史：</h1><ul><li>Mosaic 世界上第一个浏览器：美国国家计算机应用中心</li><li>Netscape 网景：Netscape（支持框架），慢慢开始流行….(第一款支持框架的浏览器)</li><li>Microsoft 微软：Internet Explorer（也支持框架）</li><li>第一次浏览器大战：网景公司失败..消失</li><li>Mozilla 基金组织：Firefox 火狐 - （Gecko内核）(第一款浏览器内核)</li><li>User-Agent 决定用户的浏览器，为了获取更好的HTML页面效果。</li><li>IE开了个好头，大家都开就给自己披着了个 Mozilla 的外皮</li><li>Microsoft公司：IE（Trident）</li><li>Opera公司：Opera（Presto）</li><li>Mozilla基金会：Firefox（Gecko）</li><li>Linux组织：KHTML （like Gecko）</li><li>Apple公司：Webkit（like KHTML）</li><li>Google公司：Chrome（like webkit）</li><li>其他浏览器都是IE/Chrome内核</li></ul><h1 id="五、-Scrapy架构图（绿线是数据流向）："><a href="#五、-Scrapy架构图（绿线是数据流向）：" class="headerlink" title="五、 Scrapy架构图（绿线是数据流向）："></a>五、 Scrapy架构图（绿线是数据流向）：</h1><p>ScrapyEngine（引擎）：负责通讯，信号、数据传递</p><h3 id="制作Scrapy爬虫-四步骤："><a href="#制作Scrapy爬虫-四步骤：" class="headerlink" title="制作Scrapy爬虫 四步骤："></a>制作Scrapy爬虫 四步骤：</h3><ul><li>新建项目（scrapy startproject xxx）:新建一个新的爬虫项目</li><li>明确目标（编写items.py）：明确你想要爬取的目标</li><li>制作爬虫（spiders/xxspider.py）：制作爬虫开始爬取网页</li><li>存储内容（pipelines.py）：设计管道存储爬取内容</li></ul><p>创建爬虫项目<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#创建普通项目</span><br><span class="line">scrapy startproject 项目名</span><br><span class="line">#创建模板</span><br><span class="line">scrapy startproject 项目名  网站名</span><br></pre></td></tr></tbody></table></figure><p></p><h1 id="六、正则表达式"><a href="#六、正则表达式" class="headerlink" title="六、正则表达式"></a>六、正则表达式</h1><h2 id="1、规范"><a href="#1、规范" class="headerlink" title="1、规范"></a>1、规范</h2><table><thead><tr><th>表达式</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>.</td><td style="text-align:center">除了\n和\r的所有字符</td></tr><tr><td>\d</td><td style="text-align:center">数字</td></tr><tr><td>\D</td><td style="text-align:center">非数字</td></tr><tr><td>\w</td><td style="text-align:center">字母和下划线</td></tr><tr><td>\W</td><td style="text-align:center">非字母和下划线</td></tr><tr><td>\s</td><td style="text-align:center">空格（包括制表符、换页符等）</td></tr><tr><td>[a-z]</td><td style="text-align:center">小写英文字母</td></tr><tr><td>[a-zA-Z0-9]</td><td style="text-align:center">大小写英文字母与数字</td></tr><tr><td>[123]</td><td style="text-align:center">数字123</td></tr><tr><td>[^123]</td><td style="text-align:center">不是数字123</td></tr><tr><td>*</td><td style="text-align:center">出现次数>=0</td></tr><tr><td>+</td><td style="text-align:center">出现次数>=1</td></tr><tr><td>{n}</td><td style="text-align:center">出现次数=n</td></tr><tr><td>{n,m}</td><td style="text-align:center">m>=出现次数>=n</td></tr><tr><td>^</td><td style="text-align:center">以开头</td></tr><tr><td>$</td><td style="text-align:center">以结尾</td></tr><tr><td>?</td><td style="text-align:center">关闭贪婪模式</td></tr><tr><td>()</td><td style="text-align:center">用于获取括号内匹配成功的字符串</td></tr></tbody></table><h2 id="2、匹配div标签"><a href="#2、匹配div标签" class="headerlink" title="2、匹配div标签"></a>2、匹配div标签</h2><p>要取class=“class1”中的文本内容</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"class1"</span>></span>要匹配的内容<span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><p>正则表达</p><blockquote><p>div_pattern1=’<div class=”class1”(.*)</p><div>‘</div><p></p></blockquote><h2 id="3、xpath"><a href="#3、xpath" class="headerlink" title="3、xpath"></a>3、xpath</h2><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>/</td><td>根结点选取或下级</td></tr><tr><td>//</td><td>任意节点，不考虑位置</td></tr><tr><td>.</td><td>当前节点</td></tr><tr><td>..</td><td>当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr><tr><td>*</td><td>匹配任何节点</td></tr><tr><td>【nodename】</td><td>根据节点筛选</td></tr><tr><td>contains(@属性，“包含的内容”)</td><td>模糊查询</td></tr><tr><td>text()</td><td>文本内容</td></tr></tbody></table><p>注：XPath中的索引从1开始</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、爬虫如何抓取网页数据&quot;&gt;&lt;a href=&quot;#一、爬虫如何抓取网页数据&quot; class=&quot;headerlink&quot; title=&quot;一、爬虫如何抓取网页数据&quot;&gt;&lt;/a&gt;一、爬虫如何抓取网页数据&lt;/h1&gt;&lt;p&gt;网页三大特征：&lt;br&gt;1、网页都有自己的唯一的URL（统一资源定位符）来进行定位。&lt;br&gt;2、网页都使用HTML(超文本标记语言)来描述页面信息。&lt;br&gt;3、网页都使用HTTP/HTTPS(超文本传输协议)协议来传输HTML数据。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python笔记</title>
    <link href="https://xifujiang.github.io//posts/c00b24b1/"/>
    <id>https://xifujiang.github.io//posts/c00b24b1/</id>
    <published>2019-03-28T06:34:00.000Z</published>
    <updated>2019-08-05T06:13:14.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h1><p>1、ipython命令技能实现python命令，也能实现部分linux命令。<br>2、python2不能识别文件里的中文，如果硬要识别，在头文件中加上 -<em>- coding:utf-8 -</em>- （python官方推荐这种方式）<br>3、输入一个数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">high = input("请输入一个数")</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><p>4、输出一个数</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = 18</span><br><span class="line">print("age的值为%d"%age)</span><br><span class="line">name = "西芙"</span><br><span class="line">print("name的值为%s"%name);</span><br><span class="line">print("name的值是%s,年龄的值是%d"%(name,age))</span><br></pre></td></tr></tbody></table></figure><p>4、if else语句<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">age = 19</span><br><span class="line">if age>18:</span><br><span class="line">    print("已经成年")</span><br><span class="line">else</span><br><span class="line">    print("未成年")</span><br><span class="line">#input获取的所有数据都会当成字符串类型</span><br><span class="line">#python 规定 str（）>int()</span><br><span class="line">#所以如果 age  = input("一个值")</span><br><span class="line">#要与int比较，需要把age换成int类型，即</span><br><span class="line">#age_num = int(age)</span><br></pre></td></tr></tbody></table></figure><p></p><p>5、python语言是弱类型的编程语言，及赋值的时候已经知道是什么类型<br>6、查看变量类型</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type(a)</span><br></pre></td></tr></tbody></table></figure><p>7、python的变量类型<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">·Numbers(数字)： int(有符号整型)，long（长整型[也可代表八进制和十六进制]），float（浮点型），complex（复数）</span><br><span class="line">·布尔类型： True，False</span><br><span class="line">·String（字符串）</span><br><span class="line">·List（列表）</span><br><span class="line">·Tuple（元组）</span><br><span class="line">·Dictionary（字典）</span><br></pre></td></tr></tbody></table></figure><p></p><p>8、关键字<br>查看关键字命令</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import keyword #导入keyword包</span><br><span class="line">keyword.kwlist</span><br></pre></td></tr></tbody></table></figure><p>9、运算符</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"s"*10</span><br><span class="line">#输出'ssssssssss'</span><br><span class="line"></span><br><span class="line">#幂</span><br><span class="line">#**</span><br></pre></td></tr></tbody></table></figure><p>10、is是地址相同的意思，在数值-5到256间，a与b地址相同，其余不同<br>￼<br>11、深拷贝与浅拷贝<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#例1、浅拷贝</span><br><span class="line">a = [11, 22, 33]</span><br><span class="line">b = a #浅拷贝，地址拷贝，地址相同</span><br><span class="line"></span><br><span class="line">#例2、深拷贝</span><br><span class="line">import copy</span><br><span class="line">c = copy.deepcopy(a) #开辟一个内存空间，拷贝内容</span><br><span class="line"></span><br><span class="line">#例3、在数组中，深拷贝数组后，</span><br><span class="line">a = [11,22,33]</span><br><span class="line">b = [44,55,66]</span><br><span class="line">c = [a, b]</span><br><span class="line">d = copy.deepcopy[c]</span><br><span class="line">#查看c，d的id，并不相同，深拷贝</span><br><span class="line">#在a数组中添加[44],查看c[0],d[0]</span><br><span class="line">a.append(44)</span><br><span class="line">c[0]</span><br><span class="line">[11,22,33,44]</span><br><span class="line">d[0]</span><br><span class="line">[11,22,33]</span><br><span class="line">#说明深拷贝后，d另外拷贝了有关a、b的拷贝</span><br><span class="line"></span><br><span class="line">#例4、有关指向a，b的拷贝</span><br><span class="line">e = copy.copy(c)</span><br><span class="line">a.append(55)</span><br><span class="line">c[0]</span><br><span class="line">e[0]</span><br><span class="line">#所看到的结果都是[11,22,33,44,55]</span><br><span class="line">id(c)</span><br><span class="line">id(e)</span><br><span class="line">#所看到的地址不同，所以他们是指向不同的地址但所指向数组的内容地址是相同的</span><br><span class="line">#但如果是c = (a,b)，是元组的话，由于元组是不可变类型，e = copy.copy(c),他们所指向的地址是一样的</span><br><span class="line">#所以使用copy模块的copy功能时候，它会根据当前拷贝的数据类型是可变类型还是不可变类型有不同的处理方式</span><br></pre></td></tr></tbody></table></figure><p></p><p>12、私有化<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__num = 100</span><br><span class="line">    def setNum(self, newNum):</span><br><span class="line">        self.__num = newNum</span><br><span class="line">    def getNum(self):</span><br><span class="line">        return self.__num</span><br><span class="line">t = Test()</span><br><span class="line">t.__num = 200 #可以使用</span><br><span class="line">print(t.__num)</span><br></pre></td></tr></tbody></table></figure><p></p><p>升级版私有化 property使用<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__num = 100</span><br><span class="line">    def setNum(self, newNum):</span><br><span class="line">        self.__num = newNum</span><br><span class="line">    def getNum(self):</span><br><span class="line">        return self.__num</span><br><span class="line">    num = property(getNum, setNum)#!!!!</span><br><span class="line">#此时，可以用t.num = ?赋值 或者 t.num 取值，不用调用函数</span><br></pre></td></tr></tbody></table></figure><p></p><p>装饰器使用<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__num = 100</span><br><span class="line">    @property    </span><br><span class="line">    def num(self):</span><br><span class="line">        return self.__num</span><br><span class="line">    @num.setter    </span><br><span class="line">    def num(self, newNum):</span><br><span class="line">        self.__num = newNum</span><br><span class="line">#与上面的代码意思相同。理解一下吧~</span><br></pre></td></tr></tbody></table></figure><p></p><p>1、xx:公有变量<br>2、<em>x:单前置下划线，私有化属性或方法，from somemodule import * 禁止导入，类对象和子类可以访问<br>3、__x</em>:双前置下划线，避免与子类中的属性命名冲突，无法在外部直接访问（名字重整所以访问不到）<br>4、<strong>x</strong>：双前后下划线，用户名字空间的魔法对象或属性。例如<strong>init</strong>,__不要自己发明这样的名字<br>5、xx_:单后置下划线，用于避免与python关键词的冲突</p><p>###但是私有属性实际上是可以访问，python把私有属性的名字由原来的<strong>_私有属性名 改成  _类名</strong>私有属性名，所以可以通过对象._类名__私有属性名可以获取值！！！</p><p>13、迭代器<br><code>迭代器迭代器是访问集合元素的一种方式，迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，知道所有的元素被访问完结束。迭代器只能往前不会后退。</code><br><code>可迭代对象：可直接作用于for循环的数据类型有以下几种：一类是集合数据类型：如list、tuple、dict、set、str等一类是generator，包括生成器和带yield的generator function。可以直接作用于for循环的对象统称为可迭代对象：Iterable。</code></p><p>14、闭包：定义：函数里面有另外的函数，并且里面的函数用到了外面的函数的变量<br>闭包的应用：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def test(number):</span><br><span class="line">    print("--1--")</span><br><span class="line">    def test_in(number2):</span><br><span class="line">        print("--2--")</span><br><span class="line">        print(number+number2)</span><br><span class="line">    print("--3--")</span><br><span class="line">    return test_in</span><br><span class="line">    </span><br><span class="line">ret = test(100)</span><br><span class="line">print("-"*30)</span><br><span class="line">ret(1)</span><br><span class="line">ret(100)</span><br><span class="line">ret(200)</span><br><span class="line">#优点 简化了步骤</span><br></pre></td></tr></tbody></table></figure><p></p><p><code>linux快捷键： %s/^/#/g  所有行前面加#  1,14/#//g 去掉1-14行的#</code><br>15、装饰器<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def w1(func):</span><br><span class="line">    def inner():</span><br><span class="line">        print("----正在验证权限---")</span><br><span class="line">        func()</span><br><span class="line">    return inner</span><br><span class="line">def f1():</span><br><span class="line">    print("---f1---")</span><br><span class="line">def f2():</span><br><span class="line">    print("---f2---")</span><br><span class="line"></span><br><span class="line">#innerFunc = w1(f1)</span><br><span class="line">#innerFunc()</span><br><span class="line"></span><br><span class="line">f1 = w1(f1)    #把w1（f1）赋值给f1，也就是说f1 = w1.inner，f1指向的就是inner这个函数</span><br><span class="line">f1()   #调用后，执行的是inner，但由于之前传入f1的参数，所以输出结果为inner的输出结果+f1函数的输出结果</span><br><span class="line"></span><br><span class="line">@w1 #与上面f1=w1(f1)意义相同，但只要python执行器执行到了这个代码，name就会自动的进行装饰，而不是等到调用的时候才装饰的  语法糖 @w1</span><br><span class="line">def f1():</span><br><span class="line">    print("---f1---")</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#若有参数</span><br><span class="line">def func(functionName):</span><br><span class="line">    print("---func---1---")</span><br><span class="line">    def func_in(*args, **kwargs):#如果没有定义参数，会导致调用的时候出现问题</span><br><span class="line">        print("---func_in---1---")</span><br><span class="line">        functionName(*args, **kwargs)#传入同样的参数</span><br><span class="line">        print("---func_in---2---")      </span><br><span class="line">    print("---func---2---")</span><br><span class="line">    return func_in</span><br><span class="line">@func</span><br><span class="line">def test(a, b, c):</span><br><span class="line">    print("---test-a=%d,b=%d,c=%d---"%(a,b,c))</span><br><span class="line">    </span><br><span class="line">@func</span><br><span class="line">def test2(a, b, c, d):</span><br><span class="line">    print("---test-a=%d,b=%d,c=%d,d=%d---"%(a,b,c,d))</span><br><span class="line"></span><br><span class="line">test(11,22,33)</span><br><span class="line">test2(44,55,66,77)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#通用装饰器</span><br><span class="line">def func(functionName):</span><br><span class="line">    def func_in(*args, **kwargs):</span><br><span class="line">        print("---记录日志---")</span><br><span class="line">        ret = functionName(*args, **kwargs)</span><br><span class="line">        return ret</span><br><span class="line">    return func_in</span><br><span class="line"></span><br><span class="line">@func</span><br><span class="line">def test():</span><br><span class="line">    print("---test---")</span><br><span class="line">    return "haha"</span><br><span class="line"></span><br><span class="line">@func</span><br><span class="line">def test2():</span><br><span class="line">    print("---test2---")</span><br><span class="line"></span><br><span class="line">@func</span><br><span class="line">def test3(a):</span><br><span class="line">    print("---test3---a=%d--"%a)</span><br><span class="line">    </span><br><span class="line">ret = test()</span><br><span class="line">print("test return value is %s"%ret)</span><br><span class="line"></span><br><span class="line">a = test2()</span><br><span class="line">print("test2 return value is %s"%a)</span><br><span class="line"></span><br><span class="line">test3(11)</span><br></pre></td></tr></tbody></table></figure><p>16、作用域</p><p>#什么是命名空间<br>在某个范围内所能用到的作用域</p><p>17、类方法与静态方法<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#给类添加方法</span><br><span class="line">import types #导入types包</span><br><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, newName, newAge):</span><br><span class="line">        self.name = newName</span><br><span class="line">        self.age = newAge</span><br><span class="line">    </span><br><span class="line">    def eat(self):</span><br><span class="line">        print("-----%s正在吃----"%self.name)</span><br><span class="line"></span><br><span class="line">def run(self):</span><br><span class="line">    print("-----%s正在跑----"%self.name)</span><br><span class="line">    </span><br><span class="line">p1 = Person("p1", 10)</span><br><span class="line">p1.eat()</span><br><span class="line">p1.run = types.MethodType(run, p1)</span><br><span class="line">p1.run()</span><br></pre></td></tr></tbody></table></figure><p></p><p>18、限制class实例添加的属性<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    __slots__ = ("name", "age")</span><br><span class="line">p = Person()</span><br><span class="line">p.name = "老王"</span><br><span class="line">p.age = 20</span><br><span class="line">p.score = 100 #会报错！！！</span><br></pre></td></tr></tbody></table></figure><p></p><h1 id="二、生成器、迭代器、装饰器、闭包"><a href="#二、生成器、迭代器、装饰器、闭包" class="headerlink" title="二、生成器、迭代器、装饰器、闭包"></a>二、生成器、迭代器、装饰器、闭包</h1><p>19、生成器</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [1]: a = [x*2 for x in range(10)]</span><br><span class="line">In [2]: a</span><br><span class="line">Out[2]: [0, 2, 4, 5, 6, 10, 12, 14, 16, 18]</span><br><span class="line">#如果用[]，会生成数组，同时加载到内存中</span><br><span class="line">#如果用括号（），输出的是一个地址，需要时才提取出</span><br><span class="line">In [3]: b = (x*2 for x in range(10))</span><br><span class="line">In [4]: b</span><br><span class="line">Out[4]: <generator object <genexpr> at 0x7fb057ff06d0></span><br><span class="line">In [5]:next(b)</span><br><span class="line">Out[5]:0</span><br></pre></td></tr></tbody></table></figure><p>20、a，b交换<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def creatNum():</span><br><span class="line">    print("----start----")</span><br><span class="line">    a, b = 0, 1</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print("----1----")</span><br><span class="line">        yield b #python中有一个非常有用的语法叫做生成器，所利用到的关键字就是yield。有效利用生成器这个工具可以有效地节约系统资源，避免不必要的内存占用。当执行到这的时候，会做停顿。</span><br><span class="line">        print("----2----")</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        print("----3----")</span><br><span class="line">    print("----stop----")</span><br><span class="line">#创建了一个生成器对象</span><br><span class="line">a = creatNum()</span><br><span class="line">#实现交换</span><br><span class="line">a, b = 0, 1</span><br><span class="line">a, b = b, a</span><br></pre></td></tr></tbody></table></figure><p></p><p>21、斐波拉契数列<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a,b = 0, 1</span><br><span class="line">a,b = b, a+b #重复此步骤</span><br></pre></td></tr></tbody></table></figure><p></p><p>22、类当做装饰器<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line">class Test(object):</span><br><span class="line">    def __call__(self):</span><br><span class="line">        print("---test---")        </span><br><span class="line">t = Test()</span><br><span class="line">t()</span><br><span class="line">#out: ---test---</span><br><span class="line"></span><br><span class="line">#2</span><br><span class="line">class Test(object):</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        print('---初始化---')</span><br><span class="line">        print('func name is %s'func.__name__)</span><br><span class="line">        self.__func = func</span><br><span class="line">    def __call__(self):</span><br><span class="line">        print('---装饰器中的功能---')</span><br><span class="line">        self.__func()</span><br><span class="line"></span><br><span class="line">@Test  #相当于 t = Test(test)  </span><br><span class="line">def test():</span><br><span class="line">    print('---test---')</span><br><span class="line"></span><br><span class="line">#out: ---初始化---</span><br><span class="line">#out:func name is 'test'</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">#out: ---装饰器中的功能</span><br><span class="line">#out:---test---</span><br></pre></td></tr></tbody></table></figure><p></p><p>23、元类<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Test = type("Test", (), {})#相当于创建一个类</span><br><span class="line">Test</span><br><span class="line">#out:__main.Test</span><br><span class="line"></span><br><span class="line">#创建一个拥有属性num=0的Person类</span><br><span class="line">Person = type("Person",(),{"num":0})</span><br><span class="line"></span><br><span class="line">#创建一个拥有方法printNum()的Test3类</span><br><span class="line">def printNum(self):</span><br><span class="line">    print("--num-%d--"%self.num)</span><br><span class="line">Test3 = type("Test3",(),{"printNum":printNum})</span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#设置Foo类的属性变大写！！，通过metaclass设置</span><br><span class="line">def upper_attr(future_class_name, future_class_parents, future_class_attr):</span><br><span class="line">                #Foo                object                {bar:"bip"}</span><br><span class="line">    #遍历属性字典，把不是__开头的属性名字变成大写</span><br><span class="line">    newAttr = {}</span><br><span class="line">    for name, value in future_class_attr.items():</span><br><span class="line">        if not name.startswith("__"):</span><br><span class="line">            newAttr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">    #调用type创建一个类</span><br><span class="line">    return type(future_class_name,future_class_parents,newAttr)</span><br><span class="line"></span><br><span class="line">class Foo(object,metaclass=upper_attr):</span><br><span class="line">  #  __metaclass__ = upper_attr #设置Foo类的元类为upper_attr  python2</span><br><span class="line">    bar = "bip"</span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, "bar"))</span><br><span class="line">print(hasattr(Foo, "BAR"))</span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)</span><br><span class="line"></span><br><span class="line">#out:False</span><br><span class="line">#out:True</span><br><span class="line">#out:bip</span><br></pre></td></tr></tbody></table></figure><p>24、内建属性<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Itcast(object):</span><br><span class="line">    def __init__(self,subject1):</span><br><span class="line">        self.subject1 = subject1</span><br><span class="line">        self.subject2 = 'cpp'</span><br><span class="line">    #属性访问时拦截器，打log</span><br><span class="line">    def __getattribute__(self,obj): #obj-->"subject1"</span><br><span class="line">        if obj == 'subject1':</span><br><span class="line">            print('log subject1')</span><br><span class="line">            return 'redirect python'</span><br><span class="line">        else:</span><br><span class="line">            return object__getattribute__(self,obj)</span><br><span class="line">    </span><br><span class="line">    def show(self):</span><br><span class="line">        print('this is Itcast')</span><br><span class="line">        </span><br><span class="line">s = Itcast("python")</span><br><span class="line">print(s.subject1)</span><br><span class="line">print(s.subject2)</span><br></pre></td></tr></tbody></table></figure><p></p><h1 id="三、内建方法"><a href="#三、内建方法" class="headerlink" title="三、内建方法"></a>三、内建方法</h1><p>25、lambda之map<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#函数需要一个参数</span><br><span class="line">map(lambda x: x*x, [1, 2,3])</span><br><span class="line">#结果为：[1, 4, 9]</span><br><span class="line"></span><br><span class="line">#函数需要两个参数</span><br><span class="line">map(lambda x, y: x+y, [1, 2, 3], [4, 5, 6])</span><br><span class="line">#结果为:[5,7,9]</span><br><span class="line"></span><br><span class="line">def f1(x, y):</span><br><span class="line">    return (x, y)</span><br><span class="line">l1 = [0,1,2,3,4,5,6]</span><br><span class="line">l2 = ['Sun', 'M', 'T', 'W', 'T', 'F', 'S']</span><br><span class="line">l3 = map(f1, l1, l2)</span><br><span class="line">print(list(l3))</span><br><span class="line">结果为：[(0,'Sun'), (1,'M').....]</span><br></pre></td></tr></tbody></table></figure><p></p><p>26、lambda之filter<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fliter(lambda x : x%2, [1, 2 ,3, 4]) #如果为1，则输出</span><br><span class="line">[1, 3]</span><br><span class="line"></span><br><span class="line">filter(None, "she")</span><br><span class="line">'she'</span><br></pre></td></tr></tbody></table></figure><p></p><p>27、lambda之reduce<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reduce(lambda x, y: x+y, [1,2,3,4])</span><br><span class="line">10 #先把1赋值给x，2赋值给2，x+y后=3，把3赋值给x，数组中的3赋值给y，再累加，以此类推</span><br><span class="line"></span><br><span class="line">reduce(lambda x, y:x+y, [1,2,3,4], 5)</span><br><span class="line">15 #如果前面是数组，先把5赋值给x，再累加[1,,2,3,4]</span><br><span class="line"></span><br><span class="line">reduce(lambda x, y: x+y, ['aa', 'bb', 'cc'], 'dd')</span><br><span class="line">ddaabbcc</span><br></pre></td></tr></tbody></table></figure><p></p><p>28、sort<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [9,8,7,6,5,4,3,2,1]</span><br><span class="line">a.sort()</span><br><span class="line">a</span><br><span class="line">#[1,2,3,4,5,6,7,8,9]</span><br><span class="line"></span><br><span class="line">b = ['dd','cc','bb','aa']</span><br><span class="line">b.sort()</span><br><span class="line">b</span><br><span class="line">#['aa','bb','cc','dd']</span><br></pre></td></tr></tbody></table></figure><p></p><p>28、python的functools包中提供了一个叫wraps的装饰器来消除这样的副作用<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import functools</span><br><span class="line">def note(func):</span><br><span class="line">    "note function"</span><br><span class="line">    @functoolswraps(func)</span><br><span class="line">    def wrapper():</span><br><span class="line">        "wrapper function"</span><br><span class="line">        print("note something")</span><br><span class="line">        return func()</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@note</span><br><span class="line">def test():</span><br><span class="line">    "test function"</span><br><span class="line">    print('I am test')</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line">print(test.__doc__)</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、基本语法&quot;&gt;&lt;a href=&quot;#一、基本语法&quot; class=&quot;headerlink&quot; title=&quot;一、基本语法&quot;&gt;&lt;/a&gt;一、基本语法&lt;/h1&gt;&lt;p&gt;1、ipython命令技能实现python命令，也能实现部分linux命令。&lt;br&gt;2、python2不能识别文件里的中文，如果硬要识别，在头文件中加上 -&lt;em&gt;- coding:utf-8 -&lt;/em&gt;- （python官方推荐这种方式）&lt;br&gt;3、输入一个数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;high = input(&quot;请输入一个数&quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux复习</title>
    <link href="https://xifujiang.github.io//posts/0/"/>
    <id>https://xifujiang.github.io//posts/0/</id>
    <published>2019-03-28T06:34:00.000Z</published>
    <updated>2020-01-13T06:36:42.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h1 id="一、Linux起源"><a href="#一、Linux起源" class="headerlink" title="一、Linux起源"></a>一、Linux起源</h1><p>Linux系统诞生于1991年，由芬兰大学生李纳斯（Linux Torvalds）。</p><a id="more"></a><h1 id="二、命令"><a href="#二、命令" class="headerlink" title="二、命令"></a>二、命令</h1><h2 id="2-1文件处理命令"><a href="#2-1文件处理命令" class="headerlink" title="2.1文件处理命令"></a>2.1文件处理命令</h2><ul><li><p><code>ls （-lh...）</code> 查看当前目录</p><pre><code>-rw-r--r-- 1 root root 8690 3月 1 13:23 install.log.syslog1是引用计数（代表此文件被调用几次 引用几次） 文件所有者 文件所属组 字节文件大小 最后修改时间 文件名称-rw-r--r--- 文件类型（- 二进制文件 d目录 l软连接文件）rw- r-- r-- u   g   ou所有者 g所属组 o其他人r读 w写 x执行</code></pre></li><li><p><code>cd</code> 进入目录</p></li><li><code>pwd</code> 显示当前绝对路径</li><li><code>mkdir</code> </li></ul><h2 id="2-2网络通信命令"><a href="#2-2网络通信命令" class="headerlink" title="2.2网络通信命令"></a>2.2网络通信命令</h2><ul><li><code>ping</code> 测试网络连接</li><li><code>ifconfig</code> 显示或配置网络设备（网络接口卡）的命令 </li></ul><h2 id="2-3系统命令"><a href="#2-3系统命令" class="headerlink" title="2.3系统命令"></a>2.3系统命令</h2><ul><li><code>shutdown</code> 关机</li><li><code>reboot</code>  重启系统</li></ul><h2 id="2-3文本编辑器"><a href="#2-3文本编辑器" class="headerlink" title="2.3文本编辑器"></a>2.3文本编辑器</h2><ul><li><code>vim/vi</code></li></ul><h1 id="三、虚拟机安装"><a href="#三、虚拟机安装" class="headerlink" title="三、虚拟机安装"></a>三、虚拟机安装</h1><blockquote><p>CPU：建议主频为1GHz以上</p><p>内存：建议1GB以上</p><p>硬盘：建议分区空闲空间8GB以上</p></blockquote><h2 id="3-1Linux分区"><a href="#3-1Linux分区" class="headerlink" title="3.1Linux分区"></a>3.1Linux分区</h2><blockquote><p><strong>boot</strong>：400MB</p><p><strong>home 分区</strong>： 4G</p><p><strong>swap交换分区</strong>：2G 没有挂载点，就是没有盘符，swap不是给用户用的，是给操作系统或内科自己调用的 设置为2G 超过两个G就没有意义了</p><p><strong>逻辑分区 / 剩余所有空间</strong>：第四个分区，linux不知道要分几个区，所有先创建一个<code>sda5</code>（第一个逻辑分区），一块硬盘只能有4个分区是第四个默认为逻辑分区，三个主分区，一个逻辑分区</p></blockquote><h2 id="3-2系统磁盘分区"><a href="#3-2系统磁盘分区" class="headerlink" title="3.2系统磁盘分区"></a>3.2系统磁盘分区</h2><ul><li>基本分区（primary partion）</li><li>扩充分区（extension partion）</li></ul><p>基本分区和扩充分区的数目之和不能大于四个。且基本分区可以马上被使用单不能再分区。<br>扩充分区必须再进行分区后才能使用，也就是说它必须还要进行二次分区。<br>扩充分区下面是逻辑分区（logical partion），逻辑分区没有数量上的限制。</p><ul><li>主分区：最多只能有4个。</li><li>扩展分区：</li><li><ul><li>最多只能有1个。</li></ul></li><li><ul><li>主分区加扩展分区最多有4个。</li></ul></li><li><ul><li>不能写入数据，只能包含逻辑分区</li></ul></li></ul><h2 id="3-3分区格式化"><a href="#3-3分区格式化" class="headerlink" title="3.3分区格式化"></a>3.3分区格式化</h2><p>目的：为了给这个分区写入文件系统，也就是告诉我们的操作系统，如何去管理这个分区的数据。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/20190514043755683.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>分区：把大硬盘分为小的逻辑分区</li><li>格式化：写入文件系统</li><li>分区设备文件名：给每个分区定义设备文件名</li><li>挂载：给每个分区分配挂载点</li></ul><h1 id="四、虚拟机网络连接方式"><a href="#四、虚拟机网络连接方式" class="headerlink" title="四、虚拟机网络连接方式"></a>四、虚拟机网络连接方式</h1><ol><li>桥接模式</li><li>NAT模式</li><li>仅主机模式</li><li>自定义模式</li></ol><h2 id="4-1桥接模式"><a href="#4-1桥接模式" class="headerlink" title="4.1桥接模式"></a>4.1桥接模式</h2><blockquote><p>你的虚拟机是利用你的真实网卡，一块本地有线网卡(以太网)，一块是本地无线网卡（wlan）装完虚拟机后会出现两块虚拟网卡，一块vmnet1，一块vmnet8，如何选择桥接你的虚拟机将会利用你的网卡以太网或无线网卡和你的真实机进行通信</p><p>好处是配置简单，和你的真是机的ip地址设置同一网段，和真机进行通信，局域网的其他电脑也可以通信。</p><p>缺点占用同意网段的一个ip地址，在家里宿舍没有问题，在教室可能会和其他同学的ip地址冲突。</p></blockquote><h2 id="4-2NAT模式"><a href="#4-2NAT模式" class="headerlink" title="4.2NAT模式"></a>4.2NAT模式</h2><blockquote><p>你的虚拟机是通过VMnet8这块假的虚拟网卡和你的真实机连接</p></blockquote><h2 id="4-3仅主机模式"><a href="#4-3仅主机模式" class="headerlink" title="4.3仅主机模式"></a>4.3仅主机模式</h2><blockquote><p>你的虚拟机是通过VMnet1这块假的虚拟网卡和你的真实机连接。</p><p>桥接是不仅和你的真机通信还可以与你的局域网的其他机器通信，和一台笔记本是一个意思。<br>Nat hostonly 只能和你真机通信，不可以和局域网其他电脑通信，不用占用你的真实网段的一个ip地址。<br>Hostonly 只能和你计算机主机通信。<br>NAT和主机通信，如果你的主机可以联网，虚拟机也可以联网</p></blockquote><h2 id="4-4df盘符分区命令"><a href="#4-4df盘符分区命令" class="headerlink" title="4.4df盘符分区命令"></a>4.4df盘符分区命令</h2><p><code>df  （-h）</code><br>文件系统   1k-块   已用   可用    已用%    挂载点</p><h1 id="五、文件处理命令"><a href="#五、文件处理命令" class="headerlink" title="五、文件处理命令"></a>五、文件处理命令</h1><h2 id="5-1ls-查看目录下的文件"><a href="#5-1ls-查看目录下的文件" class="headerlink" title="5.1ls  查看目录下的文件"></a>5.1ls  查看目录下的文件</h2><ul><li>-a 显示所有文件，包括隐藏文件</li><li>-l 详细信息显示</li><li>-d 查看目录属性</li><li>-i Inode索引节点</li></ul><h2 id="5-2mkdir-创建目录"><a href="#5-2mkdir-创建目录" class="headerlink" title="5.2mkdir 创建目录"></a>5.2mkdir 创建目录</h2><ul><li>-p 创建递归</li></ul><h2 id="5-3cd-切换目录"><a href="#5-3cd-切换目录" class="headerlink" title="5.3cd  切换目录"></a>5.3cd  切换目录</h2><h2 id="5-4pwd-显示当前目录"><a href="#5-4pwd-显示当前目录" class="headerlink" title="5.4pwd 显示当前目录"></a>5.4pwd 显示当前目录</h2><h2 id="5-5rmdir-删除空目录"><a href="#5-5rmdir-删除空目录" class="headerlink" title="5.5rmdir 删除空目录"></a>5.5rmdir 删除空目录</h2><h2 id="5-6cp-复制文件或目录"><a href="#5-6cp-复制文件或目录" class="headerlink" title="5.6cp 复制文件或目录"></a>5.6cp 复制文件或目录</h2><ul><li><p>-rp 【源文件或目录】 【目标目录】</p></li><li><p>-r 复制目录</p></li><li><p>-p 保留文件属性</p></li></ul><h2 id="5-7clear-清屏操作"><a href="#5-7clear-清屏操作" class="headerlink" title="5.7clear 清屏操作"></a>5.7clear 清屏操作</h2><h2 id="5-8mv-剪切文件、改名"><a href="#5-8mv-剪切文件、改名" class="headerlink" title="5.8mv 剪切文件、改名"></a>5.8mv 剪切文件、改名</h2><h2 id="5-9rm-删除文件"><a href="#5-9rm-删除文件" class="headerlink" title="5.9rm 删除文件"></a>5.9rm 删除文件</h2><p>-r 删除目录</p><p>-f 强制执行</p><h2 id="5-10touch-创建空文件"><a href="#5-10touch-创建空文件" class="headerlink" title="5.10touch 创建空文件"></a>5.10touch 创建空文件</h2><h2 id="5-11cat-显示文件内容"><a href="#5-11cat-显示文件内容" class="headerlink" title="5.11cat 显示文件内容"></a>5.11cat 显示文件内容</h2><p>-n 显示行号</p><h2 id="5-12more-分页显示文件内容"><a href="#5-12more-分页显示文件内容" class="headerlink" title="5.12more 分页显示文件内容"></a>5.12more 分页显示文件内容</h2><p>(空格)或f 翻页</p><p>(Enter) 换行</p><p>q或Q 退出</p><h2 id="5-13less-分页显示文件内容"><a href="#5-13less-分页显示文件内容" class="headerlink" title="5.13less 分页显示文件内容"></a>5.13less 分页显示文件内容</h2><h2 id="5-14ln-生成链接文件"><a href="#5-14ln-生成链接文件" class="headerlink" title="5.14ln 生成链接文件"></a>5.14ln 生成链接文件</h2><blockquote><p>-s创建软连接</p><p>软链接特征：类似windows快捷方式</p><p>lrwxrwxrwxl软链接</p><p>文件大小——只是符号链接</p><p>/tmp/issue.soft -> /etc/issue 箭头指向源文件</p></blockquote><blockquote><p>硬链接特征：</p><p>1、拷贝cp -p + 同步更新</p><p>2、通过i节点识别</p><p>3、不能跨分区</p><p>4、不能针对目录使用</p></blockquote><h2 id="5-15shutdown命令"><a href="#5-15shutdown命令" class="headerlink" title="5.15shutdown命令"></a>5.15shutdown命令</h2><blockquote><p>-c 取消前一个关机命令</p><p>-h 关机</p><p>-r 重启</p></blockquote><h2 id="5-16vi-vim-建立、编辑、显示文本文件"><a href="#5-16vi-vim-建立、编辑、显示文本文件" class="headerlink" title="5.16vi/vim 建立、编辑、显示文本文件"></a>5.16vi/vim 建立、编辑、显示文本文件</h2><blockquote><p>vim是一个功能强大的全屏幕文本编辑器，是Linux/UNIX上最常用的文本编辑器，它的作用是建立、编辑、显示文本文件。</p><p>vim没有菜单，只有命令。</p></blockquote><ul><li>插入命令</li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">在光标所在字符后插入</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">在光标所在行尾插入</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">在光标所在字符前插入</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">在光标所在行行首插入</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">在光标下插入新行</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">在光标上插入新行</td></tr></tbody></table><ul><li>定位命令</li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">:set nu</td><td style="text-align:center">设置行号</td></tr><tr><td style="text-align:center">:set nonu</td><td style="text-align:center">取消行号</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">到第一行</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">到最后一行</td></tr><tr><td style="text-align:center">nG</td><td style="text-align:center">到第n行</td></tr><tr><td style="text-align:center">:n</td><td style="text-align:center">到第n行</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">移至行尾</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">移至行首</td></tr></tbody></table><ul><li>删除命令</li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">删除光标所在处字符</td></tr><tr><td style="text-align:center">nx</td><td style="text-align:center">删除光标所在处后n个字符</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">删除光标所在行，ndd删除n行</td></tr><tr><td style="text-align:center">dG</td><td style="text-align:center">删除光标所在行到文件末尾内容</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">删除光标所在处到行尾内容</td></tr><tr><td style="text-align:center">n1,n2d</td><td style="text-align:center">删除指定范围的行</td></tr></tbody></table><ul><li>复制和剪切命令</li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">yy</td><td style="text-align:center">复制当前行</td></tr><tr><td style="text-align:center">nyy</td><td style="text-align:center">复制当前行以下n行</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">剪切当前行</td></tr><tr><td style="text-align:center">ndd</td><td style="text-align:center">剪切当前行以下n行</td></tr><tr><td style="text-align:center">p、P</td><td style="text-align:center">粘贴在当前光标所在行下或行上</td></tr></tbody></table><ul><li>搜索和搜索替换命令</li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">/string</td><td style="text-align:center">搜索指定字符串 搜索时忽略大小写：set ic</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">搜索指定字符串的下一个出现位置</td></tr><tr><td style="text-align:center">:%s/old/new/g</td><td style="text-align:center">全文替换指定字符串</td></tr><tr><td style="text-align:center">:n1,n2s/old/new/g</td><td style="text-align:center">在一定范围内替换指定字符串</td></tr></tbody></table><ul><li>保存和退出命令</li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">:w</td><td style="text-align:center">保存修改</td></tr><tr><td style="text-align:center">:w new_filename</td><td style="text-align:center">另存为指定文件</td></tr><tr><td style="text-align:center">:wq</td><td style="text-align:center">保存修改并退出</td></tr><tr><td style="text-align:center">zz</td><td style="text-align:center">快捷键，保存修改并退出</td></tr><tr><td style="text-align:center">:q!</td><td style="text-align:center">不保存修改退出</td></tr><tr><td style="text-align:center">:wq!</td><td style="text-align:center">保存修改并退出（文件所有者及root可使用）</td></tr></tbody></table><h2 id="5-17-sort排序命令"><a href="#5-17-sort排序命令" class="headerlink" title="5.17 sort排序命令"></a>5.17 sort排序命令</h2><blockquote><p>sort [选项] 文件名</p><p>-f 忽略大小写</p><p>-n 以数值型进行排序</p><p>-r 反向排序</p><p>-t 指定分隔符，默认是分割符是制表符</p><p>-k n[,m] 按照指定的字段范围排序，从第n个开始，m字段结束（默认到行尾）</p></blockquote><h2 id="5-18-统计命令-wc"><a href="#5-18-统计命令-wc" class="headerlink" title="5.18 统计命令 wc"></a>5.18 统计命令 wc</h2><blockquote><p>wc [选项] 文件名</p><p>-l 只统计行数</p><p>-w 只统计单词数</p><p>-m 只统计字符数</p></blockquote><h2 id="5-19-awk-grep-sed"><a href="#5-19-awk-grep-sed" class="headerlink" title="5.19 awk grep sed"></a>5.19 awk grep sed</h2><table><thead><tr><th>grep</th><th>更适合单纯的查找或匹配文本</th></tr></thead><tbody><tr><td>sed</td><td>更适合编辑匹配到的文本</td></tr><tr><td>awk</td><td>更适合格式化文本，对文本进行较复杂的格式处理（算一门编程语言）</td></tr></tbody></table><h1 id="六、权限管理命令"><a href="#六、权限管理命令" class="headerlink" title="六、权限管理命令"></a>六、权限管理命令</h1><h2 id="6-1chmod-改变文件或目录（权限）"><a href="#6-1chmod-改变文件或目录（权限）" class="headerlink" title="6.1chmod  改变文件或目录（权限）"></a>6.1chmod  改变文件或目录（权限）</h2><ul><li>-R 递归修改</li><li>权限的数字表示 r——4 w——2 x——1</li><li>文件目录权限总结</li></ul><table><thead><tr><th>代表字符</th><th style="text-align:center">权限</th><th style="text-align:right">对文件的含义</th><th style="text-align:right">对目录的含义</th></tr></thead><tbody><tr><td>r</td><td style="text-align:center">读权限</td><td style="text-align:right">可以查看文件内容</td><td style="text-align:right">可以列出目录中的内容</td></tr><tr><td>w</td><td style="text-align:center">写权限</td><td style="text-align:right">可以修改文件内容</td><td style="text-align:right">可以在目录中创建、删除文件</td></tr><tr><td>x</td><td style="text-align:center">执行权限</td><td style="text-align:right">可以执行文件</td><td style="text-align:right">可以进入目录</td></tr></tbody></table><h2 id="6-2chown-改变文件或目录的（所有者）"><a href="#6-2chown-改变文件或目录的（所有者）" class="headerlink" title="6.2chown 改变文件或目录的（所有者）"></a>6.2chown 改变文件或目录的（所有者）</h2><h2 id="6-3chgrp-改变文件或目录的（所属组）"><a href="#6-3chgrp-改变文件或目录的（所属组）" class="headerlink" title="6.3chgrp 改变文件或目录的（所属组）"></a>6.3chgrp 改变文件或目录的（所属组）</h2><p>chgrp 【用户组】【文件或目录】</p><h2 id="6-4Groupadd-所有组名称新的命令"><a href="#6-4Groupadd-所有组名称新的命令" class="headerlink" title="6.4Groupadd 所有组名称新的命令"></a>6.4Groupadd 所有组名称新的命令</h2><h2 id="6-5umask-显示、设置文件的缺省权限"><a href="#6-5umask-显示、设置文件的缺省权限" class="headerlink" title="6.5umask 显示、设置文件的缺省权限"></a>6.5umask 显示、设置文件的缺省权限</h2><ul><li>umask -S 以rwx形式显示新建文件缺省权限</li><li><ul><li>在linux创建文件默认权限没有x权限，防止病毒可执行脚本</li></ul></li><li><ul><li>在linux创建目录默认权限有x</li></ul></li></ul><h1 id="七、文件搜索命令"><a href="#七、文件搜索命令" class="headerlink" title="七、文件搜索命令"></a>七、文件搜索命令</h1><h2 id="7-1find-【搜索范围】【匹配条件】"><a href="#7-1find-【搜索范围】【匹配条件】" class="headerlink" title="7.1find 【搜索范围】【匹配条件】"></a>7.1find 【搜索范围】【匹配条件】</h2><p>尽量不要使用linux里的find命令浪费资源特别是使用高峰期的时候，目录和文件合理的命名存放位置最重要。</p><ul><li>Find  路径 选项 关键字</li><li><ul><li>完全搜索 Find / -name a</li></ul></li><li><ul><li>模糊搜索 Find / -name <em>a</em></li></ul></li><li><ul><li>模糊搜索 Find / -name *a??</li></ul></li><li><ul><li>模糊搜索 Find / -iname *a??  （iname不区分大小写）</li></ul></li><li>Find -size +n -n n 查询文件大小 (+大于 -小于 什么都不写 =)</li><li>Find -user dj 根据所有者查找文件</li><li>find /etc -cmin -5  在/etc下查找5分钟内被修改过属性的文件和目录（+超过多长时间 -在多少分钟内）</li><li><ul><li>amin 访问时间 access</li></ul></li><li><ul><li>cmin 文件属性 change</li></ul></li><li><ul><li>mmin 文件内容 modify</li></ul></li></ul><h1 id="八、用户管理命令"><a href="#八、用户管理命令" class="headerlink" title="八、用户管理命令"></a>八、用户管理命令</h1><blockquote><p>简介：所以越是对服务器安全性要求高的服务器，<br>越需要建立合理的用户权限登记制度和服务器操作规范。<br>在linux中主要是通过用户配置文件来查看好修改用户信息。<br>1、添加更多的用户分配不同的权限。<br>2、通过配置文件添加信息，使用命令重启可能就消失了。</p></blockquote><h2 id="8-1用户配置文件——用户"><a href="#8-1用户配置文件——用户" class="headerlink" title="8.1用户配置文件——用户"></a>8.1用户配置文件——用户</h2><p>用户信息文件 /etc/passwd</p><blockquote><p>第1字段：用户名称<br>第2字段：密码标志<br>第3阶段：UID（用户ID）<br>    0：         超级用户<br>    1-499：     系统用户（伪用户）<br>    500-65535： 普通用户<br>第4字段：GID（用户初始组ID）<br>第5字段：用户说明<br>第6字段：家目录<br>    普通用户：/home/用户名/<br>    超级用户：/root/<br>第7字段：登录之后的Shell</p></blockquote><p>初始组和附加组</p><blockquote><p>初始组：就是指用户一登录就立刻拥有这个用户组的相关权限，每个用户的初始组只能有一个，一般就是和这个用户名相同的组名作为这个用户的初始组。</p><p>附加组：指用户可以加入多个其他的用户组，并拥有这些组的权限，附加组可以有多个。</p></blockquote><p>shell是什么？</p><blockquote><p>1、shell就是Linux的命令解释器<br>2、在/etc/passwd当中，除了标准shell是/bin/bash之外，还可以写如/sbin/nologin。</p></blockquote><h2 id="8-2用户配置文件——影子"><a href="#8-2用户配置文件——影子" class="headerlink" title="8.2用户配置文件——影子"></a>8.2用户配置文件——影子</h2><p>1、影子文件/etc/shadow</p><pre><code>第1字段：用户名第2字段：加密密码     加密算法升级为SHA512散列加密算法     如果密码位是“!!”或“*”代表没有密码，不能登录第3字段：密码最后一次修改日期    使用1970年1月1日作为标准时间，每过一天时间戳加1第4字段：两次密码的修改间隔时间（和第三字段相比）    # 0代表随时可以修改密码，10代表10天后才能修改密码第5字段：密码有效期（和第3字段相比）第6字段：密码修改到期前的警告天数（和第5字段相比）第7字段：密码过期后的宽限天数（和第5字段相比）    0：代表密码过期后立即失效    -1：则代表密码永远不会失效。第8字段：账号失效时间  （到了不管过期 6 7）    要用时间戳表示第9阶段：保留</code></pre><p>2、时间戳换算</p><pre><code>把时间戳换算为日期    >> date -d "1970-01-01 16066 days"把日期换算为时间戳    >> echo $(($(date --date="2014/01/06" +%s)/86400 +1))</code></pre><h2 id="8-3用户配置文件——组件"><a href="#8-3用户配置文件——组件" class="headerlink" title="8.3用户配置文件——组件"></a>8.3用户配置文件——组件</h2><p>1、组信息文件/etc/group</p><pre><code>第1字段：组别第2字段：组密码标志第3阶段：GID第4字段：组中附加用户</code></pre><p>2、组密码文件/etc/gshadow</p><pre><code>第1字段：组别第2字段：组密码第3阶段：组管理员用户名第4字段：组中附加用户</code></pre><h2 id="8-4用户管理相关文件"><a href="#8-4用户管理相关文件" class="headerlink" title="8.4用户管理相关文件"></a>8.4用户管理相关文件</h2><p>用户的家目录</p><blockquote><p>普通用户：/home/用户名/，所有者和所属组都是此用户，权限是700<br>超级用户：/root/，所有者和所属组都是root用户，权限是550</p></blockquote><h2 id="8-5用户管理命令"><a href="#8-5用户管理命令" class="headerlink" title="8.5用户管理命令"></a>8.5用户管理命令</h2><ul><li><p>useradd命令</p><blockquote><p>useradd[选项] 用户名</p><pre><code>-u UID：手工指定用户的UID号-d 家目录 手工指定用户的家目录-c 用户说明 手工指定用户的说明-g 组名 手工指定用户的初始组-G 组名 指定用户的附加组-s shell 手工指定用户的登录shell。默认是/bin/bash</code></pre></blockquote></li><li><p>passwd命令格式</p><blockquote><p>passwd[选项] 用户名</p><pre><code>-S 查询用户密码的密码状态。仅root用户可用。-l 暂时锁定用户。仅root用户可用。-u 解锁用户。仅root用户可用。--stdin 可以通过管道符输出的数据作为用户的密码。</code></pre></blockquote></li><li><p>修改用户信息usermod</p><blockquote><p>usermod[选项] 用户名</p><pre><code>-u UID 修改用户的uid号-c 用户说明 修改用户的说明信息 -G  组名 修改用户附加组-L 临时锁定用户(lock)-U 解锁用户锁定（Unlock）</code></pre></blockquote></li><li><p>修改用户密码状态chage</p><blockquote><p>chage[选项] 用户名</p><pre><code>-l  列出用户的详细密码状态-d 日期 修改密码最后一次更改时间（shadow3字段）-m 天数 两次密码修改间隔（4字段）-M 天数 密码有效期（5字段）-W 天数 密码过期前警告天数（6字段）-l 天数 密码过期后宽限天数（7字段）-E 日期 账号失效时间（8字段）</code></pre></blockquote></li><li><p>删除用户userdel</p><blockquote><p>userdel[-r] 用户名</p><pre><code>-r 删除用户的同时删除用户家目录</code></pre></blockquote></li><li><p>切换用户身份su</p><blockquote><p>su [选项] 用户名</p><pre><code>- 选项只使用“-”代表连带用户的环境变量一起切换  -c命令 仅执行一次命令，而不切换用户身份</code></pre></blockquote></li></ul><h1 id="九、压缩解压命令"><a href="#九、压缩解压命令" class="headerlink" title="九、压缩解压命令"></a>九、压缩解压命令</h1><p>tar命令</p><p>　　解包：tar zxvf FileName.tar</p><p>　　打包：tar czvf FileName.tar DirName</p><h1 id="十、网络命令"><a href="#十、网络命令" class="headerlink" title="十、网络命令"></a>十、网络命令</h1><h2 id="10-1write-给用户发信息"><a href="#10-1write-给用户发信息" class="headerlink" title="10.1write 给用户发信息"></a>10.1write 给用户发信息</h2><blockquote><p>网络 w命令查看用户在线情况</p><p>打开两个窗体（写错的时候 退格键 ctrl+backspace键）</p><p>写好了 ctrl+D保存结束</p><p>远程终端第一个0</p><p>终结符EOF</p></blockquote><h2 id="10-2wall-【message】-发广播信息"><a href="#10-2wall-【message】-发广播信息" class="headerlink" title="10.2wall 【message】 发广播信息"></a>10.2wall 【message】 发广播信息</h2><p>广播信息 在线用户</p><h2 id="10-5ping-测试网络连通性"><a href="#10-5ping-测试网络连通性" class="headerlink" title="10.5ping 测试网络连通性"></a>10.5ping 测试网络连通性</h2><p>ping 选项 IP地址</p><p>-C 指定发送次数</p><h2 id="10-4ifconfig-查看和设置网卡信息"><a href="#10-4ifconfig-查看和设置网卡信息" class="headerlink" title="10.4ifconfig 查看和设置网卡信息"></a>10.4ifconfig 查看和设置网卡信息</h2><p>eth0第一块网卡</p><p>Ethernet网络昵称以太网 网络类型目前我们接触的都是以太网</p><p>Hwaddr 网卡的物理地址</p><p>Inet addr 当前计算机地址</p><p>Bcast 发送广播的ip地址</p><p>Mask 子网掩码网掩码只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分</p><p>Rx接受数据包数量 byte 接收到的数据包的总大小</p><p>TX发送数据包数量</p><p>Interrupt 网卡在内存中的物理地址</p><p>Lo回环网卡每台机器都有用来做本机网络测试的</p><h2 id="10-5mail-查看发送电子邮件"><a href="#10-5mail-查看发送电子邮件" class="headerlink" title="10.5mail 查看发送电子邮件"></a>10.5mail 查看发送电子邮件</h2><p>不在线也能收到</p><p>收到直接数据mail 直接回车</p><p>n代表没有读的邮件 1代表一份邮件 输入1回车查看第一份信内容</p><h2 id="10-6last-列出目前与过去登入系统的用户信息"><a href="#10-6last-列出目前与过去登入系统的用户信息" class="headerlink" title="10.6last 列出目前与过去登入系统的用户信息"></a>10.6last 列出目前与过去登入系统的用户信息</h2><ul><li>计算机所有用户登录系统信息</li><li>dj pts/1 192.168.40.1 Thu Mar  7 13:04  still logged in </li><li>第二个远程终端 登录的远程ip    一直在登录</li></ul><h2 id="10-7netstat-【选项】-显示网络相关信息"><a href="#10-7netstat-【选项】-显示网络相关信息" class="headerlink" title="10.7netstat 【选项】  显示网络相关信息"></a>10.7netstat 【选项】  显示网络相关信息</h2><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:right">用途</th></tr></thead><tbody><tr><td style="text-align:left">-t</td><td style="text-align:right">TCP协议</td></tr><tr><td style="text-align:left">-u</td><td style="text-align:right">UDP协议</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:right">监听</td></tr><tr><td style="text-align:left">-r</td><td style="text-align:right">路由</td></tr><tr><td style="text-align:left">-n</td><td style="text-align:right">显示IP地址和端口号</td></tr></tbody></table><p>范例</p><ul><li>netstat -tlun 查看本机监听的端口</li><li>netstat -an 查看本机所有的网络连接</li><li>netstat -rn 查看本机路由器</li><li>netstat -ntlp</li></ul><ul><li>Tcp http 用的协议 三次握手  安全可靠    传输  打电话</li><li>Udp  快 发短信 端口 ip地址为公司名字 找某人 就是端口</li><li><p>Destination Gateway Genmask  Flags   MSS Window  irtt Iface</p></li><li><p>setup 配置网络</p></li><li><ul><li>dhcp 自动分配自动获取服务 * 默认相当于windows自动获取ip地址没有用，原因个人电脑和家里的环境不会有路由分配。</li></ul></li><li><ul><li>setup操作结束后 使用 service network restart命令</li></ul></li></ul><h1 id="十一、shell概述"><a href="#十一、shell概述" class="headerlink" title="十一、shell概述"></a>十一、shell概述</h1><blockquote><p>hell是一个命令行解释器。<br>它为用户提供了一个向linux内核发送请求以便运行程序的界面系统级程序。<br>用户可以用shell来启动、挂起、停止甚至是编写一些程序。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/20190515064108763.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>注释：</p><blockquote><p>内核 机器语言01010<br>外层 pwd ls命令<br>shell就是黑色及交互命令窗体</p></blockquote><p>shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。shell是解释执行的脚本语言，在shell中可以直接调用Linux系统命令。</p><ul><li><p>shell的分类</p><blockquote><p>1、Bourne Shell: 从1979起Unix就开始使用Bourne Shell，Bourne Shell的主文件名为sh。</p><p>2、 C Shell： C Shell主要在BSD版的Unix系统中使用，其语法和C语言相类似而得名。</p><p>shell的两种语法类型有Bourne和C，这两种语法彼此不兼容。Bourne家族主要包括sh、ksh、Bash、psh、zsh；C家族主要包括：csh、tcsh</p><p>linux标准shell是伯恩 shell bash ei</p><p>Bash:Bash与sh兼容，现在使用的linux就是使用bash作为用户的基本shell。 </p></blockquote></li><li><p>linux支持的shell</p><blockquote><p>/etc/shells</p></blockquote></li></ul><h2 id="11-1shell脚本运行"><a href="#11-1shell脚本运行" class="headerlink" title="11.1shell脚本运行"></a>11.1shell脚本运行</h2><p><strong>echo输出命令</strong></p><blockquote><p>echo [选项] [输出内容]<br>   -e 支持反斜线控制的字符转换<br>转移符 echo -e ‘\e[1,31m abcd \e[0m’ 变色</p></blockquote><h2 id="11-2linux标准shellbase"><a href="#11-2linux标准shellbase" class="headerlink" title="11.2linux标准shellbase"></a>11.2linux标准shellbase</h2><p><strong>历史命令</strong></p><blockquote><p>history [选项] [历史命令保存文件]<br>    -c 清空历史记录<br>    -W 把缓存中的历史命令写入历史命令保存文件 ~/.bash_history</p></blockquote><pre><code>历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改</code></pre><h2 id="11-2标准输入输出"><a href="#11-2标准输入输出" class="headerlink" title="11.2标准输入输出"></a>11.2标准输入输出</h2><table><thead><tr><th style="text-align:center">设备</th><th style="text-align:center">设备文件名</th><th style="text-align:center">文件描述符</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">键盘</td><td style="text-align:center">/dev/stdin</td><td style="text-align:center">0</td><td style="text-align:center">标准输入</td></tr><tr><td style="text-align:center">显示器</td><td style="text-align:center">/dev/sdtout</td><td style="text-align:center">1</td><td style="text-align:center">标准输出</td></tr><tr><td style="text-align:center">显示器</td><td style="text-align:center">/dev/sdterr</td><td style="text-align:center">2</td><td style="text-align:center">标准错误输出</td></tr></tbody></table><h1 id="11-3输出重定向"><a href="#11-3输出重定向" class="headerlink" title="11.3输出重定向"></a>11.3输出重定向</h1><table><thead><tr><th>类型</th><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>标准输出重定向</td><td>命令 > 文件</td><td>以覆盖的方式，把命令中的正确输出输出到指定的文件或设备当中</td></tr><tr><td>标准输出重定向</td><td>命令 >> 文件</td><td>以追加的形式，把命令中的正确输出输出到指定的文件或设备当中</td></tr><tr><td>标准错误输出重定向</td><td>错误命令 2>文件</td><td>以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中</td></tr><tr><td>标准错误输出重定向</td><td>错误命令 2>>文件</td><td>以追加的形式，把命令的错误输出输出到指定的文件或设备当中</td></tr></tbody></table><h2 id="13-4输入重定向"><a href="#13-4输入重定向" class="headerlink" title="13.4输入重定向"></a>13.4输入重定向</h2><blockquote><p>命令<文件 文件作为命令的输入</p><p>wc [选项] [文件名]<br>    -c 统计字节数<br>    -w 统计单词数<br>    -l 统计行数</p></blockquote><h2 id="13-5多命令顺序执行"><a href="#13-5多命令顺序执行" class="headerlink" title="13.5多命令顺序执行"></a>13.5多命令顺序执行</h2><table><thead><tr><th style="text-align:center">多命令执行符</th><th style="text-align:center">格式</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">;</td><td style="text-align:center">命令1；命令2</td><td style="text-align:center">多个命令顺序执行，明明之间没有任何逻辑联系</td></tr><tr><td style="text-align:center">&&</td><td style="text-align:center">命令1&&命令2</td><td style="text-align:center">逻辑与，当命令1正确执行，则命令2才会执行，当命令1执行不正确，则命令2不会执行</td></tr><tr><td style="text-align:center">||</td><td style="text-align:center">命令1||命令2</td><td style="text-align:center">逻辑或，当命令1执行不正确，则命令2才会执行，当命令1正确执行，命令2不会执行</td></tr></tbody></table><h2 id="11-3shell变量"><a href="#11-3shell变量" class="headerlink" title="11.3shell变量"></a>11.3shell变量</h2><p><strong>变量的定义</strong></p><blockquote><p>变量是计算机内存的单元，其中存放的值可以改变。<br>如shell脚本需要保存一些信息时，如一个文件名或是一个数字，就把它存放在一个变量中。<br>每个变量有一个名字，所以很容易引用它。<br>使用变量可以保存有用信息，使系统获知用户相关设置，变量也可以用于保存暂时信息。</p></blockquote><p><strong>变量设置规则</strong></p><blockquote><p>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。</p><p>Bash中，变量的默认类型都是字符串型，如果要进行数值运算，则必须制定变量类型为数值型。</p><p>变量用等号连接值，等号左右两侧不能有空格。</p><p>变量的值如果有空格，需要使用单引号或双引号包括。</p><p>在变量的值中，可以使用“\”转译符</p><p>如果需要增加变量的值，可以进行变量的叠加。不过变量需要用双引号包含“$变量名”或用${变量名}包含</p></blockquote><p><strong>变量分类</strong></p><blockquote><p>用户自定义变量</p><p>环境变量：这种变量中主要保存的是和系统操作环境相关的数据。</p><p>位置参数变量：这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</p><p>预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</p></blockquote><p>例：用户自定义变量</p><pre><code>>name="xifu" #变量定义>#变量叠加>aa=123>aa="$aa"456>aa=${aa}789>echo $name #变量调用>set #变量查看> unset name #变量删除</code></pre><p><strong>环境变量</strong>   </p><blockquote><p>用户自定义变量只在当前的shell中生效，<br>而环境变量会在当前shell和这个shell的所有子shell中生效。<br>如果把环境变量写入相应的配置文件，<br>name这个环境变量就会在所有的shell中生效。</p></blockquote><p><strong>环境变量语法</strong></p><blockquote><p>export 变量名=变量值  #申明变量<br>env #查询变量<br>unset 变量名 #删除变量</p></blockquote><p><strong>位置参数变量</strong></p><table><thead><tr><th>位置参数变量</th><th>作用</th></tr></thead><tbody><tr><td>$n</td><td>n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}</td></tr><tr><td>$*</td><td>这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体</td></tr><tr><td>$@</td><td>这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</td></tr><tr><td>$#</td><td>这个变量代表命令行中所有参数的个数</td></tr></tbody></table><p>例1：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bash/bash</span><br><span class="line">num1=$1</span><br><span class="line">num2=$2</span><br><span class="line">sum=$(($num1+$num2))</span><br><span class="line">echo $sum #打印变量sum的值</span><br></pre></td></tr></tbody></table></figure><p>例2：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bash/bash</span><br><span class="line"><span class="meta">#</span>使用$#代表所有参数的个数</span><br><span class="line">echo 'A total of $# parameters'</span><br><span class="line"><span class="meta">#</span>使用$*代表所有参数</span><br><span class="line">echo 'The parameters is: $*'</span><br><span class="line"><span class="meta">#</span>使用$@代表所有参数</span><br><span class="line">echo 'The parameters is: $@'</span><br></pre></td></tr></tbody></table></figure><p><strong>预定义变量</strong></p><table><thead><tr><th>预定义变量</th><th>作用</th></tr></thead><tbody><tr><td>$?</td><td>最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。</td></tr><tr><td>$$</td><td>当前进程的进程号（PID）</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的进程号（PID）</td></tr></tbody></table><blockquote><p>&&  ||  是通过什么第二命令知道第一命令是否正常运行的呢   其实是通过$?的数字才判断的</p><p>程序员用户眼睛判断命令是否正确</p><p>计算机是通过$?判断命令是否正确</p></blockquote><p><strong>接收键盘输入</strong>        </p><blockquote><p>read<br>    -p “提示信息”：在等待read输入时，输出提示信息<br>    -t 描述 read命令会一直等待用户输入，使用此选项可以指定等待时间<br>    -n 字符数 read命令只接受指定的字符数，就会执行<br>    -s 隐藏输入的数据，适用于机密信息的输入</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>提示“请输入姓名”并等待30秒，把用户的输入保存入变量name中</span><br><span class="line">read -t 30 -p "Please input your name:" name</span><br><span class="line">echo "Name is $name"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>年龄是隐私，用“-s”选项隐藏输入</span><br><span class="line">read -s -t  30 -p "Please enter your age:" age</span><br><span class="line">echo -e "\n"</span><br><span class="line">echo "Age is $age"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>使用“-n 1”选项只接收一个输入字符就会执行（都不用输入回车）</span><br><span class="line">read -n 1 -t 30 -p "please select your gender[M/F]:" gender</span><br><span class="line">echo -e "\n"</span><br><span class="line">echo "sex is $gender"</span><br></pre></td></tr></tbody></table></figure><p><strong>declare声明变量类型</strong> </p><blockquote><p>declare [+/] [选项] [变量名]</p></blockquote><p>  给变量设定类型属性</p><p>  取消变量的类型属性<br>  -i 将变量声明为整数型（integer）<br>  -x 将变量声明为环境变量<br>  -p 显示指定变量的被声明的类型</p><p>例：方法一，数值运算——方法1    </p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line">给变量aa和bb赋值</span><br><span class="line">declare -i cc=$aa+$bb</span><br></pre></td></tr></tbody></table></figure><p>例：方法二，expr或let数值运算工具</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line"><span class="meta">#</span>给变量aa和bb赋值</span><br><span class="line">dd=$(expr $aa + $bb)</span><br><span class="line"><span class="meta">#</span>dd的值是aa和bb的和。注意“+”号左右两侧必须有空格</span><br></pre></td></tr></tbody></table></figure><p>例：方法三，”$((运算式))” 或”$[运算式]”</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aa=11</span><br><span class="line">bb=22</span><br><span class="line">ff=$(( $aa+$$bb ))</span><br><span class="line">gg=$[ $aa+$$bb ]</span><br><span class="line"><span class="meta">#</span>单个小括号是系统命令</span><br><span class="line"><span class="meta">#</span>双个小括号代表数值运算符</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>变量置换方式</th><th>变量y没有设置</th><th>变量y为空值</th><th>变量y设置值</th></tr></thead><tbody><tr><td>x=${y-新值}</td><td>x=新值</td><td>x为空值</td><td>x=$y</td></tr><tr><td>x=${y:-新值}</td><td>x=新值</td><td>x为新值</td><td>x=$y</td></tr><tr><td>x=${y+新值}</td><td>x为空</td><td>x为新值</td><td>x=新值</td></tr><tr><td>x=${y:+新值}</td><td>x为空</td><td>x为空值</td><td>x=新值</td></tr><tr><td>x=${y=新值}</td><td>x=新值，y=新值</td><td>x为空值，y值不变</td><td>x=$y，y值不变</td></tr><tr><td>x=${y:=新值}</td><td>x=新值，y=新值</td><td>x为新值，y为新值</td><td>x=$y，y值不变</td></tr><tr><td>x=${y?新值}</td><td>新值输出到标准错误输出</td><td>x为空值</td><td>x=$y</td></tr><tr><td>x=${y:?新值}</td><td>新值输出到标准错误输出</td><td>新值输出到标准错误输出</td><td>x=$y</td></tr></tbody></table><h1 id="十二、正则表达式"><a href="#十二、正则表达式" class="headerlink" title="十二、正则表达式"></a>十二、正则表达式</h1><blockquote><p>正则表达式用来在文件中匹配符合条件的字符串，正则是<code>包含匹配</code>。<code>grep</code>、<code>awk</code>、<code>sed</code>等命令可以支持正则表达式。</p><p>通配符用来匹配符合条件的文件名，通配符是<code>完全必配</code>。<code>ls</code>、<code>find</code>、<code>cp</code>这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配。</p></blockquote><table><thead><tr><th>元字符</th><th>作用</th></tr></thead><tbody><tr><td>*</td><td>前一个字符匹配0次或任意多次</td></tr><tr><td>.</td><td>匹配除了换行符外任意一个字符</td></tr><tr><td>^</td><td>匹配行首。</td></tr><tr><td>$</td><td>匹配行尾。</td></tr><tr><td>[]</td><td>匹配中括号中的任意一个字符，例如[a-z0-9]</td></tr><tr><td>[^]</td><td>匹配除中括号的字符以外的任意一个字符。[^a-z]</td></tr><tr><td>\</td><td>转义符</td></tr><tr><td>{n}</td><td>表示其前面的字符恰好出现几次</td></tr><tr><td>{n,}</td><td>表示其前面的字符出现不小于n次</td></tr><tr><td>{n,m}</td><td>表示前面的字符至少出现n次，最多出现m次。</td></tr></tbody></table><h1 id="十三、Linux-服务管理"><a href="#十三、Linux-服务管理" class="headerlink" title="十三、Linux 服务管理"></a>十三、Linux 服务管理</h1><h2 id="13-1服务管理分类"><a href="#13-1服务管理分类" class="headerlink" title="13.1服务管理分类"></a>13.1服务管理分类</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/20190515101608490.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>源码包可以看到源代码  可以自定义<br>Rpm没有源代码 自定义差</p><p>独立服务：服务直接在内存中 客户直接调用服务，服务直接相应用户，速度快，服务多了浪费内存资源<br>基于xinetd服务本身是独立的  本身没有功能，后面有一系列服务rsync 网络备份服务，通过xinted相应 rsync 相应最后客户端相应速度慢  本身不占用内存</p></blockquote><h2 id="13-2启动与自启动"><a href="#13-2启动与自启动" class="headerlink" title="13.2启动与自启动"></a>13.2<strong>启动与自启动</strong></h2><p>服务启动：就是当前系统让服务运行，并提供功能</p><p>服务自启动：是指让服务在系统开机或重启之后，随着系统的启动而自启动服务。</p><h2 id="13-3查询已安装的服务"><a href="#13-3查询已安装的服务" class="headerlink" title="13.3查询已安装的服务"></a>13.3查询已安装的服务</h2><p>RPM包安装的服务</p><p><code>chkconfig --list</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aegis           0:off   1:off   2:on    3:on    4:on    5:on    6:off</span><br><span class="line">bt              0:off   1:off   2:on    3:on    4:on    5:on    6:off</span><br><span class="line">netconsole      0:off   1:off   2:off   3:off   4:off   5:off   6:off</span><br><span class="line">network         0:off   1:off   2:on    3:on    4:on    5:on    6:off</span><br><span class="line">nginx           0:off   1:off   2:off   3:off   4:off   5:off   6:off</span><br><span class="line">    0关机   1单用户 2不完全多用户 3字符界面 4未分配 5图形界面 6重启动</span><br></pre></td></tr></tbody></table></figure><p>源码包安装的服务</p><blockquote><p>查看服务安装位置</p></blockquote><p>卸载</p><p><code>rpe -e  --nodeps（不检查依赖性）  包名</code></p><h1 id="十四、Linux系统备份与恢复"><a href="#十四、Linux系统备份与恢复" class="headerlink" title="十四、Linux系统备份与恢复"></a>十四、Linux系统备份与恢复</h1><h2 id="14-1备份和恢复概述"><a href="#14-1备份和恢复概述" class="headerlink" title="14.1备份和恢复概述"></a>14.1备份和恢复概述</h2><p> <strong>Linux系统中需要备份的数据</strong></p><blockquote><p>/root/目录</p><p>/home/目录</p><p>/var/spool/mail/目录</p><p>/etc/目录</p><p>其他目录</p></blockquote><h2 id="14-2-备份策略"><a href="#14-2-备份策略" class="headerlink" title="14.2 备份策略"></a>14.2 备份策略</h2><blockquote><p>完全备份：<br>    优点是数据恢复方便<br>    缺点备份的数据量较大,备份时间较长,占用的空间较大<br>增量备份：<br>    优点备份的数据较少，耗时较短，占用的空间较小；<br>    缺点是数据恢复比较麻烦，先恢复完全备份的数据每次增量备份的数据，最终才能恢复所有的数据。<br>差异备份：<br>    优点恢复数据简单方便快捷<br>    缺点数据量庞大、备份速度缓慢、占用空间较大。</p></blockquote><h2 id="14-3、备份和恢复命令"><a href="#14-3、备份和恢复命令" class="headerlink" title="14.3、备份和恢复命令"></a>14.3、备份和恢复命令</h2><blockquote><p>备份命令 dump [选项]备份之后的文件名 原文件或目录</p></blockquote><blockquote><p>恢复命令 restore [模式选项][选项]</p></blockquote><h1 id="十五、Linux系统管理"><a href="#十五、Linux系统管理" class="headerlink" title="十五、Linux系统管理"></a>十五、Linux系统管理</h1><h4 id="1、进程管理查看-ps-aux"><a href="#1、进程管理查看-ps-aux" class="headerlink" title="1、进程管理查看 ps aux"></a>1、进程管理查看 ps aux</h4><pre><code>用户   进程id  占用cpu  内存   内存daxiao 物理大 终端   状态 开始时间 占用cpu时间   命令USER       PID    %CPU %MEM    VSZ   RSS TTY      STAT START   TIME      COMMANDroot        1      0.5  0.0    2872  1416 ?        Ss   15:36   0:01   /sbin/initroot        2      0.0  0.0     0     0   ?        S    15:36   0:00   [kthreadd]</code></pre><h4 id="2、进程管理终止-kill命令"><a href="#2、进程管理终止-kill命令" class="headerlink" title="2、进程管理终止 kill命令"></a>2、进程管理终止 kill命令</h4><h4 id="3、工作管理"><a href="#3、工作管理" class="headerlink" title="3、工作管理"></a>3、工作管理</h4><h4 id="4、系统资源查看"><a href="#4、系统资源查看" class="headerlink" title="4、系统资源查看"></a>4、系统资源查看</h4><h4 id="5、系统定时任务"><a href="#5、系统定时任务" class="headerlink" title="5、系统定时任务"></a>5、系统定时任务</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Linux&quot;&gt;&lt;a href=&quot;#Linux&quot; class=&quot;headerlink&quot; title=&quot;Linux&quot;&gt;&lt;/a&gt;Linux&lt;/h1&gt;&lt;h1 id=&quot;一、Linux起源&quot;&gt;&lt;a href=&quot;#一、Linux起源&quot; class=&quot;headerlink&quot; title=&quot;一、Linux起源&quot;&gt;&lt;/a&gt;一、Linux起源&lt;/h1&gt;&lt;p&gt;Linux系统诞生于1991年，由芬兰大学生李纳斯（Linux Torvalds）。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HDFS上传和读取流程</title>
    <link href="https://xifujiang.github.io//posts/e4062a35/"/>
    <id>https://xifujiang.github.io//posts/e4062a35/</id>
    <published>2019-03-28T06:34:00.000Z</published>
    <updated>2020-01-13T02:45:22.343Z</updated>
    
    <content type="html"><![CDATA[<p></p><center>![Git][git]</center><p></p><h3 id="上传流程"><a href="#上传流程" class="headerlink" title="上传流程"></a>上传流程</h3><ul><li>1.根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在。</li><li>2.namenode返回是否可以上传</li><li><p>3.client请求第一个 block该传输到哪些datanode服务器上</p><a id="more"></a></li><li>4.namenode返回3个datanode服务器ABC</li><li>5.client请求3台dn中的一台A上传数据（本质上是一个RPC调用，建立pipeline），A收到请求会继续调用B，然后B调用C，将这个pipeline建立完成，逐级返回客户端</li><li>6.client开始往A上传第一个block（先从磁盘读取数据放到一个本地内存缓存），以packet为单位，A收到一个packet就会传给B，B传给C；A每传一个packet会放入一个应答队列等待应答</li><li>7.当一个block传输完成之后，client再次请求namenode上传第二个block的服务器。<h3 id="读取流程"><a href="#读取流程" class="headerlink" title="读取流程"></a>读取流程</h3>客户端读取HDFS数据相比写入数据要简单一些，以下是读取数据步骤：</li><li>1.client访问NameNode，查询元数据信息，获得这个文件的数据块位置列表，返回输入流对象。</li><li>2.就近挑选一台datanode服务器，请求建立输入流。</li><li>3.开始读取这个数据的第一个block块，读取完全之后，开始接着读取这个文件的第二个block，直至把这个数据所有的block都读完了则文件读取完全了。</li><li>4.数据读完之后关闭流连接。</li><li>5.如果读取过程当中读取失败，将会依次读取该数据块的下一个副本，失败的节点将会被记录，不再连接。</li></ul><p>￼# SecondaryNameNode<br>SecondaryNameNode 是 HDFS 架构中的一个组成部分，它用来保存名称节点中对HDFS元数据信息的备份，减小Editlog文件大小，从而缩短名称节点重启的时间。 它一般是单独运行在一台机器上。 SecondaryNameNode让EditLog变小的工作流程如下: </p><ul><li>(1)SecondaryNameNode 会定期和 NameNode 通信，请求其停止使用 EditLog 文件，暂时将 新的写操作写到一个新的文件 edit.new 中，这个操作是瞬间完成的，上层写日志的函数完全感觉不到差别。 </li><li>(2) SecondaryNameNode 通过 HTTP GET 方式从 NameNode 上获取到 Fslmage 和 EditLog 文 件，井下载到本地的相应目录下。 </li><li>(3) SecondaryNameNode 将下载下来的 Fslmage 载入到内存，然后一条一条地执行 EditLog 文件中的各项更新操作，使内存中的 Fslmage 保持最新。 这个过程就是 EditLog 和 Fslmage 文件合 井。 </li><li>(4) SecondaryNameNode 执行完（3）操作之后，会通过 post 方式将新的 Fslmage 文件发送 到 NameNode 节点上</li><li>(5) NameNode 将从 SecondaryNameNode 接收到的新的 Fslmage 替换旧的 Fslmage 文件，同 时将 Edit.new 替换 EditLog 文件，从而减小 EditLog 文件大小。<br>￼<br>从上面的过程可以看出，第二名称节点相当于为名称节点设置一个“检查点” ，周期性备份 名称节点中的元数据信息，但第二名称节点在 HDFS 设计中只是一个冷备份，并不能起到“热备 份”的作用。 HDFS 设计并不支持当名称节点故障时直接切换到第二名称节点。</li></ul><p>HDFS Federation<br>HDFSl.O 的单 NameNode 设计不仅存在单点故障问题，还存在可扩展性和性能问题。只有一 个 NameNode， 不利于水平扩展。 HDFS Federation (HDFS 联邦）特性允许一个 HDFS 集群中存在 多个 NameNode 同时对外提供服务，这些 NameNode 分管一部分目录（水平切分），彼此之间相 互隔离，但共享底层的 DataNode 存储资源。每个 NameNode 是独立的，不需要和其他 Nam巳Node 协调合作。 如图 4-5 所示 ， Federation 使用了 多 个独立的 NameNode/NameSpace 命名空间。这些 NameNode 之间是联合的，也就是说， 它们之间相互独立且不需要互相协调，各自分工管理自己的 区域。分布式的 DataNode 被用作通用的数据块存储设备。每个 DataNode 要向集群中所有的 NameNode 注册，且周期性地向所有 NameNode 发送心跳和块报告， 并执行来自所有 NameNode 的命令。每一个 DataNode 作为统一的块存储设备被所有 NameNode 节点使用。 每一个 DataNode 节点都在所有的 NameNode 进行注册。 DataNode 发送心跳信息、块报告到 所有 NameNode，同时执行所有 NameNode 发来的命令。<br>￼</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;/p&gt;&lt;center&gt;![Git][git]&lt;/center&gt;&lt;p&gt;&lt;/p&gt;
&lt;h3 id=&quot;上传流程&quot;&gt;&lt;a href=&quot;#上传流程&quot; class=&quot;headerlink&quot; title=&quot;上传流程&quot;&gt;&lt;/a&gt;上传流程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1.根namenode通信请求上传文件，namenode检查目标文件是否已存在，父目录是否存在。&lt;/li&gt;
&lt;li&gt;2.namenode返回是否可以上传&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3.client请求第一个 block该传输到哪些datanode服务器上&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>bat批量存放信息到excel</title>
    <link href="https://xifujiang.github.io//posts/5fe19fd1/"/>
    <id>https://xifujiang.github.io//posts/5fe19fd1/</id>
    <published>2019-03-28T06:34:00.000Z</published>
    <updated>2020-01-13T07:06:23.582Z</updated>
    
    <content type="html"><![CDATA[<p>情景：最近喵仙子有个需求，需要抽取日志文件中的有效信息到excel，刚开始我用MapReduce给他做了一份，不过他有点蠢配不了环境，于是乎我研究了下bat，终于给他整了个好方法，请看下文。</p><a id="more"></a><p><code>需求</code><br>需要从log中抽取两列数据到excel中。</p><p>本西芙没了解过bat语法，所以查了一下，通过结合这两篇解答完成bat命令。<br>1、实现了按照空格批处理分割txt数据，存储excel<br><a href="https://zhidao.baidu.com/question/1770548208106936980.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1770548208106936980.html</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">rem 保存为bat文件跟txt文件放一起运行</span><br><span class="line">md "结果\" 2>nul</span><br><span class="line">for /f "delims=" %%a in ('dir /a-d/b *.txt') do (</span><br><span class="line">    setlocal EnableDelayedExpansion</span><br><span class="line">    (for /f "delims=" %%b in ('type "%%a"') do (</span><br><span class="line">        set "str=%%b"</span><br><span class="line">        echo;!str: =,!</span><br><span class="line">    ))>"结果\%%~na.csv"</span><br><span class="line">    Endlocal</span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></tbody></table></figure><p></p><p>2、批处理分割字符串<br><a href="https://blog.csdn.net/zhju85126com/article/details/46649961" target="_blank" rel="noopener">https://blog.csdn.net/zhju85126com/article/details/46649961</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set str=100x200x300y400y500x600y700</span><br><span class="line">for /f "tokens=1,3-5,* delims=x|y" %%a in ("%str%") do (</span><br><span class="line">set c1=%%a</span><br><span class="line">set c3=%%b</span><br><span class="line">set c4=%%c</span><br><span class="line">set c5=%%d</span><br><span class="line">set c6=%%e</span><br><span class="line">)</span><br><span class="line">echo %c1%, %c3%, %c4%, %c5%, %c6%</span><br><span class="line">pause</span><br><span class="line">rem 输出结果为输出结果为：100, 300, 400, 500, 600y700。其中tokens=1,3-5,*表示提取第1、3至5列，同时把第5列后所有剩余字符串作为第6列，一个输出了5个变量，也可以写作tokens=1,3,4,5,*。</span><br></pre></td></tr></tbody></table></figure><p></p><p>最终我所加工的代码，其中代码中<code>tokens=1,2</code>是按照<code>_</code>或<code>空格</code>分割的位置，相当于数组的某一元素、把它赋值给str1<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">md "结果\" 2>nul</span><br><span class="line">rem 循环数据</span><br><span class="line">for /f "delims=" %%a in ('dir /a-d/b *.log') do (</span><br><span class="line">    setlocal EnableDelayedExpansion</span><br><span class="line">    rem 切割方式    </span><br><span class="line">    (for /f "tokens=1,2 delims=_| " %%b in ('type "%%a"') do (</span><br><span class="line">        set "str1=%%b %%c"</span><br><span class="line">        echo;!str1: =,!</span><br><span class="line">    ))>"结果\%%~na.csv"</span><br><span class="line">    Endlocal</span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></tbody></table></figure><p></p><p>首先根据第一篇解答套入转excel模板，其次根据第二篇解答对bat for循环中分割和选取的描述，修改第五行代码。可以实现。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><ul><li>文件内容<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/log%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9.png" alt="文件内容" title>                </div>                <div class="image-caption">文件内容</div>            </figure></li><li>目录下的文件<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/01.png" alt="目录下的文件" title>                </div>                <div class="image-caption">目录下的文件</div>            </figure>2、点击<code>aa.bat</code>,生成csv文件<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/csv列表展示.png" alt="生成csv文件" title>                </div>                <div class="image-caption">生成csv文件</div>            </figure>3、任意打开一个csv文件<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://47.103.115.69/pic/csv文件.png" alt="csv文件内容" title>                </div>                <div class="image-caption">csv文件内容</div>            </figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;情景：最近喵仙子有个需求，需要抽取日志文件中的有效信息到excel，刚开始我用MapReduce给他做了一份，不过他有点蠢配不了环境，于是乎我研究了下bat，终于给他整了个好方法，请看下文。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
